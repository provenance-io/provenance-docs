"use strict";(self.webpackChunkprovenance_blockchain_developer_portal=self.webpackChunkprovenance_blockchain_developer_portal||[]).push([[7125],{40519:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(74848),i=n(28453);const o={},r="Loan Servicing",s={id:"learn/provenance-applications/loan-origination-system-los/loan-validation/loan-servicing",title:"Loan Servicing",description:"After the Figure loan is onboarded, funded, and validated, the loan is onboarded to the Figure Servicing system. This exchange also takes place through a BlockVault client-side contract execution, now utilizing the multi-party capabilities of the BlockVault Contract Execution Environment.",source:"@site/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/loan-servicing.md",sourceDirName:"learn/provenance-applications/loan-origination-system-los/loan-validation",slug:"/learn/provenance-applications/loan-origination-system-los/loan-validation/loan-servicing",permalink:"/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/loan-servicing",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{}},c={},l=[];function d(e){const t={code:"code",h1:"h1",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"loan-servicing",children:"Loan Servicing"}),"\n",(0,a.jsx)(t.p,{children:"After the Figure loan is onboarded, funded, and validated, the loan is onboarded to the Figure Servicing system. This exchange also takes place through a BlockVault client-side contract execution, now utilizing the multi-party capabilities of the BlockVault Contract Execution Environment."}),"\n",(0,a.jsx)(t.p,{children:"Partial example of an \u201cassign-to-servicing\u201d contract to onboard a loan into the servicing system:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-kotlin",children:'@Participants([ORIGINATOR, SERVICER])\nopen class AssignLoanToServicer(\n        // ------------------------------------\n        // These are Cross-Scope Facts coming from the loan scope. They do not become facts in the scope\n        // in which this contract is executed.\n        // ------------------------------------\n        // Facts are alphabetical by fact name:\n        @Fact(LoanScopeFacts.additionalParties) private val additionalParties: LoanProtos.PartiesList,\n        @Fact(LoanScopeFacts.blockchainCustody) private val blockchainCustody: LoanProtos.BlockchainCustody,\n        @Fact(LoanScopeFacts.creditReports) private val creditReports: LoanProtos.CreditReportsList,\n        @Fact(LoanScopeFacts.digitalSignaturePackets) private val digitalSignaturePackets: DocumentProtos.DocumentWithDataList,\n        @Fact(LoanScopeFacts.documents) private val documents: DocumentProtos.DocumentList,\n        @Fact(LoanScopeFacts.funding) private val funding: LoanProtos.Funding,\n        @Fact(LoanScopeFacts.incomeRecords) private val incomeRecords: LoanProtos.IncomeRecordsList,\n        @Fact(LoanScopeFacts.loan) private val loan: LoanProtos.Loan,\n        @Fact(LoanScopeFacts.primaryParty) private val primaryParty: CustomerProtos.Party,\n        @Fact(LoanScopeFacts.servicing) private val servicing: io.provenance.proto.asset.LoanProtos.LoanServicing,\n        @Fact(LoanScopeFacts.signedPromNote) private val signedPromNote: DocumentProtos.Disclosure,\n        @Fact(LoanScopeFacts.triMergeReports) private val triMergeReports: LoanProtos.TriMergeReportsList,\n        @Fact(LoanScopeFacts.underwritingPacket) private val underwritingPacket: UnderwritingProtos.UnderwritingPacket\n) : P8eContract() {\n\n    @Function(SERVICER)\n    @Fact(LoanScopeFacts.servicingScopeId)\n    fun validateServicingRequirements(@Input(LoanScopeFacts.servicingScopeId) servicingScopeId: Util.UUID ) : Util.UUID = servicingScopeId.also {\n\n        // "loan" fact validation\n        val selectedOffer = underwritingPacket.selectedOffer\n        ValidationUtil.validateMoneyField(selectedOffer, selectedOffer.amount, "amount")?.also { failure(it) }\n        ValidationUtil.validateMoneyField(selectedOffer, selectedOffer.drawAmount, "drawAmount")?.let { failure(it) }\n        ValidationUtil.validateMoneyField(loan, loan.monthlyPaymentAmount, "monthlyPaymentAmount")?.also { failure(it) }\n        if (selectedOffer.amount.isValidSrv() && selectedOffer.drawAmount.isValidSrv()) {\n            val originationFeeAmount = view.originationFeeAmount\n            groupedRule("Derived origination fee should be at least zero, but was [amount (${view.loanAmount}) - drawAmount (${view.drawAmount}) = origination fee ($originationFeeAmount)]", {\n                originationFeeAmount gte BigDecimal.ZERO\n            }, ONBOARDING to FATAL, UPDATE to WARN)\n            if (originationFeeAmount gt BigDecimal.ZERO) {\n                rule("Loans with an origination fee should have an origination fee type, but had type [${view.originationFeeType}]") {\n                    selectedOffer.origFeeType.let { it.isNotBlank() && it != NO_FEE }\n                }\n            }\n        }\n\n        // "primary_party" fact validation\n        rule("Primary borrower was missing uuid") {\n            primaryParty.hasUuid()\n        }\n        rule("Primary borrower was missing name details. First Name: [${primaryParty.name.firstName}] | Last Name: [${primaryParty.name.lastName}]") {\n            primaryParty.hasName() && primaryParty.name.firstName.isNotBlank() && primaryParty.name.lastName.isNotBlank()\n        }\n\n        // "funding" fact validation\n        rule("Funding must have valid start/complete") { funding.completedDate.isValidSrv() && funding.startedDate.isValidSrv() }\n        rule("Funding must be set true") { funding.complete }\n        rule("Funding block must be non-default") { funding.isValidSrv() }\n        rule("Funding start is too early") { funding.startedDate.toCSTLocalDateSrv().isAfterInclusiveSrv(ValidationUtil.EARLIEST_DATE_ALLOWABLE.toLocalDate()) }\n        rule("Funding complete is too early") { funding.completedDate.toCSTLocalDateSrv().isAfterInclusiveSrv(ValidationUtil.EARLIEST_DATE_ALLOWABLE.toLocalDate()) }\n        rule("Funding complete cannot be in the future") { funding.completedDate.toOffsetDateTimeProv().isBeforeInclusiveSrv(ServicingTimeUtil.getServerTime()) }\n'})}),"\n",(0,a.jsx)(t.p,{children:"The contract execution to handoff a loan to the servicer has several unique characteristics:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.code,{children:"@Participants"})," annotation on the class indicates that two parties are required to execute this contract, one acting in the role of ORIGINATOR and the counter-party in the role of SERVICER."]}),"\n",(0,a.jsx)(t.li,{children:"This contract is executed in a unique scope, distinct from the loan scope."}),"\n",(0,a.jsxs)(t.li,{children:["The facts supplied in the contract constructor are pre-existing facts. However, the loan facts exist in the loan scope, not the new scope created for the servicing handoff. Nonetheless, the loan scope facts in their current state can be supplied as inputs to the ",(0,a.jsx)(t.code,{children:"AssignLoanToServicerContract"})," as cross-scope facts."]}),"\n",(0,a.jsx)(t.li,{children:"The ORIGINATOR initiates the contract execution and supplies the cross-scope loan facts."}),"\n",(0,a.jsx)(t.li,{children:"The SERVICER supplies one additional input, the UUID of the new scope the servicer establishes in order to store loan servicing data."}),"\n",(0,a.jsx)(t.li,{children:"If any of the servicing checks in this contract fail, they will throw an Exception and fail the contract execution."}),"\n",(0,a.jsxs)(t.li,{children:["Either party can terminate the contract execution at any time during the process. When the servicer receives the request to execute the contract, the servicing system can perform checks about whether it is willing to jointly execute the contract with the originator. The servicing system will check, for example, that the public key of the originator matches one or more of the keys expected by the set of originators handled by the system, or it might check that the ",(0,a.jsx)(t.code,{children:"loan.loanType"})," is one the system knows how to service."]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var a=n(96540);const i={},o=a.createContext(i);function r(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);