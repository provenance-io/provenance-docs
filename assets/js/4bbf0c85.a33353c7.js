"use strict";(self.webpackChunkprovenance_blockchain_developer_portal=self.webpackChunkprovenance_blockchain_developer_portal||[]).push([[2524],{39317:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var o=a(85893),n=a(11151),i=a(98677);const s={},c="Metadata",r={id:"pb/modules/metadata-module",title:"Metadata",description:"Overview",source:"@site/docs/pb/modules/metadata-module.md",sourceDirName:"pb/modules",slug:"/pb/modules/metadata-module",permalink:"/docs/pb/modules/metadata-module",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"documentationSidebar",previous:{title:"Cosmos Modules",permalink:"/docs/pb/modules/cosmos-modules"},next:{title:"Marker",permalink:"/docs/pb/modules/marker-module"}},d={},l=[{value:"Overview",id:"overview",level:2},{value:"State Objects",id:"state-objects",level:3},{value:"Scope Data Structures",id:"scope-data-structures",level:3},{value:"Metadata Scope",id:"metadata-scope",level:4},{value:"Sessions",id:"sessions",level:4},{value:"Record",id:"record",level:4},{value:"Specification Structures",id:"specification-structures",level:3},{value:"Scope Specification",id:"scope-specification",level:4},{value:"Record Specification",id:"record-specification",level:4},{value:"Contract Specification",id:"contract-specification",level:4},{value:"Contract Memorialization",id:"contract-memorialization",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",ul:"ul",...(0,n.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"metadata",children:"Metadata"}),"\n","\n","\n",(0,o.jsx)(i.Y,{text:"The Metadata module provides an on-chain storage and assertion facility for side-chained data including assets-of-value and NFTs."}),"\n",(0,o.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.a,{href:"../p8e/overview/",children:"Provenance Blockchain Contract Execution Environment"})," (formerly nicknamed \u201cP8e\u201d) is an optional layer on top of the Provenance Blockchain to allow single and multi-party client-side contract execution while preserving data privacy and confidentiality. Provenance Blockchain client-side contracts take encrypted data from the user (client) and transform the information into encrypted data in the user\u2019s own private object store with the object hash-ids recorded on the blockchain."]}),"\n",(0,o.jsx)(t.p,{children:"Components of the BlockVault environment include a client-side contract execution engine, a locally-hosted encrypted object store, an Elasticsearch-based index into the encrypted object store, and a communication exchange for orchestrating multi-party contract execution with other parties\u2019 own BlockVault environments. Each BlockVault instance communicates with a blockchain node to submit transactions (contract execution hash records) to the Provenance Blockchain."}),"\n",(0,o.jsxs)(t.p,{children:["Applications use client-side BlockVault contracts and object stores for preserving the privacy and confidentiality of PII (Personally Identifying Information), sensitive data, and information related to non-fungible tokens. A hash commitment of the information and its state is captured in the Metadata Module. Effectively, BlockVault, from this perspective is simply a tool for structuring data to save on chain and isn\u2019t the primary focus of the metadata module. Thus BlockVault serves as ",(0,o.jsx)(t.em,{children:"a"})," side-chain information workflow manager and the Metadata Module is the ultimate on-chain state store."]}),"\n",(0,o.jsx)(t.admonition,{type:"info",children:(0,o.jsxs)(t.p,{children:["The Metadata Module provides assertions about off-chain information, whereas representation of value and ownership are recorded in the ",(0,o.jsx)(t.a,{href:"/docs/pb/modules/marker-module",children:"Marker Module"}),"."]})}),"\n",(0,o.jsx)(t.h3,{id:"state-objects",children:"State Objects"}),"\n",(0,o.jsx)(t.p,{children:"The Metadata Modules manages state using 4 core state object structures:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Contracts executed by parties on a client-side contract execution environment"}),"\n",(0,o.jsx)(t.li,{children:"Records that represent the facts (data) pertinent to the contracts"}),"\n",(0,o.jsx)(t.li,{children:"Sessions to manage the parties that must sign, and the related input and output data that can be recorded"}),"\n",(0,o.jsx)(t.li,{children:"Scopes that wrap the Records (facts/data) and related Contracts that can mutate the Records in the Scope."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["These structures are used to efficiently store the state data in the Metadata Module. The core concept of the Metadata module is a ",(0,o.jsx)(t.code,{children:"Scope"})," that contains a list of ",(0,o.jsx)(t.code,{children:"Records"})," (facts). Updates to ",(0,o.jsx)(t.code,{children:"Scope"})," are performed in sessions with details persisted in a ",(0,o.jsx)(t.code,{children:"Session"}),". Each session contains a specification that details constraints on parties that must sign, inputs, and outputs that can be recorded. Each ",(0,o.jsx)(t.code,{children:"Scope"})," may contain a list of allowed specifications that may be used."]}),"\n",(0,o.jsx)(t.h3,{id:"scope-data-structures",children:"Scope Data Structures"}),"\n",(0,o.jsx)(t.h4,{id:"metadata-scope",children:"Metadata Scope"}),"\n",(0,o.jsx)(t.p,{children:"A metadata scope contains a collection of records of data, each made up of a hash, data type, and ownership information that establishes provenance."}),"\n",(0,o.jsx)(t.h4,{id:"sessions",children:"Sessions"}),"\n",(0,o.jsx)(t.p,{children:"Typically multiple records will be established within a scope at the same time (see: Contract Memorialization). A Session contains context for the recording of these records linking a set of records into a common process/ execution associated with a specification indicating allowed and required values."}),"\n",(0,o.jsx)(t.h4,{id:"record",children:"Record"}),"\n",(0,o.jsx)(t.p,{children:"A single record collects information about a process that generated it, a collection of inputs, and one or more outputs into a structure identified by a name that is unique within a scope."}),"\n",(0,o.jsx)(t.h3,{id:"specification-structures",children:"Specification Structures"}),"\n",(0,o.jsx)(t.p,{children:"Specifications are a hierarchy of references to existing on chain data as well as a list of requirements that incoming requests to record data against a scope must meet. Typical requirements included hashes that must be supplied corresponding to process/executable that must be ran, required signatures and sources of accounts that must sign requests, and allowed attributes/records that may be added to a scope."}),"\n",(0,o.jsx)(t.h4,{id:"scope-specification",children:"Scope Specification"}),"\n",(0,o.jsx)(t.p,{children:"The top level specification for a scope indicates a set of allowed Contract Specifications that are allowed to be used against a given scope to perform updates. Requests to record data that do not derive from these contract specifications are not allowed."}),"\n",(0,o.jsx)(t.h4,{id:"record-specification",children:"Record Specification"}),"\n",(0,o.jsx)(t.p,{children:"The specifics of which records are allowed within a group (and by extension the scope overall). These considerations include required inputs, output format, and parties that must be associated with any request to record."}),"\n",(0,o.jsx)(t.h4,{id:"contract-specification",children:"Contract Specification"}),"\n",(0,o.jsx)(t.p,{children:"The primary function of contract specifications is to denote the Contracts/Processes that will be used to manage the data within a scope. These specifications control what information may be recorded on chain. The use of definitions for inputs can build a chain of data references that must be in place in order for records to be added to the chain."}),"\n",(0,o.jsx)(t.p,{children:'For example, a contract Specification may list a record Specification that requires an input of type "Record" (indicating a reference to a scope/record must exist on chain) in order for a specific Consideration (process/method) to be executed and have an output specification ultimately result in a record added to the scope.'}),"\n",(0,o.jsx)(t.h3,{id:"contract-memorialization",children:"Contract Memorialization"}),"\n",(0,o.jsx)(t.p,{children:"Memorialization is the act of committing a contract execution and its associated records to the blockchain. When memorializing a contract the only pieces that matter are the results and facts. We scope these inside the contract_group structure to represent a scope around this information and keep the controlling parties (recitals) attached which prevents a co-mingling of the rights to change/update these records. The proof submitted to record the facts is part of the readset (the submitted Contract package) and is not important now that the information has been recorded. If the source is required it can be pulled from the ReadSet and referenced (or any of the members that stored it under the associated URI."})]})}function u(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},98677:(e,t,a)=>{a.d(t,{Y:()=>n});a(67294);var o=a(85893);const n=e=>{let{text:t}=e;return(0,o.jsx)("p",{className:"pb-5 mb-5 -mt-3 border-0 border-b border-b-gray-300 border-solid text-gray-500",children:t})}},11151:(e,t,a)=>{a.d(t,{Z:()=>c,a:()=>s});var o=a(67294);const n={},i=o.createContext(n);function s(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);