"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3417],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},l=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=p(n),f=i,h=u["".concat(s,".").concat(f)]||u[f]||d[f]||o;return n?a.createElement(h,r(r({ref:t},l),{},{components:n})):a.createElement(h,r({ref:t},l))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=f;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c[u]="string"==typeof e?e:i,r[1]=c;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},8677:(e,t,n)=>{n.d(t,{Y:()=>i});var a=n(7294);const i=e=>{let{text:t}=e;return a.createElement("p",{className:"pb-5 mb-5 -mt-3 border-0 border-b border-b-gray-300 border-solid text-gray-500"},t)}},9565:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>c,default:()=>f,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905)),o=n(8677);const r={},c="Specifications",s={unversionedId:"pb/p8e/p8e-usage/specifications",id:"pb/p8e/p8e-usage/specifications",title:"Specifications",description:"Contract Specifications",source:"@site/docs/pb/p8e/p8e-usage/specifications.md",sourceDirName:"pb/p8e/p8e-usage",slug:"/pb/p8e/p8e-usage/specifications",permalink:"/docs/pb/p8e/p8e-usage/specifications",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"documentationSidebar",previous:{title:"Architecture",permalink:"/docs/pb/p8e/p8e-usage/architecture"},next:{title:"Building New BlockVault Contracts",permalink:"/docs/pb/p8e/p8e-usage/building-new-contracts"}},p={},l=[{value:"Contract Specifications",id:"contract-specifications",level:2},{value:"Description of annotations",id:"description-of-annotations",level:3},{value:"Scope Specifications",id:"scope-specifications",level:2},{value:"Publishing",id:"publishing",level:2}],u={toc:l},d="wrapper";function f(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"specifications"},"Specifications"),(0,i.kt)(o.Y,{text:"Before you are able to execute BlockVault contracts, you must first publish specifications to Provenance Blockchain. These specifications define the ruleset that govern contracts.",mdxType:"DocSubheader"}),(0,i.kt)("h2",{id:"contract-specifications"},"Contract Specifications"),(0,i.kt)("p",null,"Contract specifications define all the information for a contract. When a contract is executed, it is validated against the associated specification. The specification includes information such as parties with their roles, inputs/outputs of records, preconditions, as well as cross scope records. The following examples can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/provenance-io/p8e-gradle-plugin/tree/main/example-kotlin"},"here"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'@Participants(roles = [OWNER])\n@ScopeSpecification(names = ["io.p8e.contracts.examplekotlin.helloWorld"])\nopen class HelloWorldContract(): P8eContract() {\n    @Function(invokedBy = OWNER)\n    @Record(name = "name")\n    open fun name(@Input(name = "name") name: ExampleName) =\n        name.toBuilder()\n            .setFirstName(name.firstName.plus("-hello"))\n            .setLastName(name.lastName.plus("-world"))\n            .build()\n}\n')),(0,i.kt)("h3",{id:"description-of-annotations"},"Description of annotations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Participants - The party types associated with this specification"),(0,i.kt)("li",{parentName:"ul"},"ScopeSpecification - All the scopes, by name, that can execute this contract"),(0,i.kt)("li",{parentName:"ul"},"Function - Specifies a function and which party is responsible for running it"),(0,i.kt)("li",{parentName:"ul"},"Input - A function parameter"),(0,i.kt)("li",{parentName:"ul"},"Record - The output of the associated function will be saved as this")),(0,i.kt)("p",null,"Contract specifications are dehydrated into a protobuf representation."),(0,i.kt)("h2",{id:"scope-specifications"},"Scope Specifications"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'@ScopeSpecificationDefinition(\n    uuid = "<UUID>",\n    name = "io.p8e.contracts.examplekotlin.helloWorld",\n    description = "A generic scope that allows for a lot of example hello world contracts.",\n    partiesInvolved = [OWNER],\n)\nopen class HelloWorldScopeSpecification() : P8eScopeSpecification()\n\n')),(0,i.kt)("p",null,"Scope specifications serve the following purposes and only act as displayable metadata."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Validation - When a contract is executed, BlockVault will validate that the provided contract can operate on the scope as defined by the contract specification and scope specification mappings. The blockchain mimics this same validation. Scope specification parties must be involved on all contracts associated with this scope. This means that in practice the parties involved in the scope specification are often a subset of parties of the encompassing contracts. For instance, if a scope has ",(0,i.kt)("inlineCode",{parentName:"li"},"OWNER")," party on one contract and ",(0,i.kt)("inlineCode",{parentName:"li"},"[OWNER, ORIGINATOR]")," on another contract, the scope specification would only include the ",(0,i.kt)("inlineCode",{parentName:"li"},"OWNER")," party."),(0,i.kt)("li",{parentName:"ul"},"Display - The ",(0,i.kt)("a",{parentName:"li",href:"https://explorer.provenance.io/dashboard"},"Provenance Blockchain Explorer")," uses the fields from the scope specifications for display purposes.")),(0,i.kt)("h2",{id:"publishing"},"Publishing"),(0,i.kt)("p",null,"Contract and scope specifications are declarative in nature. They are defined and published to Provenance Blockchain out of band from the executable that will be creating and executing contracts. The ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/provenance-io/p8e-gradle-plugin"},"p8e-gradle-plugin")," is used to publish these specifications, as well as other supporting tasks ","(","the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/provenance-io/p8e-gradle-plugin/blob/main/README.md"},"README")," is a great source for plugin usage",")","."),(0,i.kt)("p",null,"When a contract specification is published, it is dehydrated into a protobuf representation. This representation contains a hash of the uberjar that it was contained within. This means that whenever a contract specification directly changes, or a protobuf that the contract specification uses changes, both the hash of the uberjar and the hash of the contract specification change as well. Both the protobuf representation and the uberjar are persisted to the ",(0,i.kt)("a",{parentName:"p",href:"../overview/encrypted-object-store/"},"EOS"),". BlockVault is able to load any historical state for a scope as it was at the time it was executed because the uberjar and contract specification can be pulled from EOS based on their hashes. BlockVault uses these same hashes to load the correct uberjar at runtime to execute the functions defined in the contract specification."))}f.isMDXComponent=!0}}]);