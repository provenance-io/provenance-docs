"use strict";(self.webpackChunkprovenance_blockchain_developer_portal=self.webpackChunkprovenance_blockchain_developer_portal||[]).push([[7598],{75702:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>d,toc:()=>o});var i=n(85893),r=n(11151);const t={},a="Metadata Concepts",d={id:"sdk/metadata/concepts",title:"Metadata Concepts",description:"The metadata service manages things that define and reference off-chain data.",source:"@site/docs/sdk/metadata/01_concepts.md",sourceDirName:"sdk/metadata",slug:"/sdk/metadata/concepts",permalink:"/docs/sdk/metadata/concepts",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"documentationSidebar",previous:{title:"x/metadata",permalink:"/docs/sdk/metadata/"},next:{title:"Metadata State",permalink:"/docs/sdk/metadata/state"}},l={},o=[{value:"Entries",id:"entries",level:2},{value:"Specifications",id:"specifications",level:2},{value:"Metadata Addresses",id:"metadata-addresses",level:2},{value:"MetadataAddress Example Implementations",id:"metadataaddress-example-implementations",level:3},{value:"MetadataAddress General Guidelines",id:"metadataaddress-general-guidelines",level:3},{value:"Indexes",id:"indexes",level:2},{value:"Signing Requirements",id:"signing-requirements",level:2},{value:"Scope Value Owner Address Requirements",id:"scope-value-owner-address-requirements",level:3},{value:"Smart Contract Requirements",id:"smart-contract-requirements",level:3},{value:"With Party Rollup Required",id:"with-party-rollup-required",level:3},{value:"Writing or Deleting a Scope With Party Rollup",id:"writing-or-deleting-a-scope-with-party-rollup",level:4},{value:"Writing a Session With Party Rollup",id:"writing-a-session-with-party-rollup",level:4},{value:"Writing a Record With Party Rollup",id:"writing-a-record-with-party-rollup",level:4},{value:"Deleting a Record With Party Rollup",id:"deleting-a-record-with-party-rollup",level:4},{value:"Without Party Rollup Required",id:"without-party-rollup-required",level:3},{value:"Writing or Deleting a Scope Without Party Rollup",id:"writing-or-deleting-a-scope-without-party-rollup",level:4},{value:"Writing a Session Without Party Rollup",id:"writing-a-session-without-party-rollup",level:4},{value:"Writing a Record Without Party Rollup",id:"writing-a-record-without-party-rollup",level:4},{value:"Deleting a Record Without Party Rollup",id:"deleting-a-record-without-party-rollup",level:4}];function c(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"metadata-concepts",children:"Metadata Concepts"}),"\n",(0,i.jsx)(s.p,{children:'The metadata service manages things that define and reference off-chain data.\nThere are three categories of things stored: entries, specifications, and object store locators.\nEach entry and specification has a unique Metadata Address that is often simply called its "id".\nAdditionally, several indexes are created to help with linking and iterating over related messages.'}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"#entries",children:"Entries"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"#specifications",children:"Specifications"})}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"#metadata-addresses",children:"Metadata Addresses"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"#metadataaddress-example-implementations",children:"MetadataAddress Example Implementations"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"#metadataaddress-general-guidelines",children:"MetadataAddress General Guidelines"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"#indexes",children:"Indexes"})}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.a,{href:"#signing-requirements",children:"Signing Requirements"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"#scope-value-owner-address-requirements",children:"Scope Value Owner Address Requirements"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"#smart-contract-requirements",children:"Smart Contract Requirements"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"#with-party-rollup-required",children:"With Party Rollup Required"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"#without-party-rollup-required",children:"Without Party Rollup Required"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"entries",children:"Entries"}),"\n",(0,i.jsxs)(s.p,{children:['The term "entries" refers to scopes, sessions, and records.\nSee ',(0,i.jsx)(s.a,{href:"/docs/sdk/metadata/state#entries",children:"Entries"})," for details."]}),"\n",(0,i.jsx)(s.h2,{id:"specifications",children:"Specifications"}),"\n",(0,i.jsxs)(s.p,{children:['The term "specifications" refers to scope specifications, contract specifications, and record specifications.\nSee ',(0,i.jsx)(s.a,{href:"/docs/sdk/metadata/state#specifications",children:"Specifications"})," for details."]}),"\n",(0,i.jsx)(s.h2,{id:"metadata-addresses",children:"Metadata Addresses"}),"\n",(0,i.jsx)(s.p,{children:'Entries and Specifications must each have a unique metadata address.\nThese addresses are byte arrays that are commonly referered to as "ids".\nAs strings, they should be represented using the bech32 address format.\nThe addresses for the different messages have specific formats that help facilitate grouping and indexing.\nAll addresses start with a single byte that identifies the type, and are followed by 16 bytes commonly called a UUID.\nSome address types contain other elements too.'}),"\n",(0,i.jsx)(s.h3,{id:"metadataaddress-example-implementations",children:"MetadataAddress Example Implementations"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Go: ",(0,i.jsx)(s.a,{href:"https://github.com/provenance-io/provenance/blob/main/x/metadata/spec/examples/go/metadata_address.go",children:"address.go"})]}),"\n",(0,i.jsxs)(s.li,{children:["Kotlin: ",(0,i.jsx)(s.a,{href:"https://github.com/provenance-io/provenance/blob/main/x/metadata/spec/examples/kotlin/src/main/kotlin/MetadataAddress.kt",children:"MetadataAddress.kt"})]}),"\n",(0,i.jsxs)(s.li,{children:["Javascript: ",(0,i.jsx)(s.a,{href:"https://github.com/provenance-io/provenance/blob/main/x/metadata/spec/examples/js/lib/metadata-address.js",children:"metadata-address.js"})]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"metadataaddress-general-guidelines",children:"MetadataAddress General Guidelines"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"As strings, the metadata addresses are represented using the bech32 address format."}),"\n",(0,i.jsxs)(s.li,{children:["The ",(0,i.jsx)(s.code,{children:"*IdInfo"})," messages defined in ",(0,i.jsx)(s.code,{children:"metadata.proto"})," (e.g. ",(0,i.jsx)(s.code,{children:"RecordIdInfo"}),") are used in response messages and contain a breakdown of a metadata address."]}),"\n",(0,i.jsxs)(s.li,{children:["Variables that hold the addresses as byte arrays should end in ",(0,i.jsx)(s.code,{children:"_id"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["Variables that hold the addresses as bech32 strings should end in ",(0,i.jsx)(s.code,{children:"_addr"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["Variables that hold UUIDs as strings should use the standard UUID format and end in ",(0,i.jsx)(s.code,{children:"_uuid"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["If a variable is a byte array that ends in ",(0,i.jsx)(s.code,{children:"_id"}),", then it should be the full Metadata Address byte array."]}),"\n",(0,i.jsxs)(s.li,{children:["String variables that end in ",(0,i.jsx)(s.code,{children:"_id"})," should only be used in input messages.\nThey should be flexible fields that can accept either the bech32 string version of the Metadata Address byte array, or a UUID in the standard UUID string format."]}),"\n",(0,i.jsxs)(s.li,{children:["If a variable ends in ",(0,i.jsx)(s.code,{children:"_addr"}),", then it should be the bech32 string version of the Metadata Address byte array."]}),"\n",(0,i.jsxs)(s.li,{children:["If a variable ends in ",(0,i.jsx)(s.code,{children:"_uuid"}),", then it should be a UUID in the standard UUID string format.\nThe exception to this is the byte array fields in the ",(0,i.jsx)(s.code,{children:"*IdInfo"})," messages that represent the id broken into its various parts.\nFor example, ",(0,i.jsx)(s.code,{children:"ScopeIdInfo.scope_id_scope_uuid"})," represents the UUID portion of the ",(0,i.jsx)(s.code,{children:"scope_id"}),", and is left as a byte array,\nbut ",(0,i.jsx)(s.code,{children:"ScopeIdInfo.scope_uuid"})," is the standard UUID string representation of those bytes."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"indexes",children:"Indexes"}),"\n",(0,i.jsx)(s.p,{children:"Indexes are specially formatted entries in the kvstore used to find associated things."}),"\n",(0,i.jsx)(s.p,{children:"The keys contain all of the relevant information.\nThey are byte arrays with three parts:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Type byte: A single byte representing the type of index."}),"\n",(0,i.jsx)(s.li,{children:"Part 1: Address of the starting thing in the association."}),"\n",(0,i.jsx)(s.li,{children:"Part 2: Address of the entry to find."}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["The values are always a single byte: ",(0,i.jsx)(s.code,{children:"0x01"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"The general use of them is to create a prefix using the type byte and part 1.\nThen use that prefix to iterate over all keys with that same prefix.\nDuring iteration, remove the prefix from the current entry's key in order to get the key of the thing to find."}),"\n",(0,i.jsx)(s.h2,{id:"signing-requirements",children:"Signing Requirements"}),"\n",(0,i.jsxs)(s.p,{children:["Scopes have a ",(0,i.jsx)(s.code,{children:"require_party_rollup"})," boolean field that dictates most signer requirements for a scope and all it's sessions and records.\nThere are also special signer considerations related to a scope's ",(0,i.jsx)(s.code,{children:"value_owner_address"})," field."]}),"\n",(0,i.jsx)(s.h3,{id:"scope-value-owner-address-requirements",children:"Scope Value Owner Address Requirements"}),"\n",(0,i.jsxs)(s.p,{children:["These requirements are applied regardless of a scope's ",(0,i.jsx)(s.code,{children:"require_party_rollup"})," value.\nThey are applied when writing new scopes, updating existing scopes, and deleting scopes."]}),"\n",(0,i.jsx)(s.p,{children:"If a scope with a value owner address is being updated, and the ONLY change is to that value owner address, then ONLY these signer requirements are applied and all other signer requirements are ignored.\nIf the value owner address is not changing, these requirements do not apply.\nIf the value owner address is changing as well as one or more other fields, these requirements apply as well as the other signer requirements."}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"When a value owner address is being set to a marker, at least one of the signers must have deposit permission on that marker."}),"\n",(0,i.jsx)(s.li,{children:"When a value owner address is a marker and is being changed, at least one of the signers must have withdraw permission on that marker."}),"\n",(0,i.jsx)(s.li,{children:"When a value owner address is a non-marker address, and is being changed, that existing address must be one of the signers."}),"\n",(0,i.jsx)(s.li,{children:"When a value owner address is empty, and is being changed, standard scope signer requirements are also applied even if that's the only change to the scope."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"smart-contract-requirements",children:"Smart Contract Requirements"}),"\n",(0,i.jsxs)(s.p,{children:["The following are requirements related to smart contract usage of the ",(0,i.jsx)(s.code,{children:"x/metadata"})," module:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["A party with a smart contract address MUST have the ",(0,i.jsx)(s.code,{children:"PROVENANCE"})," role."]}),"\n",(0,i.jsxs)(s.li,{children:["A party with the ",(0,i.jsx)(s.code,{children:"PROVENANCE"})," role MUST have the address of a smart contract."]}),"\n",(0,i.jsx)(s.li,{children:"When a smart contract signs a message, it MUST be first or have only smart-contract signers before it, and SHOULD include the invoker address(es) after."}),"\n",(0,i.jsxs)(s.li,{children:["When a smart contract is a signer, it must either be a party/owner, or have authorizations (via ",(0,i.jsx)(s.code,{children:"x/authz"}),") from all signers after it."]}),"\n",(0,i.jsx)(s.li,{children:"If a smart contract is a signer, but not a party, it cannot be the only signer, and cannot be the last signer."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"with-party-rollup-required",children:"With Party Rollup Required"}),"\n",(0,i.jsxs)(s.p,{children:["When a scope has ",(0,i.jsx)(s.code,{children:"require_party_rollup = true"}),", all session parties must also be listed in the scope owners.\nThe use of ",(0,i.jsx)(s.code,{children:"optional = true"})," parties is also allowed.\nThe party types (aka roles) defined in specifications, in conjunction with they entry's parties dictate the signers that are required (in addition to any ",(0,i.jsx)(s.code,{children:"optional = false"})," parties)."]}),"\n",(0,i.jsxs)(s.p,{children:["For example, if a scope has an ",(0,i.jsx)(s.code,{children:"optional = false"})," ",(0,i.jsx)(s.code,{children:"CONTROLLER"})," (address ",(0,i.jsx)(s.code,{children:"A"}),"), and two ",(0,i.jsx)(s.code,{children:"optional = true"})," ",(0,i.jsx)(s.code,{children:"SERVICER"}),"s (addresses ",(0,i.jsx)(s.code,{children:"B"}),", and ",(0,i.jsx)(s.code,{children:"C"}),"),\nand a session is being written using a contract spec that requires just a ",(0,i.jsx)(s.code,{children:"SERVICER"})," signature, then to write that session,\neither address ",(0,i.jsx)(s.code,{children:"B"})," or ",(0,i.jsx)(s.code,{children:"C"})," must be a signer (due to the contract spec), and ",(0,i.jsx)(s.code,{children:"A"})," must also sign (because they're ",(0,i.jsx)(s.code,{children:"optional = false"})," in the scope)."]}),"\n",(0,i.jsx)(s.h4,{id:"writing-or-deleting-a-scope-with-party-rollup",children:"Writing or Deleting a Scope With Party Rollup"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"All roles required by the scope spec must have a party in the owners."}),"\n",(0,i.jsxs)(s.li,{children:["If not new:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["All ",(0,i.jsx)(s.code,{children:"optional = false"})," existing owners must be signers."]}),"\n",(0,i.jsx)(s.li,{children:"All roles required by the scope spec must have a signer and associated party from the existing scope."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.li,{children:"Scope value owner address requirements are applied."}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"writing-a-session-with-party-rollup",children:"Writing a Session With Party Rollup"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"All proposed session parties must be present in this scope's owners."}),"\n",(0,i.jsxs)(s.li,{children:["All ",(0,i.jsx)(s.code,{children:"optional = false"})," scope owners must be signers."]}),"\n",(0,i.jsxs)(s.li,{children:["If new:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"All roles required by the contract spec must have a signer and associated party in the proposed session."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["If not new:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"All roles required by the contract spec must have a signer and associated party in the existing session."}),"\n",(0,i.jsx)(s.li,{children:"All roles required by the contract spec must have parties in the proposed session."}),"\n",(0,i.jsxs)(s.li,{children:["All ",(0,i.jsx)(s.code,{children:"optional = false"})," existing parties must also be signers."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"writing-a-record-with-party-rollup",children:"Writing a Record With Party Rollup"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"All roles required by the record spec must have a signer and associated party in the session."}),"\n",(0,i.jsxs)(s.li,{children:["All ",(0,i.jsx)(s.code,{children:"optional = false"})," scope owners and session parties must be signers."]}),"\n",(0,i.jsxs)(s.li,{children:["If the record is changing sessions, all ",(0,i.jsx)(s.code,{children:"optional = false"})," previous session parties must be signers."]}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"deleting-a-record-with-party-rollup",children:"Deleting a Record With Party Rollup"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"All roles required by the record spec must have a signer and associated party in the scope."}),"\n",(0,i.jsxs)(s.li,{children:["All ",(0,i.jsx)(s.code,{children:"optional = false"})," scope owners must be signers."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"without-party-rollup-required",children:"Without Party Rollup Required"}),"\n",(0,i.jsxs)(s.p,{children:["When a scope has ",(0,i.jsx)(s.code,{children:"require_party_rollup = false"}),", then ",(0,i.jsx)(s.code,{children:"optional = true"})," parties are not allowed in the scope or any of its sessions."]}),"\n",(0,i.jsx)(s.h4,{id:"writing-or-deleting-a-scope-without-party-rollup",children:"Writing or Deleting a Scope Without Party Rollup"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"All roles required by the scope spec must have a party in the owners."}),"\n",(0,i.jsx)(s.li,{children:"If not new, all existing owners must sign."}),"\n",(0,i.jsx)(s.li,{children:"Scope value owner address requirements are applied."}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"writing-a-session-without-party-rollup",children:"Writing a Session Without Party Rollup"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"All roles required by the contract spec must have a party in the session parties."}),"\n",(0,i.jsx)(s.li,{children:"All scope owners must sign."}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"writing-a-record-without-party-rollup",children:"Writing a Record Without Party Rollup"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"All roles required by the record spec must have a party in the session parties."}),"\n",(0,i.jsx)(s.li,{children:"All session parties must sign."}),"\n",(0,i.jsx)(s.li,{children:"If the record is changing to a new session, all previous session parties must sign."}),"\n"]}),"\n",(0,i.jsx)(s.h4,{id:"deleting-a-record-without-party-rollup",children:"Deleting a Record Without Party Rollup"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"All scope owners must sign."}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},11151:(e,s,n)=>{n.d(s,{Z:()=>d,a:()=>a});var i=n(67294);const r={},t=i.createContext(r);function a(e){const s=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);