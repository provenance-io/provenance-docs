/*! For license information please see main.b02348c8.js.LICENSE.txt */
(self.webpackChunkprovenance_blockchain_developer_portal=self.webpackChunkprovenance_blockchain_developer_portal||[]).push([[179],{20830:(e,t,n)=>{"use strict";n.d(t,{W:()=>i});var o=n(67294);function i(){return o.createElement("svg",{width:"20",height:"20",className:"DocSearch-Search-Icon",viewBox:"0 0 20 20"},o.createElement("path",{d:"M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z",stroke:"currentColor",fill:"none",fillRule:"evenodd",strokeLinecap:"round",strokeLinejoin:"round"}))}},723:(e,t,n)=>{"use strict";n.d(t,{Z:()=>u});n(67294);var o=n(68356),i=n.n(o),s=n(16887);const a={"003f74ac":[()=>n.e(2544).then(n.bind(n,78114)),"@site/docs/sdk/metadata/08_params.md",78114],"00e1ed7a":[()=>n.e(3089).then(n.bind(n,54622)),"@site/docs/pb/blockchain/basics/transaction-lifecycle.md",54622],"012d67d0":[()=>n.e(7276).then(n.bind(n,71410)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/p8e-endpoints.md",71410],"019bb4c0":[()=>n.e(6595).then(n.bind(n,95478)),"@site/docs/sdk/trigger/06_begin_and_end_blocker.md",95478],"01d09a63":[()=>n.e(3812).then(n.bind(n,56503)),"@site/docs/sdk/attribute/02_messages.md",56503],"03db9e4c":[()=>n.e(6440).then(n.bind(n,14691)),"@site/docs/pb/contributing/adr/100-blockchain-configuration-and-concepts/101-hd-wallets-key-pairs-addresses.md",14691],"04ffa485":[()=>n.e(992).then(n.bind(n,64355)),"@site/docs/learn/provenance-applications/loan-origination-system-los/assets.md",64355],"0602d7e2":[()=>n.e(7456).then(n.bind(n,97777)),"@site/docs/pb/integrating/integrating-with-p8e/index.md",97777],"0645a285":[()=>n.e(3977).then(n.bind(n,6518)),"@site/docs/sdk/trigger/07_genesis.md",6518],"066f1a1f":[()=>n.e(3794).then(n.bind(n,70412)),"@site/docs/sdk/exchange/03_messages.md",70412],"06b87490":[()=>n.e(7002).then(n.bind(n,98032)),"@site/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/data-mapping.md",98032],"0738acf9":[()=>n.e(7371).then(n.bind(n,66559)),"@site/docs/pb/modules/marker-module.md",66559],"08e05b71":[()=>n.e(9501).then(n.bind(n,8021)),"@site/docs/pb/contributing/adr/400-smart-contracts/403-p8e-smart-contracts.md",8021],"0911d173":[()=>Promise.all([n.e(532),n.e(8621)]).then(n.bind(n,97324)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/store-object.mdx",97324],"09f5dc09":[()=>n.e(8708).then(n.bind(n,73565)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/loan-onboarding.md",73565],"0b5aeaee":[()=>n.e(5325).then(n.bind(n,15736)),"@site/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/deploying-the-encrypted-object-store/configuring-replication.md",15736],"0bba4e2f":[()=>n.e(1930).then(n.bind(n,37312)),"@site/docs/sdk/exchange/README.md",37312],"0e876153":[()=>n.e(3417).then(n.bind(n,94352)),"@site/docs/pb/p8e/p8e-usage/specifications.md",94352],"0ef3253a":[()=>n.e(1712).then(n.bind(n,6506)),"@site/docs/pb/p8e/overview/api.md",6506],"107ca8ff":[()=>n.e(3471).then(n.bind(n,57616)),"@site/docs/sdk/reward/07_begin_and_end_blocker.md",57616],"107e0817":[()=>n.e(5936).then(n.bind(n,52075)),"@site/docs/learn/provenance-applications/omnibus.md",52075],"10915e30":[()=>n.e(2160).then(n.bind(n,48948)),"@site/docs/sdk/marker/05_end_block.md",48948],"10bebd98":[()=>n.e(1088).then(n.bind(n,62118)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/error-handling.md",62118],11655800:[()=>n.e(938).then(n.bind(n,5610)),"@site/docs/learn/dapps/fiat-ramps.md",5610],"117a8e55":[()=>n.e(9451).then(n.bind(n,92561)),"@site/docs/pb/p8e/p8e-usage/p8e-setup.md",92561],"11b32f92":[()=>n.e(9419).then(n.bind(n,2004)),"@site/docs/sdk/oracle/06_genesis.md",2004],"122dc7fc":[()=>n.e(298).then(n.bind(n,79703)),"@site/docs/pb/p8e/p8e-usage/architecture.md",79703],"12de55de":[()=>n.e(3015).then(n.bind(n,76608)),"@site/docs/discover/usdf.md",76608],"1386bc64":[()=>n.e(3233).then(n.bind(n,44552)),"@site/docs/pb/blockchain/using-provenance/query-command.md",44552],17896441:[()=>Promise.all([n.e(532),n.e(325),n.e(7918)]).then(n.bind(n,10903)),"@theme/DocItem",10903],17913518:[()=>n.e(9245).then(n.bind(n,23276)),"@site/docs/sdk/exchange/01_concepts.md",23276],"17d612a1":[()=>n.e(975).then(n.bind(n,28933)),"@site/docs/learn/asset-lifecycle/06-trade.md",28933],18225268:[()=>n.e(6195).then(n.bind(n,65554)),"@site/docs/discover/explorer/ui-walkthrough/account-address.md",65554],"19a920b0":[()=>Promise.all([n.e(532),n.e(6948)]).then(n.bind(n,88539)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/approve-contract.md",88539],"1a2ebf8b":[()=>n.e(1434).then(n.bind(n,36388)),"@site/docs/sdk/trigger/03_messages.md",36388],"1a4e3797":[()=>Promise.all([n.e(532),n.e(7920)]).then(n.bind(n,56675)),"@theme/SearchPage",56675],"1bef93b5":[()=>n.e(9242).then(n.bind(n,33323)),"@site/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/index.md",33323],"1df93b7f":[()=>Promise.all([n.e(532),n.e(3237)]).then(n.bind(n,11609)),"@site/src/pages/index.tsx",11609],"1f32ae85":[()=>n.e(2569).then(n.bind(n,16799)),"@site/docs/pb/contributing/adr/100-blockchain-configuration-and-concepts/index.md",16799],"1f391b9e":[()=>Promise.all([n.e(532),n.e(325),n.e(3085)]).then(n.bind(n,14247)),"@theme/MDXPage",14247],"201e8141":[()=>n.e(3251).then(n.bind(n,60529)),"@site/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/p8e-contracts/index.md",60529],"20fc3f76":[()=>Promise.all([n.e(532),n.e(2253)]).then(n.bind(n,6923)),"@site/docs/learn/asset-lifecycle/08-capital-raise-example.md",6923],"224635d1":[()=>n.e(3424).then(n.bind(n,36486)),"@site/docs/discover/money.md",36486],"22cfe006":[()=>n.e(5642).then(n.bind(n,3318)),"@site/docs/pb/p8e/overview/api/signing-and-encryption.md",3318],"23c728bd":[()=>n.e(879).then(n.bind(n,40079)),"@site/docs/sdk/attribute/03_events.md",40079],"2560a3da":[()=>n.e(9934).then(n.bind(n,9246)),"@site/docs/pb/ecosystem/financial-services-blockchain/distribution.md",9246],"2671b8d3":[()=>n.e(4571).then(n.bind(n,80455)),"@site/docs/pb/modules/modules.md",80455],"27a9d6c5":[()=>n.e(90).then(n.bind(n,21398)),"@site/docs/discover/ramps.md",21398],"284af742":[()=>n.e(788).then(n.bind(n,10508)),"@site/docs/pb/p8e/p8e-usage/quick-start/README.md",10508],"2b220663":[()=>n.e(7771).then(n.bind(n,5512)),"@site/docs/sdk/attribute/01_state.md",5512],"2cfe1a27":[()=>n.e(7359).then(n.bind(n,69017)),"@site/docs/pb/contributing/adr/400-smart-contracts/400-smart-contracts-1.md",69017],"2dd1c8dd":[()=>n.e(6608).then(n.t.bind(n,41837,19)),"/home/runner/work/provenance-docs/provenance-docs/.docusaurus/docusaurus-plugin-redoc/plugin-redoc-0/redocApiSpecV1.2-plugin-redoc-0.json",41837],"2e798e45":[()=>n.e(2641).then(n.bind(n,451)),"@site/docs/sdk/reward/05_queries.md",451],"2eeef9d7":[()=>n.e(7759).then(n.bind(n,75635)),"@site/docs/sdk/name/04_events.md",75635],"2f554aff":[()=>n.e(2e3).then(n.bind(n,57092)),"@site/docs/learn/whitepapers/investment-fund-services-on-provenance.md",57092],"2fd7c50c":[()=>n.e(8792).then(n.bind(n,97262)),"@site/docs/pb/p8e/index.md",97262],"302b56e9":[()=>n.e(8220).then(n.bind(n,72939)),"@site/docs/quick-start/start-here.md",72939],"30ad14ec":[()=>n.e(7598).then(n.bind(n,75702)),"@site/docs/sdk/metadata/01_concepts.md",75702],"30f01348":[()=>n.e(5426).then(n.bind(n,72466)),"@site/docs/learn/provenance-applications/loan-origination-system-los/data-sharing-with-portfolio-manager.md",72466],"3314ce8a":[()=>n.e(8151).then(n.bind(n,27531)),"@site/docs/pb/ecosystem/financial-services-blockchain/index.md",27531],"34c1e115":[()=>n.e(373).then(n.bind(n,35393)),"@site/docs/discover/explorer/ui-walkthrough/dashboard/index.md",35393],"34ce8394":[()=>n.e(9608).then(n.t.bind(n,69162,19)),"/home/runner/work/provenance-docs/provenance-docs/.docusaurus/docusaurus-plugin-redoc/plugin-redoc-0/plugin-route-context-module-100.json",69162],"35099a50":[()=>n.e(7525).then(n.bind(n,87426)),"@site/docs/sdk/msgfees/03_start_end_block.md",87426],"3604eab4":[()=>n.e(2795).then(n.bind(n,22102)),"@site/docs/learn/dapps/dapp-architecture.md",22102],"3695be36":[()=>n.e(1874).then(n.bind(n,64814)),"@site/docs/learn/dapps/identity-verification/identity-attribute-tutorial.md",64814],"369f35ba":[()=>n.e(3130).then(n.bind(n,48223)),"@site/docs/pb/ecosystem/community/asset-originators.md",48223],"36f8c416":[()=>n.e(4857).then(n.bind(n,52851)),"@site/docs/sdk/hold/01_concepts.md",52851],"37526ba3":[()=>n.e(9306).then(n.bind(n,91126)),"@site/docs/pb/modules/cosmos-modules.md",91126],37534510:[()=>n.e(9209).then(n.bind(n,45752)),"@site/docs/pb/p8e/components-1/api.md",45752],"3761e2f2":[()=>n.e(9288).then(n.bind(n,73918)),"@site/docs/learn/learn-about.md",73918],"386a7de4":[()=>n.e(5757).then(n.bind(n,65905)),"@site/docs/pb/blockchain/running-a-node/running-a-node-1/join-provenance-testnet/running-a-testnet-node-from-quicksync.md",65905],"38bc7367":[()=>n.e(1335).then(n.bind(n,95286)),"@site/docs/pb/modules/provwasm-smart-contracts.md",95286],"393be207":[()=>n.e(7414).then(n.bind(n,10461)),"@site/src/pages/markdown-page.md",10461],"39b7b8a1":[()=>n.e(3302).then(n.bind(n,47958)),"@site/docs/learn/asset-lifecycle/03-markers.md",47958],"3a404b4f":[()=>n.e(9960).then(n.bind(n,24650)),"@site/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/3rd-party-digital-signatures.md",24650],"3a4a69ed":[()=>n.e(8121).then(n.bind(n,16120)),"@site/docs/quick-start/wallet-and-hash.md",16120],"3a7a8a49":[()=>n.e(5147).then(n.bind(n,31958)),"@site/docs/learn/dapps/identity-verification.md",31958],"3b408982":[()=>n.e(4462).then(n.t.bind(n,21294,19)),"/home/runner/work/provenance-docs/provenance-docs/.docusaurus/docusaurus-plugin-redoc/plugin-redoc-0/redocApiLayoutV1-plugin-redoc-0.json",21294],"3bc15923":[()=>n.e(9189).then(n.bind(n,60045)),"@site/docs/sdk/metadata/05_queries.md",60045],"3bc71cf1":[()=>n.e(2723).then(n.bind(n,20299)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/validation-response.md",20299],"3ea00ea9":[()=>n.e(5430).then(n.bind(n,42927)),"@site/docs/sdk/exchange/04_events.md",42927],"4004cd87":[()=>n.e(8718).then(n.bind(n,2922)),"@site/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/p8e-contracts/example-loan-contracts.md",2922],"4257fe2b":[()=>n.e(3897).then(n.bind(n,30489)),"@site/docs/pb/ecosystem/governance/voting.md",30489],"42c6802c":[()=>n.e(9641).then(n.bind(n,11081)),"@site/docs/pb/contributing/adr/200-base-infrastructure/201-account-metadata.md",11081],43079485:[()=>n.e(441).then(n.bind(n,70053)),"@site/docs/sdk/exchange/02_state.md",70053],"435a0344":[()=>n.e(9309).then(n.bind(n,35939)),"@site/docs/learn/why-cosmos.md",35939],"437ba7a3":[()=>n.e(9360).then(n.bind(n,3621)),"@site/docs/pb/contributing/adr/500-administration.md",3621],"441e93e4":[()=>n.e(5192).then(n.bind(n,78117)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/index.md",78117],"44dea36a":[()=>n.e(7909).then(n.bind(n,9772)),"@site/docs/discover/hash.md",9772],"45bc127f":[()=>n.e(5190).then(n.bind(n,36022)),"@site/docs/pb/p8e/security.md",36022],"4635ef74":[()=>n.e(2985).then(n.bind(n,29994)),"@site/docs/pb/contributing/adr/100-blockchain-configuration-and-concepts/103-transaction-fees-and-gas.md",29994],"467c0153":[()=>n.e(9909).then(n.bind(n,58303)),"@site/docs/pb/blockchain/using-provenance/tx-command.md",58303],"468e17e2":[()=>n.e(3719).then(n.bind(n,79006)),"@site/docs/sdk/oracle/03_messages.md",79006],"478c945a":[()=>n.e(4469).then(n.bind(n,40493)),"@site/docs/pb/contributing/adr/200-base-infrastructure/index.md",40493],"4859d8e2":[()=>n.e(1060).then(n.bind(n,81670)),"@site/docs/pb/contributing/adr/template.mdx",81670],"49108e93":[()=>n.e(9497).then(n.bind(n,30103)),"@site/docs/discover/explorer/ui-walkthrough/forthcoming/ibc.md",30103],"49870d76":[()=>n.e(9107).then(n.bind(n,37491)),"@site/docs/learn/asset-lifecycle/04-issue.md",37491],"49b578ab":[()=>n.e(555).then(n.bind(n,12340)),"@site/docs/pb/faq/validator-faq.md",12340],"4bbf0c85":[()=>n.e(2524).then(n.bind(n,39317)),"@site/docs/pb/modules/metadata-module.md",39317],"4bc6e3bf":[()=>n.e(2409).then(n.bind(n,7280)),"@site/docs/pb/integrating/asset-originators-guide.md",7280],"4c316eb3":[()=>n.e(3440).then(n.bind(n,33683)),"@site/docs/sdk/msgfees/07_governance.md",33683],"4c582ecf":[()=>n.e(6616).then(n.bind(n,8089)),"@site/docs/learn/dapps/blockchain-communication.md",8089],"4cd95b83":[()=>n.e(5040).then(n.bind(n,88927)),"@site/docs/pb/p8e/untitled/README.md",88927],"4cdbde10":[()=>n.e(1639).then(n.bind(n,27900)),"@site/docs/sdk/trigger/05_events.md",27900],"4e19846a":[()=>n.e(4731).then(n.bind(n,83565)),"@site/docs/learn/dapps/dapps-overview.md",83565],"4f6d8885":[()=>n.e(7720).then(n.bind(n,23568)),"@site/docs/learn/asset-lifecycle/asset-lifecycle.md",23568],"4f80c3ef":[()=>n.e(2059).then(n.bind(n,1348)),"@site/docs/sdk/reward/02_state.md",1348],50583958:[()=>n.e(6125).then(n.bind(n,24362)),"@site/docs/sdk/marker/README.md",24362],"5389b6b3":[()=>n.e(1894).then(n.bind(n,22451)),"@site/docs/sdk/README.md",22451],"538fdd7e":[()=>n.e(5479).then(n.bind(n,18265)),"@site/docs/sdk/oracle/01_concepts.md",18265],"544a1c6c":[()=>n.e(8753).then(n.bind(n,24589)),"@site/docs/quick-start/build-a-dapp.md",24589],"5485839b":[()=>n.e(9301).then(n.bind(n,11432)),"@site/docs/pb/modules/attribute-module.md",11432],"552a5b32":[()=>n.e(1984).then(n.bind(n,44841)),"@site/docs/learn/provenance-applications/loan-origination-system-los/loan-servicing.md",44841],57887178:[()=>n.e(9893).then(n.bind(n,6103)),"@site/docs/discover/explorer.md",6103],"5802bce8":[()=>n.e(7307).then(n.bind(n,64926)),"@site/docs/pb/contributing/adr/300-core-concepts/301-hash.md",64926],"58b1a698":[()=>n.e(7388).then(n.bind(n,16198)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/index.md",16198],"590b6b50":[()=>n.e(270).then(n.bind(n,29625)),"@site/docs/pb/contributing/adr/300-core-concepts/300-identity.md",29625],"59979f1f":[()=>n.e(9977).then(n.bind(n,56770)),"@site/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/summary.md",56770],"59f3bed4":[()=>n.e(7133).then(n.bind(n,11913)),"@site/docs/pb/contributing/adr/100-blockchain-configuration-and-concepts/100-genesis-network-configuration.mdx",11913],"5b2b520a":[()=>n.e(1218).then(n.bind(n,31752)),"@site/docs/sdk/msgfees/08_genesis.md",31752],"5c826b46":[()=>n.e(350).then(n.bind(n,48047)),"@site/docs/learn/dapps/organization-management.md",48047],"5d311828":[()=>n.e(6851).then(n.bind(n,85580)),"@site/docs/learn/dapps/identity-verification/identity-nfts.md",85580],"5e95c892":[()=>n.e(9661).then(n.bind(n,41892)),"@theme/DocsRoot",41892],"5e9f5e1a":[()=>Promise.resolve().then(n.bind(n,36809)),"@generated/docusaurus.config",36809],"5edad310":[()=>n.e(4986).then(n.bind(n,90867)),"@site/docs/pb/blockchain/basics/anatomy-of-a-provenance-application.md",90867],"5ee5099f":[()=>n.e(5105).then(n.bind(n,29855)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/index.md",29855],"5ffcd300":[()=>n.e(6110).then(n.t.bind(n,15745,19)),"/home/runner/work/provenance-docs/provenance-docs/.docusaurus/docusaurus-plugin-content-pages/default/plugin-route-context-module-100.json",15745],"6216800c":[()=>n.e(4474).then(n.bind(n,65260)),"@site/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/loan-servicing.md",65260],"633e38b7":[()=>n.e(1919).then(n.bind(n,15077)),"@site/docs/sdk/reward/06_events.md",15077],"64db2ecd":[()=>n.e(953).then(n.bind(n,86042)),"@site/docs/pb/blockchain/basics/accounts.md",86042],"65148b81":[()=>n.e(5635).then(n.bind(n,5503)),"@site/docs/sdk/oracle/04_queries.md",5503],65471103:[()=>n.e(8369).then(n.bind(n,69943)),"@site/docs/sdk/msgfees/README.md",69943],"656afb91":[()=>n.e(8314).then(n.bind(n,47115)),"@site/docs/pb/contributing/adr/200-base-infrastructure/200-name-service.md",47115],"675359c4":[()=>n.e(7072).then(n.t.bind(n,83769,19)),"/home/runner/work/provenance-docs/provenance-docs/.docusaurus/docusaurus-plugin-content-docs/default/plugin-route-context-module-100.json",83769],"68b00b7c":[()=>n.e(4701).then(n.bind(n,54808)),"@site/docs/sdk/oracle/README.md",54808],"68ddbf57":[()=>n.e(3003).then(n.bind(n,4530)),"@site/docs/sdk/metadata/07_telemetry.md",4530],"68ed7ca5":[()=>n.e(6057).then(n.bind(n,31209)),"@site/docs/pb/p8e/p8e-usage/multi-contract-example.md",31209],"692ce386":[()=>n.e(4957).then(n.bind(n,30295)),"@site/docs/discover/explorer/ui-walkthrough/staking-validators/index.md",30295],"6992b847":[()=>n.e(7802).then(n.bind(n,45580)),"@site/docs/pb/contributing/adr/400-smart-contracts/index.md",45580],"6a0a334d":[()=>n.e(2385).then(n.bind(n,32956)),"@site/docs/sdk/metadata/README.md",32956],"6c5235e2":[()=>n.e(8006).then(n.bind(n,94689)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/configuration-endpoints.md",94689],"6e93f297":[()=>n.e(4973).then(n.bind(n,22384)),"@site/docs/discover/solutions.md",22384],"6f229bd3":[()=>n.e(6080).then(n.bind(n,39123)),"@site/docs/sdk/attribute/04_params.md",39123],"6f6da0a1":[()=>n.e(2304).then(n.bind(n,20088)),"@site/docs/discover/staking.md",20088],"6ff5f9db":[()=>n.e(8438).then(n.bind(n,81688)),"@site/docs/pb/p8e/p8e-usage/building-new-contracts.md",81688],"724624a5":[()=>n.e(1727).then(n.bind(n,76089)),"@site/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/key-management/permissioning-others.md",76089],"7272aeda":[()=>Promise.all([n.e(532),n.e(9240)]).then(n.bind(n,29926)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/retrieve-file.md",29926],"72adf621":[()=>n.e(2887).then(n.t.bind(n,7085,19)),"/home/runner/work/provenance-docs/provenance-docs/.docusaurus/docusaurus-theme-search-algolia/default/plugin-route-context-module-100.json",7085],"73a09b8d":[()=>n.e(2247).then(n.bind(n,45612)),"@site/docs/sdk/metadata/03_messages.md",45612],"7711cccf":[()=>n.e(7632).then(n.bind(n,34166)),"@site/docs/sdk/name/01_concepts.md",34166],"77c3e805":[()=>n.e(2626).then(n.bind(n,92367)),"@site/docs/pb/blockchain/introduction/index.md",92367],78412288:[()=>n.e(2417).then(n.bind(n,35138)),"@site/docs/pb/p8e/overview/encrypted-object-store/encryption-scheme.md",35138],"78a1e2b8":[()=>n.e(1393).then(n.bind(n,92254)),"@site/docs/sdk/name/02_state.md",92254],79037153:[()=>n.e(7781).then(n.bind(n,37246)),"@site/docs/pb/p8e/p8e-usage/quick-start/hello-world-example.md",37246],"794070ee":[()=>n.e(8977).then(n.bind(n,45412)),"@site/docs/learn/dapps/identity-verification/attribute-values.md",45412],"79824c81":[()=>n.e(2268).then(n.bind(n,1720)),"@site/docs/pb/blockchain/running-a-node/running-a-node-1/index.md",1720],"7a635e3f":[()=>n.e(9346).then(n.bind(n,53957)),"@site/docs/quick-start/write-a-smart-contract.md",53957],"7ab24626":[()=>n.e(2241).then(n.bind(n,35405)),"@site/docs/discover/explorer/ui-walkthrough/staking-validators/validator-details.md",35405],"7ac5008d":[()=>n.e(5841).then(n.bind(n,58088)),"@site/docs/pb/ecosystem/community/validator.md",58088],"7c91ab8a":[()=>n.e(9902).then(n.bind(n,68054)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/index.md",68054],"7e534d6c":[()=>n.e(3675).then(n.bind(n,91866)),"@site/docs/pb/blockchain/running-a-node/running-a-node-1/become-a-validator.md",91866],"7e5492a1":[()=>n.e(3072).then(n.bind(n,243)),"@site/docs/pb/p8e/untitled/3rd-party-digital-signatures.md",243],"7f608aa1":[()=>n.e(7807).then(n.bind(n,4228)),"@site/docs/discover/explorer/ui-walkthrough/transactions.md",4228],"7fc14121":[()=>n.e(7439).then(n.bind(n,49269)),"@site/docs/pb/ecosystem/financial-services-blockchain/token-economics.mdx",49269],"8033d4f2":[()=>n.e(3855).then(n.bind(n,15445)),"@site/docs/sdk/hold/04_queries.md",15445],"8174260a":[()=>n.e(7448).then(n.bind(n,51095)),"@site/docs/learn/provenance-applications/loan-origination-system-los/index.md",51095],"82faa77e":[()=>n.e(4738).then(n.bind(n,31506)),"@site/docs/sdk/ibcratelimit/README.md",31506],"838112e6":[()=>n.e(3923).then(n.bind(n,28541)),"@site/docs/discover/explorer/explorer-as-a-service/ingestion.md",28541],"843d4610":[()=>n.e(109).then(n.bind(n,26336)),"@site/docs/learn/asset-lifecycle/05-manage.md",26336],"84e93ef0":[()=>n.e(27).then(n.bind(n,3652)),"@site/docs/pb/p8e/overview/p8e-ui.md",3652],"856cf724":[()=>n.e(6607).then(n.bind(n,8995)),"@site/docs/pb/p8e/overview/encrypted-object-store/dime-encryption-envelope-specification.md",8995],"8578622d":[()=>n.e(9592).then(n.bind(n,62049)),"@site/docs/sdk/marker/12_transfers.md",62049],86030147:[()=>n.e(8740).then(n.bind(n,73793)),"@site/docs/pb/blockchain/using-provenance/index.md",73793],"88912d26":[()=>n.e(217).then(n.bind(n,68692)),"@site/docs/learn/dapps/identity-verification/attribute-names.md",68692],"8a4f7277":[()=>n.e(2261).then(n.bind(n,93123)),"@site/docs/sdk/marker/10_governance.md",93123],"8aa6e8ab":[()=>n.e(2048).then(n.bind(n,52531)),"@site/docs/sdk/msgfees/04_queries.md",52531],"8c6af858":[()=>n.e(857).then(n.bind(n,12158)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/index.md",12158],"8c6ce6d0":[()=>n.e(9212).then(n.bind(n,61264)),"@site/docs/pb/blockchain/basics/query-lifecycle.md",61264],"8cf8b69a":[()=>Promise.all([n.e(532),n.e(6838)]).then(n.bind(n,31742)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/execute-contract.md",31742],"8f4f3548":[()=>n.e(7559).then(n.bind(n,55290)),"@site/docs/quick-start/become-a-validator.md",55290],"9142477f":[()=>n.e(6579).then(n.bind(n,99030)),"@site/docs/sdk/trigger/README.md",99030],"91587fb7":[()=>n.e(9534).then(n.bind(n,89845)),"@site/docs/pb/contributing/adr/400-smart-contracts/402-p8e-specifications.md",89845],"918a6147":[()=>n.e(966).then(n.bind(n,41732)),"@site/docs/learn/about-provenance/foundation.md",41732],"91aa23a8":[()=>n.e(5986).then(n.bind(n,11836)),"@site/docs/pb/p8e/overview/index.md",11836],"922b40da":[()=>n.e(673).then(n.bind(n,46246)),"@site/docs/pb/ecosystem/community/delegator.md",46246],"9274dddb":[()=>n.e(8071).then(n.bind(n,73604)),"@site/docs/learn/whitepapers/blockchain-impact-on-credit-ratings.md",73604],"9286998c":[()=>n.e(336).then(n.bind(n,44015)),"@site/docs/discover/wallets.mdx",44015],"932c8818":[()=>n.e(5869).then(n.bind(n,26202)),"@site/docs/pb/p8e/client-contract-execution-environment-faq.md",26202],"935f2afb":[()=>n.e(53).then(n.t.bind(n,1109,19)),"~docs/default/version-current-metadata-prop-751.json",1109],"960691ce":[()=>n.e(8651).then(n.bind(n,50887)),"@site/docs/learn/dapps/data-privacy.md",50887],"98c0552c":[()=>n.e(458).then(n.bind(n,5241)),"@site/docs/sdk/metadata/02_state.md",5241],"98dfef2a":[()=>n.e(2396).then(n.bind(n,35183)),"@site/docs/pb/p8e/overview/api/contract-life-cycle.md",35183],"9aed69bf":[()=>n.e(4982).then(n.bind(n,9310)),"@site/docs/sdk/reward/03_state_transitions.md",9310],"9d2ba7fb":[()=>n.e(586).then(n.bind(n,51454)),"@site/docs/learn/dapps/identity-verification/flow.md",51454],"9dcb1406":[()=>n.e(4905).then(n.bind(n,48340)),"@site/docs/pb/p8e/contract-life-cycle.md",48340],"9e031b8d":[()=>n.e(6328).then(n.bind(n,7197)),"@site/docs/sdk/trigger/02_state.md",7197],"9ef3fdab":[()=>n.e(3661).then(n.bind(n,32725)),"@site/docs/pb/p8e/overview/p8e-transition-flow.md",32725],a058717d:[()=>n.e(1086).then(n.bind(n,35960)),"@site/docs/pb/p8e/p8e-usage/multi-step-contract-example.md",35960],a0c85ba5:[()=>n.e(2316).then(n.bind(n,44794)),"@site/docs/sdk/marker/02_state_transitions.md",44794],a137ef52:[()=>n.e(1663).then(n.bind(n,9343)),"@site/docs/pb/p8e/overview/api/authentication.md",9343],a211fb39:[()=>n.e(6611).then(n.bind(n,1138)),"@site/docs/discover/explorer/ui-walkthrough/dashboard/blocks.md",1138],a26be617:[()=>n.e(2860).then(n.bind(n,1624)),"@site/docs/sdk/exchange/06_params.md",1624],a4721379:[()=>n.e(6828).then(n.bind(n,18287)),"@site/docs/sdk/reward/01_concepts.md",18287],a58e2fdd:[()=>n.e(4558).then(n.bind(n,89159)),"@site/docs/pb/contributing/adr/400-smart-contracts/404-omnibus.md",89159],a5bef1e5:[()=>n.e(7407).then(n.bind(n,77757)),"@site/docs/discover/explorer/ui-walkthrough/forthcoming/blockchain-statistics.md",77757],a6955a14:[()=>n.e(786).then(n.bind(n,50952)),"@site/docs/pb/ecosystem/governance/software-upgrade-proposal.md",50952],a7bd4aaa:[()=>n.e(8518).then(n.bind(n,8564)),"@theme/DocVersionRoot",8564],a94703ab:[()=>Promise.all([n.e(532),n.e(4368)]).then(n.bind(n,12674)),"@theme/DocRoot",12674],a9df9c48:[()=>n.e(2234).then(n.bind(n,76113)),"@site/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/life-cycle-of-a-loan.md",76113],aa4cf0d5:[()=>n.e(8690).then(n.bind(n,18558)),"@site/docs/pb/blockchain/running-a-node/running-a-node-1/join-provenance-testnet/index.md",18558],ab163351:[()=>n.e(3954).then(n.bind(n,91147)),"@site/docs/sdk/hold/README.md",91147],ab8de27a:[()=>n.e(7245).then(n.bind(n,73622)),"@site/docs/pb/p8e/overview/api/README.md",73622],ac294bd0:[()=>n.e(1139).then(n.bind(n,76423)),"@site/docs/pb/blockchain/basics/gas-and-fees.md",76423],adcac10b:[()=>n.e(4249).then(n.bind(n,22130)),"@site/docs/pb/contributing/adr/index.md",22130],afe081df:[()=>n.e(2491).then(n.bind(n,43642)),"@site/docs/sdk/attribute/README.md",43642],aff65b1d:[()=>n.e(4346).then(n.bind(n,30742)),"@site/docs/pb/contributing/adr/600-governance.md",30742],b1242aa7:[()=>n.e(1343).then(n.bind(n,9164)),"@site/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/key-management/index.md",9164],b3c31fe3:[()=>n.e(3889).then(n.bind(n,67542)),"@site/docs/pb/blockchain/running-a-node/running-a-node-1/running-a-mainnet-node.md",67542],b4363cdd:[()=>n.e(6064).then(n.bind(n,52569)),"@site/docs/learn/about-provenance/index.md",52569],b540ff88:[()=>Promise.all([n.e(532),n.e(9016)]).then(n.bind(n,35644)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/retrieve-object.md",35644],b641d608:[()=>n.e(5612).then(n.bind(n,37466)),"@site/docs/pb/blockchain/running-a-node/index.md",37466],b6b00c1e:[()=>n.e(3578).then(n.bind(n,59252)),"@site/docs/learn/whitepapers/loan-participation-on-provenance.md",59252],b86c74f5:[()=>n.e(2900).then(n.bind(n,30503)),"@site/docs/sdk/metadata/06_events.md",30503],b97da1ff:[()=>n.e(9730).then(n.bind(n,56754)),"@site/docs/pb/contributing/adr/100-blockchain-configuration-and-concepts/102-markers-tokens-and-coins.md",56754],b9c66fb2:[()=>n.e(6115).then(n.bind(n,88967)),"@site/docs/sdk/oracle/02_state.md",88967],ba11e1b9:[()=>n.e(6262).then(n.bind(n,22521)),"@site/docs/learn/provenance-applications/loan-origination-system-los/funding.md",22521],ba856710:[()=>n.e(5812).then(n.bind(n,30531)),"@site/docs/sdk/marker/01_state.md",30531],baf863e5:[()=>n.e(1317).then(n.bind(n,14429)),"@site/docs/sdk/name/README.md",14429],bb0226cd:[()=>n.e(4053).then(n.bind(n,46947)),"@site/docs/pb/p8e/p8e-usage/next-steps.md",46947],bb729153:[()=>n.e(4814).then(n.bind(n,36117)),"@site/docs/pb/ecosystem/governance/index.md",36117],bd0296fc:[()=>n.e(7755).then(n.bind(n,68953)),"@site/docs/sdk/reward/README.md",68953],bd95ecf1:[()=>n.e(2207).then(n.bind(n,60133)),"@site/docs/pb/contributing/adr/300-core-concepts/index.md",60133],c0e15940:[()=>n.e(7774).then(n.bind(n,97913)),"@site/docs/discover/explorer/ui-walkthrough/walkthru.md",97913],c0e3a46c:[()=>n.e(7984).then(n.bind(n,45110)),"@site/docs/sdk/reward/08_genesis.md",45110],c203815b:[()=>n.e(6105).then(n.bind(n,59457)),"@site/docs/sdk/msgfees/05_events.md",59457],c377a04b:[()=>n.e(6971).then(n.bind(n,97433)),"@site/docs/index.md",97433],c3805537:[()=>n.e(5597).then(n.bind(n,23725)),"@site/docs/sdk/oracle/05_events.md",23725],c63d7cf9:[()=>n.e(5134).then(n.bind(n,9113)),"@site/docs/build/clients.md",9113],c77bf7af:[()=>n.e(3924).then(n.bind(n,48632)),"@site/docs/sdk/msgfees/01_concepts.md",48632],c79678dd:[()=>n.e(2941).then(n.bind(n,46675)),"@site/docs/discover/explorer/ui-walkthrough/assets.md",46675],c836b11f:[()=>n.e(8816).then(n.bind(n,48451)),"@site/docs/pb/p8e/overview/encrypted-object-store/index.md",48451],c83d36be:[()=>n.e(2453).then(n.bind(n,63116)),"@site/docs/pb/modules/ibc-and-zones.md",63116],c932c0ed:[()=>n.e(5752).then(n.bind(n,6165)),"@site/docs/pb/blockchain/basics/stablecoin.md",6165],ca8aea47:[()=>n.e(4157).then(n.bind(n,35156)),"@site/docs/pb/faq/transactions-error-codes.md",35156],cd0fdc8b:[()=>n.e(5796).then(n.bind(n,22153)),"@site/docs/sdk/exchange/05_queries.md",22153],ceb5af00:[()=>n.e(9587).then(n.bind(n,21937)),"@site/docs/learn/asset-lifecycle/02-nfts.mdx",21937],cfd5da02:[()=>n.e(1721).then(n.bind(n,29561)),"@site/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/index.md",29561],d143a44d:[()=>n.e(4528).then(n.bind(n,43937)),"@site/docs/sdk/marker/04_begin_block.md",43937],d2cf49c0:[()=>n.e(3156).then(n.bind(n,46883)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/validation-request.md",46883],d33615ad:[()=>n.e(8817).then(n.bind(n,21714)),"@site/docs/sdk/trigger/04_queries.md",21714],d468077b:[()=>n.e(784).then(n.bind(n,73974)),"@site/docs/sdk/name/05_params.md",73974],d4cf4b1e:[()=>n.e(1391).then(n.bind(n,52213)),"@site/docs/pb/contributing/adr/400-smart-contracts/401-p8e-metadata.md",52213],d4ee2c86:[()=>n.e(5446).then(n.bind(n,1340)),"@site/docs/sdk/msgfees/02_state.md",1340],d63fee6f:[()=>n.e(9648).then(n.bind(n,52653)),"@site/docs/build/libraries.md",52653],d699eab4:[()=>n.e(8330).then(n.bind(n,45468)),"@site/docs/discover/dapps.md",45468],d74cc90d:[()=>n.e(3649).then(n.bind(n,62122)),"@site/docs/pb/contributing/adr/700-business-applications.md",62122],d8f7434e:[()=>n.e(9663).then(n.bind(n,38589)),"@site/docs/learn/provenance-applications/loan-origination-system-los/onboarding-contract.md",38589],dbc15c7d:[()=>n.e(7957).then(n.bind(n,99428)),"@site/docs/sdk/marker/08_telemetry.md",99428],dc433783:[()=>n.e(3290).then(n.bind(n,67849)),"@site/docs/sdk/metadata/examples/kotlin/README.md",67849],dc56ea68:[()=>n.e(9731).then(n.bind(n,23109)),"@site/docs/sdk/marker/09_params.md",23109],dc6980cf:[()=>n.e(7052).then(n.bind(n,56718)),"@site/docs/pb/p8e/components-1/index-engine.md",56718],dc884da2:[()=>n.e(7733).then(n.bind(n,11920)),"@site/docs/sdk/trigger/01_concepts.md",11920],dcfecf48:[()=>n.e(534).then(n.bind(n,22255)),"@site/docs/discover/explorer/index.md",22255],df18dd7d:[()=>n.e(8119).then(n.bind(n,38957)),"@site/docs/learn/provenance-applications/apps-powered-by-provenance.md",38957],dfccabea:[()=>n.e(3773).then(n.bind(n,55982)),"@site/docs/pb/modules/name-module.md",55982],e0d232bf:[()=>n.e(5731).then(n.bind(n,13664)),"@site/docs/discover/resources.md",13664],e1b4a860:[()=>n.e(1081).then(n.bind(n,96420)),"@site/docs/sdk/hold/02_state.md",96420],e3a5fbe4:[()=>n.e(334).then(n.bind(n,76680)),"@site/docs/sdk/reward/04_messages.md",76680],e66e98d0:[()=>n.e(5302).then(n.bind(n,48679)),"@site/docs/build/dev-environment.md",48679],e790eacb:[()=>n.e(9576).then(n.bind(n,20140)),"@site/docs/sdk/marker/03_messages.md",20140],e7c3554b:[()=>n.e(1916).then(n.bind(n,46149)),"@site/docs/pb/contributing/adr/400-smart-contracts/405-upgrading.mdx",46149],e8bf91ff:[()=>n.e(6723).then(n.bind(n,82941)),"@site/docs/sdk/marker/07_events.md",82941],e94d5572:[()=>n.e(8972).then(n.bind(n,13272)),"@site/docs/sdk/ibchooks/README.md",13272],e94e12f0:[()=>n.e(5573).then(n.bind(n,18191)),"@site/docs/discover/smart-contract-catalog.md",18191],ea1c85ff:[()=>n.e(7445).then(n.bind(n,19799)),"@site/docs/sdk/msgfees/09_messages.md",19799],ea9d8076:[()=>n.e(969).then(n.bind(n,26602)),"@site/docs/pb/p8e/p8e-usage/data-retrieval.md",26602],eacdae2b:[()=>n.e(2042).then(n.bind(n,23451)),"@site/docs/pb/faq/delegator-faq.md",23451],eba5eeb0:[()=>n.e(1564).then(n.bind(n,26903)),"@site/docs/discover/explorer/explorer-as-a-service/index.md",26903],ec18fed9:[()=>n.e(3750).then(n.bind(n,40397)),"@site/docs/learn/dapps/ui-ux.md",40397],ec6e4860:[()=>n.e(983).then(n.bind(n,5125)),"@site/docs/learn/whitepapers/securitization-on-provenance.md",5125],ee686975:[()=>n.e(46).then(n.bind(n,36227)),"@site/docs/learn/asset-lifecycle/07-lending-example.md",36227],f032e681:[()=>n.e(6297).then(n.bind(n,97476)),"@site/docs/pb/p8e/overview/api/index-engine.md",97476],f0ad3fbb:[()=>Promise.all([n.e(532),n.e(2943),n.e(8612)]).then(n.bind(n,62943)),"@theme/ApiDoc",62943],f0ca0fdd:[()=>n.e(8326).then(n.bind(n,86607)),"@site/docs/sdk/marker/06_hooks.md",86607],f150ede0:[()=>n.e(3406).then(n.bind(n,66790)),"@site/docs/sdk/marker/11_authorization.md",66790],f1665f4c:[()=>n.e(564).then(n.bind(n,11137)),"@site/docs/pb/blockchain/introduction/application-architecture.md",11137],f19b186d:[()=>n.e(4038).then(n.bind(n,10808)),"@site/docs/pb/contributing/adr/800-system-migration.md",10808],f29001e3:[()=>n.e(1085).then(n.bind(n,66429)),"@site/docs/sdk/metadata/04_authz.md",66429],f5484fe9:[()=>n.e(1969).then(n.bind(n,69164)),"@site/docs/sdk/msgfees/06_params.md",69164],f7212c74:[()=>n.e(349).then(n.bind(n,26990)),"@site/docs/sdk/name/03_messages.md",26990],f730245e:[()=>n.e(933).then(n.bind(n,28314)),"@site/docs/learn/whitepapers/supply-chain-finance-on-provenance.md",28314],f9694a6b:[()=>n.e(6654).then(n.bind(n,10614)),"@site/docs/pb/blockchain/introduction/major-components.md",10614],fa64bb9a:[()=>n.e(3447).then(n.bind(n,14251)),"@site/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/deploying-the-encrypted-object-store/index.md",14251],fb30c99f:[()=>n.e(7787).then(n.bind(n,32313)),"@site/docs/learn/asset-lifecycle/01-assets-overview.md",32313],fb6cccac:[()=>n.e(9523).then(n.bind(n,68978)),"@site/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/index.md",68978],fb9278bc:[()=>n.e(3830).then(n.bind(n,63619)),"@site/docs/pb/blockchain/running-a-node/running-a-node-1/configure-a-sentry.md",63619],fc25d28c:[()=>Promise.all([n.e(532),n.e(5594)]).then(n.bind(n,78186)),"@site/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/store-file.mdx",78186],fcac9a94:[()=>n.e(6994).then(n.bind(n,6716)),"@site/docs/discover/explorer/ui-walkthrough/governance.md",6716],ffa4164d:[()=>n.e(1026).then(n.bind(n,28831)),"@site/docs/sdk/hold/03_events.md",28831],ffcdb96d:[()=>n.e(460).then(n.bind(n,38534)),"@site/docs/pb/p8e/p8e-usage/cross-scope-contract-example.md",38534]};var r=n(85893);function p(e){let{error:t,retry:n,pastDelay:o}=e;return t?(0,r.jsxs)("div",{style:{textAlign:"center",color:"#fff",backgroundColor:"#fa383e",borderColor:"#fa383e",borderStyle:"solid",borderRadius:"0.25rem",borderWidth:"1px",boxSizing:"border-box",display:"block",padding:"1rem",flex:"0 0 50%",marginLeft:"25%",marginRight:"25%",marginTop:"5rem",maxWidth:"50%",width:"100%"},children:[(0,r.jsx)("p",{children:String(t)}),(0,r.jsx)("div",{children:(0,r.jsx)("button",{type:"button",onClick:n,children:"Retry"})})]}):o?(0,r.jsx)("div",{style:{display:"flex",justifyContent:"center",alignItems:"center",height:"100vh"},children:(0,r.jsx)("svg",{id:"loader",style:{width:128,height:110,position:"absolute",top:"calc(100vh - 64%)"},viewBox:"0 0 45 45",xmlns:"http://www.w3.org/2000/svg",stroke:"#61dafb",children:(0,r.jsxs)("g",{fill:"none",fillRule:"evenodd",transform:"translate(1 1)",strokeWidth:"2",children:[(0,r.jsxs)("circle",{cx:"22",cy:"22",r:"6",strokeOpacity:"0",children:[(0,r.jsx)("animate",{attributeName:"r",begin:"1.5s",dur:"3s",values:"6;22",calcMode:"linear",repeatCount:"indefinite"}),(0,r.jsx)("animate",{attributeName:"stroke-opacity",begin:"1.5s",dur:"3s",values:"1;0",calcMode:"linear",repeatCount:"indefinite"}),(0,r.jsx)("animate",{attributeName:"stroke-width",begin:"1.5s",dur:"3s",values:"2;0",calcMode:"linear",repeatCount:"indefinite"})]}),(0,r.jsxs)("circle",{cx:"22",cy:"22",r:"6",strokeOpacity:"0",children:[(0,r.jsx)("animate",{attributeName:"r",begin:"3s",dur:"3s",values:"6;22",calcMode:"linear",repeatCount:"indefinite"}),(0,r.jsx)("animate",{attributeName:"stroke-opacity",begin:"3s",dur:"3s",values:"1;0",calcMode:"linear",repeatCount:"indefinite"}),(0,r.jsx)("animate",{attributeName:"stroke-width",begin:"3s",dur:"3s",values:"2;0",calcMode:"linear",repeatCount:"indefinite"})]}),(0,r.jsx)("circle",{cx:"22",cy:"22",r:"8",children:(0,r.jsx)("animate",{attributeName:"r",begin:"0s",dur:"1.5s",values:"6;1;2;3;4;5;6",calcMode:"linear",repeatCount:"indefinite"})})]})})}):null}var c=n(99670),d=n(30226);function l(e,t){if("*"===e)return i()({loading:p,loader:()=>n.e(1772).then(n.bind(n,51772)),modules:["@theme/NotFound"],webpack:()=>[51772],render(e,t){const n=e.default;return(0,r.jsx)(d.z,{value:{plugin:{name:"native",id:"default"}},children:(0,r.jsx)(n,{...t})})}});const o=s[`${e}-${t}`],l={},u=[],h=[],f=(0,c.Z)(o);return Object.entries(f).forEach((e=>{let[t,n]=e;const o=a[n];o&&(l[t]=o[0],u.push(o[1]),h.push(o[2]))})),i().Map({loading:p,loader:l,modules:u,webpack:()=>h,render(t,n){const i=JSON.parse(JSON.stringify(o));Object.entries(t).forEach((t=>{let[n,o]=t;const s=o.default;if(!s)throw new Error(`The page component at ${e} doesn't have a default export. This makes it impossible to render anything. Consider default-exporting a React component.`);"object"!=typeof s&&"function"!=typeof s||Object.keys(o).filter((e=>"default"!==e)).forEach((e=>{s[e]=o[e]}));let a=i;const r=n.split(".");r.slice(0,-1).forEach((e=>{a=a[e]})),a[r[r.length-1]]=s}));const s=i.__comp;delete i.__comp;const a=i.__context;return delete i.__context,(0,r.jsx)(d.z,{value:a,children:(0,r.jsx)(s,{...i,...n})})}})}const u=[{path:"/api/",component:l("/api/","acb"),exact:!0},{path:"/markdown-page",component:l("/markdown-page","3cc"),exact:!0},{path:"/search",component:l("/search","264"),exact:!0},{path:"/docs",component:l("/docs","389"),routes:[{path:"/docs",component:l("/docs","d83"),routes:[{path:"/docs",component:l("/docs","b8d"),routes:[{path:"/docs/",component:l("/docs/","662"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/build/clients",component:l("/docs/build/clients","2a1"),exact:!0,sidebar:"buildSidebar"},{path:"/docs/build/dev-environment",component:l("/docs/build/dev-environment","ce8"),exact:!0,sidebar:"buildSidebar"},{path:"/docs/build/libraries",component:l("/docs/build/libraries","930"),exact:!0,sidebar:"buildSidebar"},{path:"/docs/discover/dapps",component:l("/docs/discover/dapps","930"),exact:!0},{path:"/docs/discover/explorer",component:l("/docs/discover/explorer","83c"),exact:!0},{path:"/docs/discover/explorer/",component:l("/docs/discover/explorer/","1bd"),exact:!0},{path:"/docs/discover/explorer/explorer-as-a-service/",component:l("/docs/discover/explorer/explorer-as-a-service/","4c5"),exact:!0},{path:"/docs/discover/explorer/explorer-as-a-service/ingestion",component:l("/docs/discover/explorer/explorer-as-a-service/ingestion","120"),exact:!0},{path:"/docs/discover/explorer/ui-walkthrough/account-address",component:l("/docs/discover/explorer/ui-walkthrough/account-address","59c"),exact:!0},{path:"/docs/discover/explorer/ui-walkthrough/assets",component:l("/docs/discover/explorer/ui-walkthrough/assets","c7a"),exact:!0},{path:"/docs/discover/explorer/ui-walkthrough/dashboard/",component:l("/docs/discover/explorer/ui-walkthrough/dashboard/","bfa"),exact:!0},{path:"/docs/discover/explorer/ui-walkthrough/dashboard/blocks",component:l("/docs/discover/explorer/ui-walkthrough/dashboard/blocks","f9d"),exact:!0},{path:"/docs/discover/explorer/ui-walkthrough/forthcoming/blockchain-statistics",component:l("/docs/discover/explorer/ui-walkthrough/forthcoming/blockchain-statistics","859"),exact:!0},{path:"/docs/discover/explorer/ui-walkthrough/forthcoming/ibc",component:l("/docs/discover/explorer/ui-walkthrough/forthcoming/ibc","f04"),exact:!0},{path:"/docs/discover/explorer/ui-walkthrough/governance",component:l("/docs/discover/explorer/ui-walkthrough/governance","710"),exact:!0},{path:"/docs/discover/explorer/ui-walkthrough/staking-validators/",component:l("/docs/discover/explorer/ui-walkthrough/staking-validators/","3ed"),exact:!0},{path:"/docs/discover/explorer/ui-walkthrough/staking-validators/validator-details",component:l("/docs/discover/explorer/ui-walkthrough/staking-validators/validator-details","1c2"),exact:!0},{path:"/docs/discover/explorer/ui-walkthrough/transactions",component:l("/docs/discover/explorer/ui-walkthrough/transactions","3f7"),exact:!0},{path:"/docs/discover/explorer/ui-walkthrough/walkthru",component:l("/docs/discover/explorer/ui-walkthrough/walkthru","8d5"),exact:!0},{path:"/docs/discover/hash",component:l("/docs/discover/hash","523"),exact:!0},{path:"/docs/discover/money",component:l("/docs/discover/money","86d"),exact:!0},{path:"/docs/discover/ramps",component:l("/docs/discover/ramps","862"),exact:!0},{path:"/docs/discover/resources",component:l("/docs/discover/resources","feb"),exact:!0},{path:"/docs/discover/smart-contract-catalog",component:l("/docs/discover/smart-contract-catalog","2cd"),exact:!0},{path:"/docs/discover/solutions",component:l("/docs/discover/solutions","5a0"),exact:!0},{path:"/docs/discover/staking",component:l("/docs/discover/staking","a24"),exact:!0},{path:"/docs/discover/usdf",component:l("/docs/discover/usdf","b48"),exact:!0},{path:"/docs/discover/wallets",component:l("/docs/discover/wallets","8a8"),exact:!0},{path:"/docs/learn/about-provenance/",component:l("/docs/learn/about-provenance/","f15"),exact:!0},{path:"/docs/learn/about-provenance/foundation",component:l("/docs/learn/about-provenance/foundation","248"),exact:!0},{path:"/docs/learn/asset-lifecycle/",component:l("/docs/learn/asset-lifecycle/","ce4"),exact:!0},{path:"/docs/learn/asset-lifecycle/assets-overview",component:l("/docs/learn/asset-lifecycle/assets-overview","a45"),exact:!0,sidebar:"assetLifecycleSidebar"},{path:"/docs/learn/asset-lifecycle/capital-raise-example",component:l("/docs/learn/asset-lifecycle/capital-raise-example","706"),exact:!0,sidebar:"assetLifecycleSidebar"},{path:"/docs/learn/asset-lifecycle/issue",component:l("/docs/learn/asset-lifecycle/issue","f23"),exact:!0},{path:"/docs/learn/asset-lifecycle/lending-example",component:l("/docs/learn/asset-lifecycle/lending-example","753"),exact:!0,sidebar:"assetLifecycleSidebar"},{path:"/docs/learn/asset-lifecycle/manage",component:l("/docs/learn/asset-lifecycle/manage","316"),exact:!0},{path:"/docs/learn/asset-lifecycle/markers",component:l("/docs/learn/asset-lifecycle/markers","73c"),exact:!0,sidebar:"assetLifecycleSidebar"},{path:"/docs/learn/asset-lifecycle/nfts",component:l("/docs/learn/asset-lifecycle/nfts","ad3"),exact:!0,sidebar:"assetLifecycleSidebar"},{path:"/docs/learn/asset-lifecycle/trade",component:l("/docs/learn/asset-lifecycle/trade","60d"),exact:!0},{path:"/docs/learn/dapps/blockchain-communication",component:l("/docs/learn/dapps/blockchain-communication","7b5"),exact:!0},{path:"/docs/learn/dapps/dapp-architecture",component:l("/docs/learn/dapps/dapp-architecture","6d9"),exact:!0},{path:"/docs/learn/dapps/dapps-overview",component:l("/docs/learn/dapps/dapps-overview","ba7"),exact:!0,sidebar:"dappsSidebar"},{path:"/docs/learn/dapps/data-privacy",component:l("/docs/learn/dapps/data-privacy","8a7"),exact:!0},{path:"/docs/learn/dapps/fiat-ramps",component:l("/docs/learn/dapps/fiat-ramps","196"),exact:!0},{path:"/docs/learn/dapps/identity-verification",component:l("/docs/learn/dapps/identity-verification","5d5"),exact:!0,sidebar:"dappsSidebar"},{path:"/docs/learn/dapps/identity-verification/attribute-names",component:l("/docs/learn/dapps/identity-verification/attribute-names","9d6"),exact:!0,sidebar:"dappsSidebar"},{path:"/docs/learn/dapps/identity-verification/attribute-values",component:l("/docs/learn/dapps/identity-verification/attribute-values","2fd"),exact:!0,sidebar:"dappsSidebar"},{path:"/docs/learn/dapps/identity-verification/flow",component:l("/docs/learn/dapps/identity-verification/flow","90e"),exact:!0,sidebar:"dappsSidebar"},{path:"/docs/learn/dapps/identity-verification/identity-attribute-tutorial",component:l("/docs/learn/dapps/identity-verification/identity-attribute-tutorial","2a6"),exact:!0},{path:"/docs/learn/dapps/identity-verification/identity-nfts",component:l("/docs/learn/dapps/identity-verification/identity-nfts","d8a"),exact:!0,sidebar:"dappsSidebar"},{path:"/docs/learn/dapps/organization-management",component:l("/docs/learn/dapps/organization-management","b89"),exact:!0},{path:"/docs/learn/dapps/ui-ux",component:l("/docs/learn/dapps/ui-ux","f2d"),exact:!0},{path:"/docs/learn/learn-about",component:l("/docs/learn/learn-about","b60"),exact:!0},{path:"/docs/learn/provenance-applications/apps-powered-by-provenance",component:l("/docs/learn/provenance-applications/apps-powered-by-provenance","45e"),exact:!0},{path:"/docs/learn/provenance-applications/loan-origination-system-los/",component:l("/docs/learn/provenance-applications/loan-origination-system-los/","a96"),exact:!0},{path:"/docs/learn/provenance-applications/loan-origination-system-los/assets",component:l("/docs/learn/provenance-applications/loan-origination-system-los/assets","04c"),exact:!0},{path:"/docs/learn/provenance-applications/loan-origination-system-los/data-sharing-with-portfolio-manager",component:l("/docs/learn/provenance-applications/loan-origination-system-los/data-sharing-with-portfolio-manager","a28"),exact:!0},{path:"/docs/learn/provenance-applications/loan-origination-system-los/funding",component:l("/docs/learn/provenance-applications/loan-origination-system-los/funding","85f"),exact:!0},{path:"/docs/learn/provenance-applications/loan-origination-system-los/loan-servicing",component:l("/docs/learn/provenance-applications/loan-origination-system-los/loan-servicing","f0a"),exact:!0},{path:"/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/",component:l("/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/","afb"),exact:!0},{path:"/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/3rd-party-digital-signatures",component:l("/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/3rd-party-digital-signatures","ab5"),exact:!0},{path:"/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/loan-servicing",component:l("/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/loan-servicing","cca"),exact:!0},{path:"/docs/learn/provenance-applications/loan-origination-system-los/onboarding-contract",component:l("/docs/learn/provenance-applications/loan-origination-system-los/onboarding-contract","b65"),exact:!0},{path:"/docs/learn/provenance-applications/omnibus",component:l("/docs/learn/provenance-applications/omnibus","ef0"),exact:!0},{path:"/docs/learn/whitepapers/blockchain-impact-on-credit-ratings",component:l("/docs/learn/whitepapers/blockchain-impact-on-credit-ratings","9b4"),exact:!0},{path:"/docs/learn/whitepapers/investment-fund-services-on-provenance",component:l("/docs/learn/whitepapers/investment-fund-services-on-provenance","98a"),exact:!0},{path:"/docs/learn/whitepapers/loan-participation-on-provenance",component:l("/docs/learn/whitepapers/loan-participation-on-provenance","626"),exact:!0},{path:"/docs/learn/whitepapers/securitization-on-provenance",component:l("/docs/learn/whitepapers/securitization-on-provenance","110"),exact:!0},{path:"/docs/learn/whitepapers/supply-chain-finance-on-provenance",component:l("/docs/learn/whitepapers/supply-chain-finance-on-provenance","ed8"),exact:!0},{path:"/docs/learn/why-cosmos",component:l("/docs/learn/why-cosmos","92d"),exact:!0},{path:"/docs/pb/blockchain/basics/accounts",component:l("/docs/pb/blockchain/basics/accounts","415"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/basics/anatomy-of-a-provenance-application",component:l("/docs/pb/blockchain/basics/anatomy-of-a-provenance-application","571"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/basics/gas-and-fees",component:l("/docs/pb/blockchain/basics/gas-and-fees","146"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/basics/query-lifecycle",component:l("/docs/pb/blockchain/basics/query-lifecycle","5a4"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/basics/stablecoin",component:l("/docs/pb/blockchain/basics/stablecoin","761"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/basics/transaction-lifecycle",component:l("/docs/pb/blockchain/basics/transaction-lifecycle","983"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/introduction/",component:l("/docs/pb/blockchain/introduction/","aa3"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/introduction/application-architecture",component:l("/docs/pb/blockchain/introduction/application-architecture","6d5"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/introduction/major-components",component:l("/docs/pb/blockchain/introduction/major-components","cee"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/running-a-node/",component:l("/docs/pb/blockchain/running-a-node/","d50"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/running-a-node/running-a-node-1/",component:l("/docs/pb/blockchain/running-a-node/running-a-node-1/","c22"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/running-a-node/running-a-node-1/become-a-validator",component:l("/docs/pb/blockchain/running-a-node/running-a-node-1/become-a-validator","5ea"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/running-a-node/running-a-node-1/configure-a-sentry",component:l("/docs/pb/blockchain/running-a-node/running-a-node-1/configure-a-sentry","717"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/running-a-node/running-a-node-1/join-provenance-testnet/",component:l("/docs/pb/blockchain/running-a-node/running-a-node-1/join-provenance-testnet/","d5d"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/running-a-node/running-a-node-1/join-provenance-testnet/running-a-testnet-node-from-quicksync",component:l("/docs/pb/blockchain/running-a-node/running-a-node-1/join-provenance-testnet/running-a-testnet-node-from-quicksync","9c4"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/running-a-node/running-a-node-1/running-a-mainnet-node",component:l("/docs/pb/blockchain/running-a-node/running-a-node-1/running-a-mainnet-node","b87"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/using-provenance/",component:l("/docs/pb/blockchain/using-provenance/","1e7"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/using-provenance/query-command",component:l("/docs/pb/blockchain/using-provenance/query-command","fbb"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/blockchain/using-provenance/tx-command",component:l("/docs/pb/blockchain/using-provenance/tx-command","920"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/",component:l("/docs/pb/contributing/adr/","7e6"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/administration",component:l("/docs/pb/contributing/adr/administration","91f"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/base-infrastructure/",component:l("/docs/pb/contributing/adr/base-infrastructure/","591"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/base-infrastructure/account-metadata",component:l("/docs/pb/contributing/adr/base-infrastructure/account-metadata","65e"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/base-infrastructure/name-service",component:l("/docs/pb/contributing/adr/base-infrastructure/name-service","2ca"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/",component:l("/docs/pb/contributing/adr/blockchain-configuration-and-concepts/","bf7"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/genesis-network-configuration",component:l("/docs/pb/contributing/adr/blockchain-configuration-and-concepts/genesis-network-configuration","f13"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/hd-wallets-key-pairs-addresses",component:l("/docs/pb/contributing/adr/blockchain-configuration-and-concepts/hd-wallets-key-pairs-addresses","314"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/markers-tokens-and-coins",component:l("/docs/pb/contributing/adr/blockchain-configuration-and-concepts/markers-tokens-and-coins","f05"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/transaction-fees-and-gas",component:l("/docs/pb/contributing/adr/blockchain-configuration-and-concepts/transaction-fees-and-gas","e71"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/business-applications",component:l("/docs/pb/contributing/adr/business-applications","5eb"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/core-concepts/",component:l("/docs/pb/contributing/adr/core-concepts/","3a7"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/core-concepts/hash",component:l("/docs/pb/contributing/adr/core-concepts/hash","fa5"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/core-concepts/identity",component:l("/docs/pb/contributing/adr/core-concepts/identity","7ba"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/governance",component:l("/docs/pb/contributing/adr/governance","e80"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/smart-contracts/",component:l("/docs/pb/contributing/adr/smart-contracts/","0f0"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/smart-contracts/omnibus",component:l("/docs/pb/contributing/adr/smart-contracts/omnibus","f07"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/smart-contracts/p8e-metadata",component:l("/docs/pb/contributing/adr/smart-contracts/p8e-metadata","5b5"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/smart-contracts/p8e-smart-contracts",component:l("/docs/pb/contributing/adr/smart-contracts/p8e-smart-contracts","711"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/smart-contracts/p8e-specifications",component:l("/docs/pb/contributing/adr/smart-contracts/p8e-specifications","8e5"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/smart-contracts/smart-contracts-1",component:l("/docs/pb/contributing/adr/smart-contracts/smart-contracts-1","a57"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/smart-contracts/upgrading",component:l("/docs/pb/contributing/adr/smart-contracts/upgrading","827"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/system-migration",component:l("/docs/pb/contributing/adr/system-migration","d3e"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/contributing/adr/template",component:l("/docs/pb/contributing/adr/template","c18"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/ecosystem/community/asset-originators",component:l("/docs/pb/ecosystem/community/asset-originators","51e"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/ecosystem/community/delegator",component:l("/docs/pb/ecosystem/community/delegator","870"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/ecosystem/community/validator",component:l("/docs/pb/ecosystem/community/validator","895"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/ecosystem/financial-services-blockchain/",component:l("/docs/pb/ecosystem/financial-services-blockchain/","af9"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/ecosystem/financial-services-blockchain/distribution",component:l("/docs/pb/ecosystem/financial-services-blockchain/distribution","350"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/ecosystem/financial-services-blockchain/token-economics",component:l("/docs/pb/ecosystem/financial-services-blockchain/token-economics","a26"),exact:!0},{path:"/docs/pb/ecosystem/governance/",component:l("/docs/pb/ecosystem/governance/","d7d"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/ecosystem/governance/software-upgrade-proposal",component:l("/docs/pb/ecosystem/governance/software-upgrade-proposal","c77"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/ecosystem/governance/voting",component:l("/docs/pb/ecosystem/governance/voting","9b9"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/faq/delegator-faq",component:l("/docs/pb/faq/delegator-faq","1bf"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/faq/transactions-error-codes",component:l("/docs/pb/faq/transactions-error-codes","59b"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/faq/validator-faq",component:l("/docs/pb/faq/validator-faq","af7"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/asset-originators-guide",component:l("/docs/pb/integrating/asset-originators-guide","2c1"),exact:!0},{path:"/docs/pb/integrating/integrating-with-p8e/",component:l("/docs/pb/integrating/integrating-with-p8e/","0f3"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/",component:l("/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/","767"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/data-mapping",component:l("/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/data-mapping","2fa"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/life-cycle-of-a-loan",component:l("/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/life-cycle-of-a-loan","add"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/","5b2"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/","c47"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/configuration-endpoints",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/configuration-endpoints","ee0"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/","94e"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/approve-contract",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/approve-contract","e72"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/execute-contract",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/execute-contract","5d5"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/","a9c"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/retrieve-file",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/retrieve-file","d83"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/retrieve-object",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/retrieve-object","8e0"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/store-file",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/store-file","f95"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/store-object",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/store-object","418"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/p8e-endpoints",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/p8e-endpoints","f7c"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/","040"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/error-handling",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/error-handling","a82"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/loan-onboarding",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/loan-onboarding","253"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/validation-request",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/validation-request","dfc"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/validation-response",component:l("/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/validation-response","727"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/",component:l("/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/","dd8"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/deploying-the-encrypted-object-store/",component:l("/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/deploying-the-encrypted-object-store/","3b3"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/deploying-the-encrypted-object-store/configuring-replication",component:l("/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/deploying-the-encrypted-object-store/configuring-replication","c01"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/key-management/",component:l("/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/key-management/","a2d"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/key-management/permissioning-others",component:l("/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/key-management/permissioning-others","c37"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/p8e-contracts/",component:l("/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/p8e-contracts/","5af"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/p8e-contracts/example-loan-contracts",component:l("/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/p8e-contracts/example-loan-contracts","f1e"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/summary",component:l("/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/summary","7cc"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/modules/",component:l("/docs/pb/modules/","acb"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/modules/attribute-module",component:l("/docs/pb/modules/attribute-module","f48"),exact:!0},{path:"/docs/pb/modules/cosmos-modules",component:l("/docs/pb/modules/cosmos-modules","c1c"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/modules/ibc-and-zones",component:l("/docs/pb/modules/ibc-and-zones","210"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/modules/marker-module",component:l("/docs/pb/modules/marker-module","4b9"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/modules/metadata-module",component:l("/docs/pb/modules/metadata-module","862"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/modules/name-module",component:l("/docs/pb/modules/name-module","373"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/modules/provwasm-smart-contracts",component:l("/docs/pb/modules/provwasm-smart-contracts","7e3"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/",component:l("/docs/pb/p8e/","5ae"),exact:!0},{path:"/docs/pb/p8e/client-contract-execution-environment-faq",component:l("/docs/pb/p8e/client-contract-execution-environment-faq","85b"),exact:!0},{path:"/docs/pb/p8e/components-1/api",component:l("/docs/pb/p8e/components-1/api","3f6"),exact:!0},{path:"/docs/pb/p8e/components-1/index-engine",component:l("/docs/pb/p8e/components-1/index-engine","824"),exact:!0},{path:"/docs/pb/p8e/contract-life-cycle",component:l("/docs/pb/p8e/contract-life-cycle","da1"),exact:!0},{path:"/docs/pb/p8e/overview/",component:l("/docs/pb/p8e/overview/","1e0"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/overview/api",component:l("/docs/pb/p8e/overview/api","6b0"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/overview/api/",component:l("/docs/pb/p8e/overview/api/","0cd"),exact:!0},{path:"/docs/pb/p8e/overview/api/authentication",component:l("/docs/pb/p8e/overview/api/authentication","280"),exact:!0},{path:"/docs/pb/p8e/overview/api/contract-life-cycle",component:l("/docs/pb/p8e/overview/api/contract-life-cycle","9d1"),exact:!0},{path:"/docs/pb/p8e/overview/api/index-engine",component:l("/docs/pb/p8e/overview/api/index-engine","94d"),exact:!0},{path:"/docs/pb/p8e/overview/api/signing-and-encryption",component:l("/docs/pb/p8e/overview/api/signing-and-encryption","8c0"),exact:!0},{path:"/docs/pb/p8e/overview/encrypted-object-store/",component:l("/docs/pb/p8e/overview/encrypted-object-store/","eaa"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/overview/encrypted-object-store/dime-encryption-envelope-specification",component:l("/docs/pb/p8e/overview/encrypted-object-store/dime-encryption-envelope-specification","466"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/overview/encrypted-object-store/encryption-scheme",component:l("/docs/pb/p8e/overview/encrypted-object-store/encryption-scheme","c42"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/overview/p8e-transition-flow",component:l("/docs/pb/p8e/overview/p8e-transition-flow","86f"),exact:!0},{path:"/docs/pb/p8e/overview/p8e-ui",component:l("/docs/pb/p8e/overview/p8e-ui","1f8"),exact:!0},{path:"/docs/pb/p8e/p8e-usage/architecture",component:l("/docs/pb/p8e/p8e-usage/architecture","a3f"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/p8e-usage/building-new-contracts",component:l("/docs/pb/p8e/p8e-usage/building-new-contracts","979"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/p8e-usage/cross-scope-contract-example",component:l("/docs/pb/p8e/p8e-usage/cross-scope-contract-example","f62"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/p8e-usage/data-retrieval",component:l("/docs/pb/p8e/p8e-usage/data-retrieval","ebd"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/p8e-usage/multi-contract-example",component:l("/docs/pb/p8e/p8e-usage/multi-contract-example","cfb"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/p8e-usage/multi-step-contract-example",component:l("/docs/pb/p8e/p8e-usage/multi-step-contract-example","147"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/p8e-usage/next-steps",component:l("/docs/pb/p8e/p8e-usage/next-steps","fa5"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/p8e-usage/p8e-setup",component:l("/docs/pb/p8e/p8e-usage/p8e-setup","f63"),exact:!0},{path:"/docs/pb/p8e/p8e-usage/quick-start/",component:l("/docs/pb/p8e/p8e-usage/quick-start/","8a7"),exact:!0},{path:"/docs/pb/p8e/p8e-usage/quick-start/hello-world-example",component:l("/docs/pb/p8e/p8e-usage/quick-start/hello-world-example","3f4"),exact:!0},{path:"/docs/pb/p8e/p8e-usage/specifications",component:l("/docs/pb/p8e/p8e-usage/specifications","06b"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/pb/p8e/security",component:l("/docs/pb/p8e/security","81f"),exact:!0},{path:"/docs/pb/p8e/untitled/",component:l("/docs/pb/p8e/untitled/","bfa"),exact:!0},{path:"/docs/pb/p8e/untitled/3rd-party-digital-signatures",component:l("/docs/pb/p8e/untitled/3rd-party-digital-signatures","f6f"),exact:!0},{path:"/docs/quick-start/become-a-validator",component:l("/docs/quick-start/become-a-validator","2dc"),exact:!0},{path:"/docs/quick-start/build-a-dapp",component:l("/docs/quick-start/build-a-dapp","15e"),exact:!0},{path:"/docs/quick-start/start-here",component:l("/docs/quick-start/start-here","069"),exact:!0},{path:"/docs/quick-start/wallet-and-hash",component:l("/docs/quick-start/wallet-and-hash","72c"),exact:!0},{path:"/docs/quick-start/write-a-smart-contract",component:l("/docs/quick-start/write-a-smart-contract","e06"),exact:!0},{path:"/docs/sdk/",component:l("/docs/sdk/","268"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/attribute/",component:l("/docs/sdk/attribute/","684"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/attribute/events",component:l("/docs/sdk/attribute/events","357"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/attribute/messages",component:l("/docs/sdk/attribute/messages","b04"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/attribute/params",component:l("/docs/sdk/attribute/params","eb3"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/attribute/state",component:l("/docs/sdk/attribute/state","282"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/exchange/",component:l("/docs/sdk/exchange/","eca"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/exchange/concepts",component:l("/docs/sdk/exchange/concepts","8f7"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/exchange/events",component:l("/docs/sdk/exchange/events","4f5"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/exchange/messages",component:l("/docs/sdk/exchange/messages","576"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/exchange/params",component:l("/docs/sdk/exchange/params","18d"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/exchange/queries",component:l("/docs/sdk/exchange/queries","6bb"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/exchange/state",component:l("/docs/sdk/exchange/state","d04"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/hold/",component:l("/docs/sdk/hold/","8ba"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/hold/concepts",component:l("/docs/sdk/hold/concepts","05a"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/hold/events",component:l("/docs/sdk/hold/events","663"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/hold/queries",component:l("/docs/sdk/hold/queries","91b"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/hold/state",component:l("/docs/sdk/hold/state","05d"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/ibchooks/",component:l("/docs/sdk/ibchooks/","32d"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/ibcratelimit/",component:l("/docs/sdk/ibcratelimit/","6ea"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/",component:l("/docs/sdk/marker/","6e3"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/authorization",component:l("/docs/sdk/marker/authorization","5df"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/begin_block",component:l("/docs/sdk/marker/begin_block","faa"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/end_block",component:l("/docs/sdk/marker/end_block","225"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/events",component:l("/docs/sdk/marker/events","2d3"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/governance",component:l("/docs/sdk/marker/governance","177"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/hooks",component:l("/docs/sdk/marker/hooks","7f7"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/messages",component:l("/docs/sdk/marker/messages","676"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/params",component:l("/docs/sdk/marker/params","899"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/state",component:l("/docs/sdk/marker/state","e86"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/state_transitions",component:l("/docs/sdk/marker/state_transitions","17e"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/telemetry",component:l("/docs/sdk/marker/telemetry","d6c"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/marker/transfers",component:l("/docs/sdk/marker/transfers","56a"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/metadata/",component:l("/docs/sdk/metadata/","631"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/metadata/authz",component:l("/docs/sdk/metadata/authz","e9f"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/metadata/concepts",component:l("/docs/sdk/metadata/concepts","42e"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/metadata/events",component:l("/docs/sdk/metadata/events","ca5"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/metadata/examples/kotlin/",component:l("/docs/sdk/metadata/examples/kotlin/","47b"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/metadata/messages",component:l("/docs/sdk/metadata/messages","c25"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/metadata/params",component:l("/docs/sdk/metadata/params","2d6"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/metadata/queries",component:l("/docs/sdk/metadata/queries","f15"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/metadata/state",component:l("/docs/sdk/metadata/state","dbe"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/metadata/telemetry",component:l("/docs/sdk/metadata/telemetry","c90"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/msgfees/",component:l("/docs/sdk/msgfees/","146"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/msgfees/concepts",component:l("/docs/sdk/msgfees/concepts","6fd"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/msgfees/events",component:l("/docs/sdk/msgfees/events","7d1"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/msgfees/genesis",component:l("/docs/sdk/msgfees/genesis","7ed"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/msgfees/governance",component:l("/docs/sdk/msgfees/governance","a69"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/msgfees/messages",component:l("/docs/sdk/msgfees/messages","ba4"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/msgfees/params",component:l("/docs/sdk/msgfees/params","88d"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/msgfees/queries",component:l("/docs/sdk/msgfees/queries","851"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/msgfees/start_end_block",component:l("/docs/sdk/msgfees/start_end_block","d30"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/msgfees/state",component:l("/docs/sdk/msgfees/state","f69"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/name/",component:l("/docs/sdk/name/","feb"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/name/concepts",component:l("/docs/sdk/name/concepts","adc"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/name/events",component:l("/docs/sdk/name/events","93e"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/name/messages",component:l("/docs/sdk/name/messages","0f6"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/name/params",component:l("/docs/sdk/name/params","aa0"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/name/state",component:l("/docs/sdk/name/state","639"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/oracle/",component:l("/docs/sdk/oracle/","07b"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/oracle/concepts",component:l("/docs/sdk/oracle/concepts","0ae"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/oracle/events",component:l("/docs/sdk/oracle/events","dc3"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/oracle/genesis",component:l("/docs/sdk/oracle/genesis","83c"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/oracle/messages",component:l("/docs/sdk/oracle/messages","247"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/oracle/queries",component:l("/docs/sdk/oracle/queries","615"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/oracle/state",component:l("/docs/sdk/oracle/state","d06"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/reward/",component:l("/docs/sdk/reward/","349"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/reward/begin_and_end_blocker",component:l("/docs/sdk/reward/begin_and_end_blocker","feb"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/reward/concepts",component:l("/docs/sdk/reward/concepts","e25"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/reward/events",component:l("/docs/sdk/reward/events","7f7"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/reward/genesis",component:l("/docs/sdk/reward/genesis","a9d"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/reward/messages",component:l("/docs/sdk/reward/messages","6bb"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/reward/queries",component:l("/docs/sdk/reward/queries","c30"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/reward/state",component:l("/docs/sdk/reward/state","c17"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/reward/state_transitions",component:l("/docs/sdk/reward/state_transitions","46c"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/trigger/",component:l("/docs/sdk/trigger/","df5"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/trigger/begin_and_end_blocker",component:l("/docs/sdk/trigger/begin_and_end_blocker","0cd"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/trigger/concepts",component:l("/docs/sdk/trigger/concepts","02f"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/trigger/events",component:l("/docs/sdk/trigger/events","dca"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/trigger/genesis",component:l("/docs/sdk/trigger/genesis","576"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/trigger/messages",component:l("/docs/sdk/trigger/messages","c9c"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/trigger/queries",component:l("/docs/sdk/trigger/queries","849"),exact:!0,sidebar:"documentationSidebar"},{path:"/docs/sdk/trigger/state",component:l("/docs/sdk/trigger/state","501"),exact:!0,sidebar:"documentationSidebar"}]}]}]},{path:"/",component:l("/","2bb"),exact:!0},{path:"*",component:l("*")}]},98934:(e,t,n)=>{"use strict";n.d(t,{_:()=>s,t:()=>a});var o=n(67294),i=n(85893);const s=o.createContext(!1);function a(e){let{children:t}=e;const[n,a]=(0,o.useState)(!1);return(0,o.useEffect)((()=>{a(!0)}),[]),(0,i.jsx)(s.Provider,{value:n,children:t})}},97221:(e,t,n)=>{"use strict";var o=n(67294),i=n(20745),s=n(73727),a=n(70405),r=n(10412);const p=[n(56657),n(32497),n(3310),n(18320),n(52295),n(41304),n(4750)];var c=n(723),d=n(16550),l=n(18790),u=n(85893);function h(e){let{children:t}=e;return(0,u.jsx)(u.Fragment,{children:t})}var f=n(35742),y=n(52263),m=n(44996),g=n(86668),_=n(10833),b=n(94711),T=n(19727),v=n(43320),P=n(18780),E=n(90197);function R(){const{i18n:{currentLocale:e,defaultLocale:t,localeConfigs:n}}=(0,y.Z)(),o=(0,b.l)(),i=n[e].htmlLang,s=e=>e.replace("-","_");return(0,u.jsxs)(f.Z,{children:[Object.entries(n).map((e=>{let[t,{htmlLang:n}]=e;return(0,u.jsx)("link",{rel:"alternate",href:o.createUrl({locale:t,fullyQualified:!0}),hrefLang:n},t)})),(0,u.jsx)("link",{rel:"alternate",href:o.createUrl({locale:t,fullyQualified:!0}),hrefLang:"x-default"}),(0,u.jsx)("meta",{property:"og:locale",content:s(i)}),Object.values(n).filter((e=>i!==e.htmlLang)).map((e=>(0,u.jsx)("meta",{property:"og:locale:alternate",content:s(e.htmlLang)},`meta-og-${e.htmlLang}`)))]})}function A(e){let{permalink:t}=e;const{siteConfig:{url:n}}=(0,y.Z)(),o=function(){const{siteConfig:{url:e,baseUrl:t,trailingSlash:n}}=(0,y.Z)(),{pathname:o}=(0,d.TH)();return e+(0,P.applyTrailingSlash)((0,m.Z)(o),{trailingSlash:n,baseUrl:t})}(),i=t?`${n}${t}`:o;return(0,u.jsxs)(f.Z,{children:[(0,u.jsx)("meta",{property:"og:url",content:i}),(0,u.jsx)("link",{rel:"canonical",href:i})]})}function k(){const{i18n:{currentLocale:e}}=(0,y.Z)(),{metadata:t,image:n}=(0,g.L)();return(0,u.jsxs)(u.Fragment,{children:[(0,u.jsxs)(f.Z,{children:[(0,u.jsx)("meta",{name:"twitter:card",content:"summary_large_image"}),(0,u.jsx)("body",{className:T.h})]}),n&&(0,u.jsx)(_.d,{image:n}),(0,u.jsx)(A,{}),(0,u.jsx)(R,{}),(0,u.jsx)(E.Z,{tag:v.HX,locale:e}),(0,u.jsx)(f.Z,{children:t.map(((e,t)=>(0,u.jsx)("meta",{...e},t)))})]})}const w=new Map;function S(e){if(w.has(e.pathname))return{...e,pathname:w.get(e.pathname)};if((0,l.f)(c.Z,e.pathname).some((e=>{let{route:t}=e;return!0===t.exact})))return w.set(e.pathname,e.pathname),e;const t=e.pathname.trim().replace(/(?:\/index)?\.html$/,"")||"/";return w.set(e.pathname,t),{...e,pathname:t}}var I=n(98934),O=n(58940),x=n(20469);function N(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),o=1;o<t;o++)n[o-1]=arguments[o];const i=p.map((t=>{const o=t.default?.[e]??t[e];return o?.(...n)}));return()=>i.forEach((e=>e?.()))}const U=function(e){let{children:t,location:n,previousLocation:o}=e;return(0,x.Z)((()=>{o!==n&&(!function(e){let{location:t,previousLocation:n}=e;if(!n)return;const o=t.pathname===n.pathname,i=t.hash===n.hash,s=t.search===n.search;if(o&&i&&!s)return;const{hash:a}=t;if(a){const e=decodeURIComponent(a.substring(1)),t=document.getElementById(e);t?.scrollIntoView()}else window.scrollTo(0,0)}({location:n,previousLocation:o}),N("onRouteDidUpdate",{previousLocation:o,location:n}))}),[o,n]),t};function Y(e){const t=Array.from(new Set([e,decodeURI(e)])).map((e=>(0,l.f)(c.Z,e))).flat();return Promise.all(t.map((e=>e.route.component.preload?.())))}class C extends o.Component{previousLocation;routeUpdateCleanupCb;constructor(e){super(e),this.previousLocation=null,this.routeUpdateCleanupCb=r.default.canUseDOM?N("onRouteUpdate",{previousLocation:null,location:this.props.location}):()=>{},this.state={nextRouteHasLoaded:!0}}shouldComponentUpdate(e,t){if(e.location===this.props.location)return t.nextRouteHasLoaded;const n=e.location;return this.previousLocation=this.props.location,this.setState({nextRouteHasLoaded:!1}),this.routeUpdateCleanupCb=N("onRouteUpdate",{previousLocation:this.previousLocation,location:n}),Y(n.pathname).then((()=>{this.routeUpdateCleanupCb(),this.setState({nextRouteHasLoaded:!0})})).catch((e=>{console.warn(e),window.location.reload()})),!1}render(){const{children:e,location:t}=this.props;return(0,u.jsx)(U,{previousLocation:this.previousLocation,location:t,children:(0,u.jsx)(d.AW,{location:t,render:()=>e})})}}const L=C,D="__docusaurus-base-url-issue-banner-container",q="__docusaurus-base-url-issue-banner",F="__docusaurus-base-url-issue-banner-suggestion-container";function j(e){return`\ndocument.addEventListener('DOMContentLoaded', function maybeInsertBanner() {\n  var shouldInsert = typeof window['docusaurus'] === 'undefined';\n  shouldInsert && insertBanner();\n});\n\nfunction insertBanner() {\n  var bannerContainer = document.createElement('div');\n  bannerContainer.id = '${D}';\n  var bannerHtml = ${JSON.stringify(function(e){return`\n<div id="${q}" style="border: thick solid red; background-color: rgb(255, 230, 179); margin: 20px; padding: 20px; font-size: 20px;">\n   <p style="font-weight: bold; font-size: 30px;">Your Docusaurus site did not load properly.</p>\n   <p>A very common reason is a wrong site <a href="https://docusaurus.io/docs/docusaurus.config.js/#baseUrl" style="font-weight: bold;">baseUrl configuration</a>.</p>\n   <p>Current configured baseUrl = <span style="font-weight: bold; color: red;">${e}</span> ${"/"===e?" (default value)":""}</p>\n   <p>We suggest trying baseUrl = <span id="${F}" style="font-weight: bold; color: green;"></span></p>\n</div>\n`}(e)).replace(/</g,"\\<")};\n  bannerContainer.innerHTML = bannerHtml;\n  document.body.prepend(bannerContainer);\n  var suggestionContainer = document.getElementById('${F}');\n  var actualHomePagePath = window.location.pathname;\n  var suggestedBaseUrl = actualHomePagePath.substr(-1) === '/'\n        ? actualHomePagePath\n        : actualHomePagePath + '/';\n  suggestionContainer.innerHTML = suggestedBaseUrl;\n}\n`}function M(){const{siteConfig:{baseUrl:e}}=(0,y.Z)();return(0,u.jsx)(u.Fragment,{children:!r.default.canUseDOM&&(0,u.jsx)(f.Z,{children:(0,u.jsx)("script",{children:j(e)})})})}function z(){const{siteConfig:{baseUrl:e,baseUrlIssueBanner:t}}=(0,y.Z)(),{pathname:n}=(0,d.TH)();return t&&n===e?(0,u.jsx)(M,{}):null}function V(){const{siteConfig:{favicon:e,title:t,noIndex:n},i18n:{currentLocale:o,localeConfigs:i}}=(0,y.Z)(),s=(0,m.Z)(e),{htmlLang:a,direction:r}=i[o];return(0,u.jsxs)(f.Z,{children:[(0,u.jsx)("html",{lang:a,dir:r}),(0,u.jsx)("title",{children:t}),(0,u.jsx)("meta",{property:"og:title",content:t}),(0,u.jsx)("meta",{name:"viewport",content:"width=device-width, initial-scale=1.0"}),n&&(0,u.jsx)("meta",{name:"robots",content:"noindex, nofollow"}),e&&(0,u.jsx)("link",{rel:"icon",href:s})]})}var G=n(44763),B=n(72389);function J(){const e=(0,B.Z)();return(0,u.jsx)(f.Z,{children:(0,u.jsx)("html",{"data-has-hydrated":e})})}function Q(){const e=(0,l.H)(c.Z),t=(0,d.TH)();return(0,u.jsx)(G.Z,{children:(0,u.jsx)(O.M,{children:(0,u.jsxs)(I.t,{children:[(0,u.jsxs)(h,{children:[(0,u.jsx)(V,{}),(0,u.jsx)(k,{}),(0,u.jsx)(z,{}),(0,u.jsx)(L,{location:S(t),children:e})]}),(0,u.jsx)(J,{})]})})})}var H=n(16887);const W=function(e){try{return document.createElement("link").relList.supports(e)}catch{return!1}}("prefetch")?function(e){return new Promise(((t,n)=>{if("undefined"==typeof document)return void n();const o=document.createElement("link");o.setAttribute("rel","prefetch"),o.setAttribute("href",e),o.onload=()=>t(),o.onerror=()=>n();const i=document.getElementsByTagName("head")[0]??document.getElementsByName("script")[0]?.parentNode;i?.appendChild(o)}))}:function(e){return new Promise(((t,n)=>{const o=new XMLHttpRequest;o.open("GET",e,!0),o.withCredentials=!0,o.onload=()=>{200===o.status?t():n()},o.send(null)}))};var K=n(99670);const $=new Set,Z=new Set,X=()=>navigator.connection?.effectiveType.includes("2g")||navigator.connection?.saveData,ee={prefetch(e){if(!(e=>!X()&&!Z.has(e)&&!$.has(e))(e))return!1;$.add(e);const t=(0,l.f)(c.Z,e).flatMap((e=>{return t=e.route.path,Object.entries(H).filter((e=>{let[n]=e;return n.replace(/-[^-]+$/,"")===t})).flatMap((e=>{let[,t]=e;return Object.values((0,K.Z)(t))}));var t}));return Promise.all(t.map((e=>{const t=n.gca(e);return t&&!t.includes("undefined")?W(t).catch((()=>{})):Promise.resolve()})))},preload:e=>!!(e=>!X()&&!Z.has(e))(e)&&(Z.add(e),Y(e))},te=Object.freeze(ee),ne=Boolean(!0);if(r.default.canUseDOM){window.docusaurus=te;const e=document.getElementById("__docusaurus"),t=(0,u.jsx)(a.B6,{children:(0,u.jsx)(s.VK,{children:(0,u.jsx)(Q,{})})}),n=(e,t)=>{console.error("Docusaurus React Root onRecoverableError:",e,t)},r=()=>{if(ne)o.startTransition((()=>{i.hydrateRoot(e,t,{onRecoverableError:n})}));else{const s=i.createRoot(e,{onRecoverableError:n});o.startTransition((()=>{s.render(t)}))}};Y(window.location.pathname).then(r)}},58940:(e,t,n)=>{"use strict";n.d(t,{_:()=>l,M:()=>u});var o=n(67294),i=n(36809);const s=JSON.parse('{"docusaurus-plugin-redoc":{"plugin-redoc-0":{"url":"redocusaurus/plugin-redoc-0.yaml","themeId":"theme-redoc","isSpecFile":true,"spec":{"openapi":"3.0.0","info":{"title":"Provenance Blockchain","description":"Provenance Blockchain Node Application","version":"1.13.0"},"paths":{"/cosmos/auth/v1beta1/accounts":{"get":{"summary":"Accounts returns all the existing accounts","description":"Since: cosmos-sdk 0.43","operationId":"Accounts","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"accounts":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"title":"accounts are the existing accounts"},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAccountsResponse is the response type for the Query/Accounts RPC method.\\n\\nSince: cosmos-sdk 0.43"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/auth/v1beta1/accounts/{address}":{"get":{"summary":"Account returns account details based on address.","operationId":"Account","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"account":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"description":"QueryAccountResponse is the response type for the Query/Account RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"address","description":"address defines the address to query for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/auth/v1beta1/address_by_id/{id}":{"get":{"summary":"AccountAddressByID returns account address based on account number.","description":"Since: cosmos-sdk 0.46.2","operationId":"AccountAddressByID","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"account_address":{"type":"string"}},"description":"Since: cosmos-sdk 0.46.2","title":"QueryAccountAddressByIDResponse is the response type for AccountAddressByID rpc method"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"id","description":"id is the account number of the address to be queried. This field\\nshould have been an uint64 (like all account numbers), and will be\\nupdated to uint64 in a future version of the auth query.","in":"path","required":true,"schema":{"type":"string","format":"int64"}}],"tags":["Query"]}},"/cosmos/auth/v1beta1/bech32":{"get":{"summary":"Bech32Prefix queries bech32Prefix","description":"Since: cosmos-sdk 0.46","operationId":"Bech32Prefix","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"bech32_prefix":{"type":"string"}},"description":"Bech32PrefixResponse is the response type for Bech32Prefix rpc method.\\n\\nSince: cosmos-sdk 0.46"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"tags":["Query"]}},"/cosmos/auth/v1beta1/bech32/{address_bytes}":{"get":{"summary":"AddressBytesToString converts Account Address bytes to string","description":"Since: cosmos-sdk 0.46","operationId":"AddressBytesToString","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"address_string":{"type":"string"}},"description":"AddressBytesToStringResponse is the response type for AddressString rpc method.\\n\\nSince: cosmos-sdk 0.46"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"address_bytes","in":"path","required":true,"schema":{"type":"string","format":"byte"}}],"tags":["Query"]}},"/cosmos/auth/v1beta1/bech32/{address_string}":{"get":{"summary":"AddressStringToBytes converts Address string to bytes","description":"Since: cosmos-sdk 0.46","operationId":"AddressStringToBytes","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"address_bytes":{"type":"string","format":"byte"}},"description":"AddressStringToBytesResponse is the response type for AddressBytes rpc method.\\n\\nSince: cosmos-sdk 0.46"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"address_string","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/auth/v1beta1/module_accounts":{"get":{"summary":"ModuleAccounts returns all the existing module accounts.","description":"Since: cosmos-sdk 0.46","operationId":"ModuleAccounts","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"accounts":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}},"description":"QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method.\\n\\nSince: cosmos-sdk 0.46"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"tags":["Query"]}},"/cosmos/auth/v1beta1/module_accounts/{name}":{"get":{"summary":"ModuleAccountByName returns the module account info by module name","operationId":"ModuleAccountByName","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"account":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"description":"QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"name","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/auth/v1beta1/params":{"get":{"summary":"Params queries all parameters.","operationId":"AuthParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"max_memo_characters":{"type":"string","format":"uint64"},"tx_sig_limit":{"type":"string","format":"uint64"},"tx_size_cost_per_byte":{"type":"string","format":"uint64"},"sig_verify_cost_ed25519":{"type":"string","format":"uint64"},"sig_verify_cost_secp256k1":{"type":"string","format":"uint64"}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"tags":["Query"]}},"/cosmos/bank/v1beta1/balances/{address}":{"get":{"summary":"AllBalances queries the balance of all coins for a single account.","operationId":"AllBalances","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"balances":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"balances is the balances of all the coins."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAllBalancesResponse is the response type for the Query/AllBalances RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"address","description":"address is the address to query balances for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/bank/v1beta1/balances/{address}/by_denom":{"get":{"summary":"Balance queries the balance of a single coin for a single account.","operationId":"Balance","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"balance":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"QueryBalanceResponse is the response type for the Query/Balance RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"address","description":"address is the address to query balances for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"denom","description":"denom is the coin denom to query balances for.","in":"query","required":false,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/bank/v1beta1/denom_owners/{denom}":{"get":{"summary":"DenomOwners queries for all account addresses that own a particular token\\ndenomination.","description":"Since: cosmos-sdk 0.46","operationId":"DenomOwners","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"denom_owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address defines the address that owns a particular denomination."},"balance":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"DenomOwner defines structure representing an account that owns or holds a\\nparticular denominated token. It contains the account address and account\\nbalance of the denominated token.\\n\\nSince: cosmos-sdk 0.46"}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.\\n\\nSince: cosmos-sdk 0.46"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"denom","description":"denom defines the coin denomination to query all account holders for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/bank/v1beta1/denoms_metadata":{"get":{"summary":"DenomsMetadata queries the client metadata for all registered coin\\ndenominations.","operationId":"DenomsMetadata","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"metadatas":{"type":"array","items":{"type":"object","properties":{"description":{"type":"string"},"denom_units":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string","description":"denom represents the string name of the given denom unit (e.g uatom)."},"exponent":{"type":"integer","format":"int64","description":"exponent represents power of 10 exponent that one must\\nraise the base_denom to in order to equal the given DenomUnit\'s denom\\n1 denom = 10^exponent base_denom\\n(e.g. with a base_denom of uatom, one can create a DenomUnit of \'atom\' with\\nexponent = 6, thus: 1 atom = 10^6 uatom)."},"aliases":{"type":"array","items":{"type":"string"},"title":"aliases is a list of string aliases for the given denom"}},"description":"DenomUnit represents a struct that describes a given\\ndenomination unit of the basic token."},"title":"denom_units represents the list of DenomUnit\'s for a given coin"},"base":{"type":"string","description":"base represents the base denom (should be the DenomUnit with exponent = 0)."},"display":{"type":"string","description":"display indicates the suggested denom that should be\\ndisplayed in clients."},"name":{"type":"string","description":"Since: cosmos-sdk 0.43","title":"name defines the name of the token (eg: Cosmos Atom)"},"symbol":{"type":"string","description":"symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\\nbe the same as the display.\\n\\nSince: cosmos-sdk 0.43"},"uri":{"type":"string","description":"URI to a document (on or off-chain) that contains additional information. Optional.\\n\\nSince: cosmos-sdk 0.46"},"uri_hash":{"type":"string","description":"URIHash is a sha256 hash of a document pointed by URI. It\'s used to verify that\\nthe document didn\'t change. Optional.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Metadata represents a struct that describes\\na basic token."},"description":"metadata provides the client information for all the registered tokens."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/bank/v1beta1/denoms_metadata/{denom}":{"get":{"summary":"DenomsMetadata queries the client metadata of a given coin denomination.","operationId":"DenomMetadata","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"metadata":{"type":"object","properties":{"description":{"type":"string"},"denom_units":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string","description":"denom represents the string name of the given denom unit (e.g uatom)."},"exponent":{"type":"integer","format":"int64","description":"exponent represents power of 10 exponent that one must\\nraise the base_denom to in order to equal the given DenomUnit\'s denom\\n1 denom = 10^exponent base_denom\\n(e.g. with a base_denom of uatom, one can create a DenomUnit of \'atom\' with\\nexponent = 6, thus: 1 atom = 10^6 uatom)."},"aliases":{"type":"array","items":{"type":"string"},"title":"aliases is a list of string aliases for the given denom"}},"description":"DenomUnit represents a struct that describes a given\\ndenomination unit of the basic token."},"title":"denom_units represents the list of DenomUnit\'s for a given coin"},"base":{"type":"string","description":"base represents the base denom (should be the DenomUnit with exponent = 0)."},"display":{"type":"string","description":"display indicates the suggested denom that should be\\ndisplayed in clients."},"name":{"type":"string","description":"Since: cosmos-sdk 0.43","title":"name defines the name of the token (eg: Cosmos Atom)"},"symbol":{"type":"string","description":"symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\\nbe the same as the display.\\n\\nSince: cosmos-sdk 0.43"},"uri":{"type":"string","description":"URI to a document (on or off-chain) that contains additional information. Optional.\\n\\nSince: cosmos-sdk 0.46"},"uri_hash":{"type":"string","description":"URIHash is a sha256 hash of a document pointed by URI. It\'s used to verify that\\nthe document didn\'t change. Optional.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Metadata represents a struct that describes\\na basic token."}},"description":"QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"denom","description":"denom is the coin denom to query the metadata for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/bank/v1beta1/params":{"get":{"summary":"Params queries the parameters of x/bank module.","operationId":"BankParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"type":"object","properties":{"send_enabled":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"enabled":{"type":"boolean"}},"description":"SendEnabled maps coin denom to a send_enabled status (whether a denom is\\nsendable)."},"description":"Deprecated: Use of SendEnabled in params is deprecated.\\nFor genesis, use the newly added send_enabled field in the genesis object.\\nStorage, lookup, and manipulation of this information is now in the keeper.\\n\\nAs of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files."},"default_send_enabled":{"type":"boolean"}},"description":"Params defines the parameters for the bank module."}},"description":"QueryParamsResponse defines the response type for querying x/bank parameters."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/cosmos/bank/v1beta1/send_enabled":{"get":{"summary":"SendEnabled queries for SendEnabled entries.","description":"This query only returns denominations that have specific SendEnabled settings.\\nAny denomination that does not have a specific setting will use the default\\nparams.default_send_enabled, and will not be returned by this query.\\n\\nSince: cosmos-sdk 0.47","operationId":"SendEnabled","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"send_enabled":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"enabled":{"type":"boolean"}},"description":"SendEnabled maps coin denom to a send_enabled status (whether a denom is\\nsendable)."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QuerySendEnabledResponse defines the RPC response of a SendEnable query.\\n\\nSince: cosmos-sdk 0.47"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"denoms","description":"denoms is the specific denoms you want look up. Leave empty to get all entries.","in":"query","required":false,"explode":true,"schema":{"type":"array","items":{"type":"string"}}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/bank/v1beta1/spendable_balances/{address}":{"get":{"summary":"SpendableBalances queries the spenable balance of all coins for a single\\naccount.","description":"Since: cosmos-sdk 0.46","operationId":"SpendableBalances","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"balances":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"balances is the spendable balances of all the coins."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QuerySpendableBalancesResponse defines the gRPC response structure for querying\\nan account\'s spendable balances.\\n\\nSince: cosmos-sdk 0.46"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"address","description":"address is the address to query spendable balances for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/bank/v1beta1/supply":{"get":{"summary":"TotalSupply queries the total supply of all coins.","operationId":"TotalSupply","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"supply":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"title":"supply is the supply of the coins"},"pagination":{"description":"pagination defines the pagination in the response.\\n\\nSince: cosmos-sdk 0.43","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"title":"QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC\\nmethod"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/bank/v1beta1/supply/by_denom":{"get":{"summary":"SupplyOf queries the supply of a single coin.","operationId":"SupplyOf","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"amount":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"denom","description":"denom is the coin denom to query balances for.","in":"query","required":false,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/base/tendermint/v1beta1/abci_query":{"get":{"summary":"ABCIQuery defines a query handler that supports ABCI queries directly to\\nthe application, bypassing Tendermint completely. The ABCI query must\\ncontain a valid and supported path, including app, custom, p2p, and store.","description":"Since: cosmos-sdk 0.46","operationId":"ABCIQuery","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"code":{"type":"integer","format":"int64"},"log":{"type":"string"},"info":{"type":"string"},"index":{"type":"string","format":"int64"},"key":{"type":"string","format":"byte"},"value":{"type":"string","format":"byte"},"proof_ops":{"type":"object","properties":{"ops":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"key":{"type":"string","format":"byte"},"data":{"type":"string","format":"byte"}},"description":"ProofOp defines an operation used for calculating Merkle root. The data could\\nbe arbitrary format, providing nessecary data for example neighbouring node\\nhash.\\n\\nNote: This type is a duplicate of the ProofOp proto type defined in\\nTendermint."}}},"description":"ProofOps is Merkle proof defined by the list of ProofOps.\\n\\nNote: This type is a duplicate of the ProofOps proto type defined in\\nTendermint."},"height":{"type":"string","format":"int64"},"codespace":{"type":"string"}},"description":"ABCIQueryResponse defines the response structure for the ABCIQuery gRPC\\nquery.\\n\\nNote: This type is a duplicate of the ResponseQuery proto type defined in\\nTendermint."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"data","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"path","in":"query","required":false,"schema":{"type":"string"}},{"name":"height","in":"query","required":false,"schema":{"type":"string","format":"int64"}},{"name":"prove","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Service"]}},"/cosmos/base/tendermint/v1beta1/blocks/latest":{"get":{"summary":"GetLatestBlock returns the latest block.","operationId":"GetLatestBlock","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"block":{"title":"Deprecated: please use `sdk_block` instead","type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"data":{"type":"object","properties":{"txs":{"type":"array","items":{"type":"string","format":"byte"},"description":"Txs that will be applied by state @ block.Height+1.\\nNOTE: not all txs here are valid.  We\'re just agreeing on the order first.\\nThis means that block.AppHash does not include these txs."}},"title":"Data contains the set of transactions included in the block"},"evidence":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}}}}},"last_commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"sdk_block":{"title":"Since: cosmos-sdk 0.47","type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","description":"proposer_address is the original block proposer address, formatted as a Bech32 string.\\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\\nfor better UX."}},"description":"Header defines the structure of a Tendermint block header."},"data":{"type":"object","properties":{"txs":{"type":"array","items":{"type":"string","format":"byte"},"description":"Txs that will be applied by state @ block.Height+1.\\nNOTE: not all txs here are valid.  We\'re just agreeing on the order first.\\nThis means that block.AppHash does not include these txs."}},"title":"Data contains the set of transactions included in the block"},"evidence":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}}}}},"last_commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}},"description":"Block is tendermint type Block, with the Header proposer address\\nfield converted to bech32 string."}},"description":"GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"tags":["Service"]}},"/cosmos/base/tendermint/v1beta1/blocks/{height}":{"get":{"summary":"GetBlockByHeight queries block for given height.","operationId":"GetBlockByHeight","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"block":{"title":"Deprecated: please use `sdk_block` instead","type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"data":{"type":"object","properties":{"txs":{"type":"array","items":{"type":"string","format":"byte"},"description":"Txs that will be applied by state @ block.Height+1.\\nNOTE: not all txs here are valid.  We\'re just agreeing on the order first.\\nThis means that block.AppHash does not include these txs."}},"title":"Data contains the set of transactions included in the block"},"evidence":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}}}}},"last_commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"sdk_block":{"title":"Since: cosmos-sdk 0.47","type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","description":"proposer_address is the original block proposer address, formatted as a Bech32 string.\\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\\nfor better UX."}},"description":"Header defines the structure of a Tendermint block header."},"data":{"type":"object","properties":{"txs":{"type":"array","items":{"type":"string","format":"byte"},"description":"Txs that will be applied by state @ block.Height+1.\\nNOTE: not all txs here are valid.  We\'re just agreeing on the order first.\\nThis means that block.AppHash does not include these txs."}},"title":"Data contains the set of transactions included in the block"},"evidence":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}}}}},"last_commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}},"description":"Block is tendermint type Block, with the Header proposer address\\nfield converted to bech32 string."}},"description":"GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight\\nRPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"height","in":"path","required":true,"schema":{"type":"string","format":"int64"}}],"tags":["Service"]}},"/cosmos/base/tendermint/v1beta1/node_info":{"get":{"summary":"GetNodeInfo queries the current node info.","operationId":"GetNodeInfo","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"default_node_info":{"type":"object","properties":{"protocol_version":{"type":"object","properties":{"p2p":{"type":"string","format":"uint64"},"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}}},"default_node_id":{"type":"string"},"listen_addr":{"type":"string"},"network":{"type":"string"},"version":{"type":"string"},"channels":{"type":"string","format":"byte"},"moniker":{"type":"string"},"other":{"type":"object","properties":{"tx_index":{"type":"string"},"rpc_address":{"type":"string"}}}}},"application_version":{"type":"object","properties":{"name":{"type":"string"},"app_name":{"type":"string"},"version":{"type":"string"},"git_commit":{"type":"string"},"build_tags":{"type":"string"},"go_version":{"type":"string"},"build_deps":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string","title":"module path"},"version":{"type":"string","title":"module version"},"sum":{"type":"string","title":"checksum"}},"title":"Module is the type for VersionInfo"}},"cosmos_sdk_version":{"type":"string","title":"Since: cosmos-sdk 0.43"}},"description":"VersionInfo is the type for the GetNodeInfoResponse message."}},"description":"GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"tags":["Service"]}},"/cosmos/base/tendermint/v1beta1/syncing":{"get":{"summary":"GetSyncing queries node syncing.","operationId":"GetSyncing","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"syncing":{"type":"boolean"}},"description":"GetSyncingResponse is the response type for the Query/GetSyncing RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"tags":["Service"]}},"/cosmos/base/tendermint/v1beta1/validatorsets/latest":{"get":{"summary":"GetLatestValidatorSet queries latest validator-set.","operationId":"GetLatestValidatorSet","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"block_height":{"type":"string","format":"int64"},"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string"},"pub_key":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}},"description":"Validator is the type for the validator-set."}},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"GetLatestValidatorSetResponse is the response type for the\\nQuery/GetValidatorSetByHeight RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Service"]}},"/cosmos/base/tendermint/v1beta1/validatorsets/{height}":{"get":{"summary":"GetValidatorSetByHeight queries validator-set at a given height.","operationId":"GetValidatorSetByHeight","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"block_height":{"type":"string","format":"int64"},"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string"},"pub_key":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}},"description":"Validator is the type for the validator-set."}},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"GetValidatorSetByHeightResponse is the response type for the\\nQuery/GetValidatorSetByHeight RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"height","in":"path","required":true,"schema":{"type":"string","format":"int64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Service"]}},"/cosmos/distribution/v1beta1/community_pool":{"get":{"summary":"CommunityPool queries the community pool coins.","operationId":"CommunityPool","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"pool":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."},"description":"pool defines community pool\'s coins."}},"description":"QueryCommunityPoolResponse is the response type for the Query/CommunityPool\\nRPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards":{"get":{"summary":"DelegationTotalRewards queries the total rewards accrued by a each\\nvalidator.","operationId":"DelegationTotalRewards","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"rewards":{"type":"array","items":{"type":"object","properties":{"validator_address":{"type":"string"},"reward":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."}}},"description":"DelegationDelegatorReward represents the properties\\nof a delegator\'s delegation reward."},"description":"rewards defines all the rewards accrued by a delegator."},"total":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."},"description":"total defines the sum of all the rewards."}},"description":"QueryDelegationTotalRewardsResponse is the response type for the\\nQuery/DelegationTotalRewards RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"delegator_address","description":"delegator_address defines the delegator address to query for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}":{"get":{"summary":"DelegationRewards queries the total rewards accrued by a delegation.","operationId":"DelegationRewards","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"rewards":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."},"description":"rewards defines the rewards accrued by a delegation."}},"description":"QueryDelegationRewardsResponse is the response type for the\\nQuery/DelegationRewards RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"delegator_address","description":"delegator_address defines the delegator address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"validator_address","description":"validator_address defines the validator address to query for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators":{"get":{"summary":"DelegatorValidators queries the validators of a delegator.","operationId":"DelegatorValidators","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"string"},"description":"validators defines the validators a delegator is delegating for."}},"description":"QueryDelegatorValidatorsResponse is the response type for the\\nQuery/DelegatorValidators RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"delegator_address","description":"delegator_address defines the delegator address to query for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address":{"get":{"summary":"DelegatorWithdrawAddress queries withdraw address of a delegator.","operationId":"DelegatorWithdrawAddress","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"withdraw_address":{"type":"string","description":"withdraw_address defines the delegator address to query for."}},"description":"QueryDelegatorWithdrawAddressResponse is the response type for the\\nQuery/DelegatorWithdrawAddress RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"delegator_address","description":"delegator_address defines the delegator address to query for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/distribution/v1beta1/params":{"get":{"summary":"Params queries params of the distribution module.","operationId":"DistributionParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"community_tax":{"type":"string"},"base_proposer_reward":{"type":"string"},"bonus_proposer_reward":{"type":"string"},"withdraw_addr_enabled":{"type":"boolean"}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/cosmos/distribution/v1beta1/validators/{validator_address}/commission":{"get":{"summary":"ValidatorCommission queries accumulated commission for a validator.","operationId":"ValidatorCommission","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"commission":{"description":"commission defines the commision the validator received.","type":"object","properties":{"commission":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."}}}}},"title":"QueryValidatorCommissionResponse is the response type for the\\nQuery/ValidatorCommission RPC method"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"validator_address","description":"validator_address defines the validator address to query for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards":{"get":{"summary":"ValidatorOutstandingRewards queries rewards of a validator address.","operationId":"ValidatorOutstandingRewards","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"rewards":{"type":"object","properties":{"rewards":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."}}},"description":"ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\\nfor a validator inexpensive to track, allows simple sanity checks."}},"description":"QueryValidatorOutstandingRewardsResponse is the response type for the\\nQuery/ValidatorOutstandingRewards RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"validator_address","description":"validator_address defines the validator address to query for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/distribution/v1beta1/validators/{validator_address}/slashes":{"get":{"summary":"ValidatorSlashes queries slash events of a validator.","operationId":"ValidatorSlashes","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"slashes":{"type":"array","items":{"type":"object","properties":{"validator_period":{"type":"string","format":"uint64"},"fraction":{"type":"string"}},"description":"ValidatorSlashEvent represents a validator slash event.\\nHeight is implicit within the store key.\\nThis is needed to calculate appropriate amount of staking tokens\\nfor delegations which are withdrawn after a slash has occurred."},"description":"slashes defines the slashes the validator received."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryValidatorSlashesResponse is the response type for the\\nQuery/ValidatorSlashes RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"validator_address","description":"validator_address defines the validator address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"starting_height","description":"starting_height defines the optional starting height to query the slashes.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"ending_height","description":"starting_height defines the optional ending height to query the slashes.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/evidence/v1beta1/evidence":{"get":{"summary":"AllEvidence queries all evidence.","operationId":"AllEvidence","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"evidence returns all evidences."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/evidence/v1beta1/evidence/{evidence_hash}":{"get":{"summary":"Evidence queries evidence based on evidence hash.","operationId":"Evidence","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"evidence":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"description":"QueryEvidenceResponse is the response type for the Query/Evidence RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"evidence_hash","description":"evidence_hash defines the hash of the requested evidence.","in":"path","required":true,"schema":{"type":"string","format":"byte"}}],"tags":["Query"]}},"/cosmos/gov/v1beta1/params/{params_type}":{"get":{"summary":"Params queries all parameters of the gov module.","operationId":"GovParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"voting_params":{"description":"voting_params defines the parameters related to voting.","type":"object","properties":{"voting_period":{"type":"string","description":"Length of the voting period."}}},"deposit_params":{"description":"deposit_params defines the parameters related to deposit.","type":"object","properties":{"min_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"Minimum deposit for a proposal to enter voting period."},"max_deposit_period":{"type":"string","description":"Maximum period for Atom holders to deposit on a proposal. Initial value: 2\\n months."}}},"tally_params":{"description":"tally_params defines the parameters related to tally.","type":"object","properties":{"quorum":{"type":"string","format":"byte","description":"Minimum percentage of total stake needed to vote for a result to be\\n considered valid."},"threshold":{"type":"string","format":"byte","description":"Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."},"veto_threshold":{"type":"string","format":"byte","description":"Minimum value of Veto votes to Total votes ratio for proposal to be\\n vetoed. Default value: 1/3."}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"params_type","description":"params_type defines which parameters to query for, can be one of \\"voting\\",\\n\\"tallying\\" or \\"deposit\\".","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/gov/v1beta1/proposals":{"get":{"summary":"Proposals queries all proposals based on given status.","operationId":"Proposals","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"proposals":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"content":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"status":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus enumerates the valid statuses of a proposal.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed."},"final_tally_result":{"description":"final_tally_result is the final tally result of the proposal. When\\nquerying a proposal via gRPC, this field is not populated until the\\nproposal\'s voting period has ended.","type":"object","properties":{"yes":{"type":"string"},"abstain":{"type":"string"},"no":{"type":"string"},"no_with_veto":{"type":"string"}}},"submit_time":{"type":"string","format":"date-time"},"deposit_end_time":{"type":"string","format":"date-time"},"total_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"voting_start_time":{"type":"string","format":"date-time"},"voting_end_time":{"type":"string","format":"date-time"}},"description":"Proposal defines the core field members of a governance proposal."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryProposalsResponse is the response type for the Query/Proposals RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_status","description":"proposal_status defines the status of the proposals.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed.","in":"query","required":false,"schema":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED"}},{"name":"voter","description":"voter defines the voter address for the proposals.","in":"query","required":false,"schema":{"type":"string"}},{"name":"depositor","description":"depositor defines the deposit addresses from the proposals.","in":"query","required":false,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/gov/v1beta1/proposals/{proposal_id}":{"get":{"summary":"Proposal queries proposal details based on ProposalID.","operationId":"Proposal","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"proposal":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"content":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"status":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus enumerates the valid statuses of a proposal.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed."},"final_tally_result":{"description":"final_tally_result is the final tally result of the proposal. When\\nquerying a proposal via gRPC, this field is not populated until the\\nproposal\'s voting period has ended.","type":"object","properties":{"yes":{"type":"string"},"abstain":{"type":"string"},"no":{"type":"string"},"no_with_veto":{"type":"string"}}},"submit_time":{"type":"string","format":"date-time"},"deposit_end_time":{"type":"string","format":"date-time"},"total_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"voting_start_time":{"type":"string","format":"date-time"},"voting_end_time":{"type":"string","format":"date-time"}},"description":"Proposal defines the core field members of a governance proposal."}},"description":"QueryProposalResponse is the response type for the Query/Proposal RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id defines the unique id of the proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}}],"tags":["Query"]}},"/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits":{"get":{"summary":"Deposits queries all deposits of a single proposal.","operationId":"Deposits","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"deposits":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"depositor":{"type":"string"},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}}},"description":"Deposit defines an amount deposited by an account address to an active\\nproposal."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryDepositsResponse is the response type for the Query/Deposits RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id defines the unique id of the proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}":{"get":{"summary":"Deposit queries single deposit information based proposalID, depositAddr.","operationId":"Deposit","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"deposit":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"depositor":{"type":"string"},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}}},"description":"Deposit defines an amount deposited by an account address to an active\\nproposal."}},"description":"QueryDepositResponse is the response type for the Query/Deposit RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id defines the unique id of the proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"depositor","description":"depositor defines the deposit addresses from the proposals.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/gov/v1beta1/proposals/{proposal_id}/tally":{"get":{"summary":"TallyResult queries the tally of a proposal vote.","operationId":"TallyResult","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"tally":{"description":"tally defines the requested tally.","type":"object","properties":{"yes":{"type":"string"},"abstain":{"type":"string"},"no":{"type":"string"},"no_with_veto":{"type":"string"}}}},"description":"QueryTallyResultResponse is the response type for the Query/Tally RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id defines the unique id of the proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}}],"tags":["Query"]}},"/cosmos/gov/v1beta1/proposals/{proposal_id}/votes":{"get":{"summary":"Votes queries votes of a given proposal.","operationId":"Votes","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"votes":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"voter":{"type":"string"},"option":{"description":"Deprecated: Prefer to use `options` instead. This field is set in queries\\nif and only if `len(options) == 1` and that option has weight 1. In all\\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.","type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED"},"options":{"type":"array","items":{"type":"object","properties":{"option":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"weight":{"type":"string"}},"description":"WeightedVoteOption defines a unit of vote for vote split.\\n\\nSince: cosmos-sdk 0.43"},"title":"Since: cosmos-sdk 0.43"}},"description":"Vote defines a vote on a governance proposal.\\nA Vote consists of a proposal ID, the voter, and the vote option."},"description":"votes defined the queried votes."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryVotesResponse is the response type for the Query/Votes RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id defines the unique id of the proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}":{"get":{"summary":"Vote queries voted information based on proposalID, voterAddr.","operationId":"Vote","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"vote":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"voter":{"type":"string"},"option":{"description":"Deprecated: Prefer to use `options` instead. This field is set in queries\\nif and only if `len(options) == 1` and that option has weight 1. In all\\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.","type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED"},"options":{"type":"array","items":{"type":"object","properties":{"option":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"weight":{"type":"string"}},"description":"WeightedVoteOption defines a unit of vote for vote split.\\n\\nSince: cosmos-sdk 0.43"},"title":"Since: cosmos-sdk 0.43"}},"description":"Vote defines a vote on a governance proposal.\\nA Vote consists of a proposal ID, the voter, and the vote option."}},"description":"QueryVoteResponse is the response type for the Query/Vote RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id defines the unique id of the proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"voter","description":"voter defines the voter address for the proposals.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/gov/v1/params/{params_type}":{"get":{"summary":"Params queries all parameters of the gov module.","operationId":"GovV1Params","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"voting_params":{"description":"voting_params defines the parameters related to voting.","type":"object","properties":{"voting_period":{"type":"string","description":"Length of the voting period."}}},"deposit_params":{"description":"deposit_params defines the parameters related to deposit.","type":"object","properties":{"min_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"Minimum deposit for a proposal to enter voting period."},"max_deposit_period":{"type":"string","description":"Maximum period for Atom holders to deposit on a proposal. Initial value: 2\\n months."}}},"tally_params":{"description":"tally_params defines the parameters related to tally.","type":"object","properties":{"quorum":{"type":"string","description":"Minimum percentage of total stake needed to vote for a result to be\\n considered valid."},"threshold":{"type":"string","description":"Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."},"veto_threshold":{"type":"string","description":"Minimum value of Veto votes to Total votes ratio for proposal to be\\n vetoed. Default value: 1/3."}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"params_type","description":"params_type defines which parameters to query for, can be one of \\"voting\\",\\n\\"tallying\\" or \\"deposit\\".","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/gov/v1/proposals":{"get":{"summary":"Proposals queries all proposals based on given status.","operationId":"GovV1Proposal","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"proposals":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64"},"messages":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"status":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus enumerates the valid statuses of a proposal.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed."},"final_tally_result":{"description":"final_tally_result is the final tally result of the proposal. When\\nquerying a proposal via gRPC, this field is not populated until the\\nproposal\'s voting period has ended.","type":"object","properties":{"yes_count":{"type":"string"},"abstain_count":{"type":"string"},"no_count":{"type":"string"},"no_with_veto_count":{"type":"string"}}},"submit_time":{"type":"string","format":"date-time"},"deposit_end_time":{"type":"string","format":"date-time"},"total_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"voting_start_time":{"type":"string","format":"date-time"},"voting_end_time":{"type":"string","format":"date-time"},"metadata":{"type":"string","description":"metadata is any arbitrary metadata attached to the proposal."}},"description":"Proposal defines the core field members of a governance proposal."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryProposalsResponse is the response type for the Query/Proposals RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_status","description":"proposal_status defines the status of the proposals.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed.","in":"query","required":false,"schema":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED"}},{"name":"voter","description":"voter defines the voter address for the proposals.","in":"query","required":false,"schema":{"type":"string"}},{"name":"depositor","description":"depositor defines the deposit addresses from the proposals.","in":"query","required":false,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/gov/v1/proposals/{proposal_id}":{"get":{"summary":"Proposal queries proposal details based on ProposalID.","operationId":"GovV1Proposal","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"proposal":{"type":"object","properties":{"id":{"type":"string","format":"uint64"},"messages":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"status":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus enumerates the valid statuses of a proposal.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed."},"final_tally_result":{"description":"final_tally_result is the final tally result of the proposal. When\\nquerying a proposal via gRPC, this field is not populated until the\\nproposal\'s voting period has ended.","type":"object","properties":{"yes_count":{"type":"string"},"abstain_count":{"type":"string"},"no_count":{"type":"string"},"no_with_veto_count":{"type":"string"}}},"submit_time":{"type":"string","format":"date-time"},"deposit_end_time":{"type":"string","format":"date-time"},"total_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"voting_start_time":{"type":"string","format":"date-time"},"voting_end_time":{"type":"string","format":"date-time"},"metadata":{"type":"string","description":"metadata is any arbitrary metadata attached to the proposal."}},"description":"Proposal defines the core field members of a governance proposal."}},"description":"QueryProposalResponse is the response type for the Query/Proposal RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id defines the unique id of the proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}}],"tags":["Query"]}},"/cosmos/gov/v1/proposals/{proposal_id}/deposits":{"get":{"summary":"Deposits queries all deposits of a single proposal.","operationId":"GovV1Deposit","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"deposits":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"depositor":{"type":"string"},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}}},"description":"Deposit defines an amount deposited by an account address to an active\\nproposal."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryDepositsResponse is the response type for the Query/Deposits RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id defines the unique id of the proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/gov/v1/proposals/{proposal_id}/deposits/{depositor}":{"get":{"summary":"Deposit queries single deposit information based proposalID, depositAddr.","operationId":"GovV1Deposit","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"deposit":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"depositor":{"type":"string"},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}}},"description":"Deposit defines an amount deposited by an account address to an active\\nproposal."}},"description":"QueryDepositResponse is the response type for the Query/Deposit RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id defines the unique id of the proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"depositor","description":"depositor defines the deposit addresses from the proposals.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/gov/v1/proposals/{proposal_id}/tally":{"get":{"summary":"TallyResult queries the tally of a proposal vote.","operationId":"GovV1TallyResult","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"tally":{"description":"tally defines the requested tally.","type":"object","properties":{"yes_count":{"type":"string"},"abstain_count":{"type":"string"},"no_count":{"type":"string"},"no_with_veto_count":{"type":"string"}}}},"description":"QueryTallyResultResponse is the response type for the Query/Tally RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id defines the unique id of the proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}}],"tags":["Query"]}},"/cosmos/gov/v1/proposals/{proposal_id}/votes":{"get":{"summary":"Votes queries votes of a given proposal.","operationId":"GovV1Votes","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"votes":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"voter":{"type":"string"},"options":{"type":"array","items":{"type":"object","properties":{"option":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"weight":{"type":"string"}},"description":"WeightedVoteOption defines a unit of vote for vote split."}},"metadata":{"type":"string","description":"metadata is any  arbitrary metadata to attached to the vote."}},"description":"Vote defines a vote on a governance proposal.\\nA Vote consists of a proposal ID, the voter, and the vote option."},"description":"votes defined the queried votes."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryVotesResponse is the response type for the Query/Votes RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id defines the unique id of the proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/gov/v1/proposals/{proposal_id}/votes/{voter}":{"get":{"summary":"Vote queries voted information based on proposalID, voterAddr.","operationId":"GovV1Vote","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"vote":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"voter":{"type":"string"},"options":{"type":"array","items":{"type":"object","properties":{"option":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"weight":{"type":"string"}},"description":"WeightedVoteOption defines a unit of vote for vote split."}},"metadata":{"type":"string","description":"metadata is any  arbitrary metadata to attached to the vote."}},"description":"Vote defines a vote on a governance proposal.\\nA Vote consists of a proposal ID, the voter, and the vote option."}},"description":"QueryVoteResponse is the response type for the Query/Vote RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id defines the unique id of the proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"voter","description":"voter defines the voter address for the proposals.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/mint/v1beta1/annual_provisions":{"get":{"summary":"AnnualProvisions current minting annual provisions value.","operationId":"AnnualProvisions","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"annual_provisions":{"type":"string","format":"byte","description":"annual_provisions is the current minting annual provisions value."}},"description":"QueryAnnualProvisionsResponse is the response type for the\\nQuery/AnnualProvisions RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/cosmos/mint/v1beta1/inflation":{"get":{"summary":"Inflation returns the current minting inflation value.","operationId":"Inflation","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"inflation":{"type":"string","format":"byte","description":"inflation is the current minting inflation value."}},"description":"QueryInflationResponse is the response type for the Query/Inflation RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/cosmos/mint/v1beta1/params":{"get":{"summary":"Params returns the total set of minting parameters.","operationId":"MintParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"mint_denom":{"type":"string","title":"type of coin to mint"},"inflation_rate_change":{"type":"string","title":"maximum annual change in inflation rate"},"inflation_max":{"type":"string","title":"maximum inflation rate"},"inflation_min":{"type":"string","title":"minimum inflation rate"},"goal_bonded":{"type":"string","title":"goal of percent bonded atoms"},"blocks_per_year":{"type":"string","format":"uint64","title":"expected blocks per year"}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/cosmos/params/v1beta1/params":{"get":{"summary":"Params queries a specific parameter of a module, given its subspace and\\nkey.","operationId":"Params","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"param":{"description":"param defines the queried parameter.","type":"object","properties":{"subspace":{"type":"string"},"key":{"type":"string"},"value":{"type":"string"}}}},"description":"QueryParamsResponse is response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"subspace","description":"subspace defines the module to query the parameter for.","in":"query","required":false,"schema":{"type":"string"}},{"name":"key","description":"key defines the key of the parameter in the subspace.","in":"query","required":false,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/params/v1beta1/subspaces":{"get":{"summary":"Subspaces queries for all registered subspaces and all keys for a subspace.","description":"Since: cosmos-sdk 0.46","operationId":"Subspaces","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"subspaces":{"type":"array","items":{"type":"object","properties":{"subspace":{"type":"string"},"keys":{"type":"array","items":{"type":"string"}}},"description":"Subspace defines a parameter subspace name and all the keys that exist for\\nthe subspace.\\n\\nSince: cosmos-sdk 0.46"}}},"description":"QuerySubspacesResponse defines the response types for querying for all\\nregistered subspaces and all keys for a subspace.\\n\\nSince: cosmos-sdk 0.46"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/cosmos/quarantine/v1beta1/active/{to_address}":{"get":{"summary":"IsQuarantined checks if an account has opted into quarantine.","operationId":"IsQuarantined","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"is_quarantined":{"type":"boolean","description":"is_quarantined is true if the to_address has opted into quarantine."}},"description":"QueryIsQuarantinedResponse defines the RPC response of an IsQuarantined query."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"to_address","description":"to_address is the address to check.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/quarantine/v1beta1/auto/{to_address}":{"get":{"summary":"AutoResponses gets the auto-response settings for a quarantined account.","description":"The to_address is required. If a from_address is provided only the auto response for that from_address will be\\nreturned. If no from_address is provided, all auto-response settings for the given to_address will be returned.","operationId":"AutoResponses","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"auto_responses":{"type":"array","items":{"type":"object","properties":{"to_address":{"type":"string","description":"to_address is the receiving address."},"from_address":{"type":"string","description":"from_address is the sending address."},"response":{"description":"response is the auto-response setting for these two addresses.","type":"string","enum":["AUTO_RESPONSE_UNSPECIFIED","AUTO_RESPONSE_ACCEPT","AUTO_RESPONSE_DECLINE"],"default":"AUTO_RESPONSE_UNSPECIFIED"}},"description":"AutoResponseEntry defines the auto response to one address from another."},"description":"auto_responses are the auto-response entries from the provided query."},"pagination":{"description":"pagination defines the pagination parameters of the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAutoResponsesResponse defines the RPC response of a AutoResponses query."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"to_address","description":"to_address is the quarantined account to get info on.","in":"path","required":true,"schema":{"type":"string"}},{"name":"from_address","description":"from_address is an optional sender address to limit results.","in":"query","required":false,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/quarantine/v1beta1/auto/{to_address}/{from_address}":{"get":{"summary":"AutoResponses gets the auto-response settings for a quarantined account.","description":"The to_address is required. If a from_address is provided only the auto response for that from_address will be\\nreturned. If no from_address is provided, all auto-response settings for the given to_address will be returned.","operationId":"AutoResponses2","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"auto_responses":{"type":"array","items":{"type":"object","properties":{"to_address":{"type":"string","description":"to_address is the receiving address."},"from_address":{"type":"string","description":"from_address is the sending address."},"response":{"description":"response is the auto-response setting for these two addresses.","type":"string","enum":["AUTO_RESPONSE_UNSPECIFIED","AUTO_RESPONSE_ACCEPT","AUTO_RESPONSE_DECLINE"],"default":"AUTO_RESPONSE_UNSPECIFIED"}},"description":"AutoResponseEntry defines the auto response to one address from another."},"description":"auto_responses are the auto-response entries from the provided query."},"pagination":{"description":"pagination defines the pagination parameters of the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAutoResponsesResponse defines the RPC response of a AutoResponses query."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"to_address","description":"to_address is the quarantined account to get info on.","in":"path","required":true,"schema":{"type":"string"}},{"name":"from_address","description":"from_address is an optional sender address to limit results.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/quarantine/v1beta1/funds":{"get":{"summary":"QuarantinedFunds gets information about funds that have been quarantined.","description":"If both a to_address and from_address are provided, any such quarantined funds will be returned regardless of\\nwhether they\'ve been declined. If only a to_address is provided, the unaccepted and undeclined funds waiting on a\\nresponse from to_address will be returned. If neither a to_address nor from_address is provided, all non-declined\\nquarantined funds for any address will be returned. The request is invalid if only a from_address is provided.","operationId":"QuarantinedFunds","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"quarantinedFunds":{"type":"array","items":{"type":"object","properties":{"to_address":{"type":"string","description":"to_address is the intended recipient of the coins that have been quarantined."},"unaccepted_from_addresses":{"type":"array","items":{"type":"string"},"description":"unaccepted_from_addresses are the senders that have not been part of an accept yet for these coins."},"coins":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"coins is the amount currently in quarantined for the two addresses."},"declined":{"type":"boolean","description":"declined is true if these funds were previously declined."}},"description":"QuarantinedFunds defines structure that represents coins that have been quarantined."},"description":"quarantinedFunds is info about coins sitting in quarantine."},"pagination":{"description":"pagination defines the pagination parameters of the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryQuarantinedFundsResponse defines the RPC response of a QuarantinedFunds query."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"to_address","description":"to_address is the intended recipient of the coins that have been quarantined.","in":"query","required":false,"schema":{"type":"string"}},{"name":"from_address","description":"from_address is the sender of the coins. If provided, a to_address must also be provided.","in":"query","required":false,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/quarantine/v1beta1/funds/{to_address}":{"get":{"summary":"QuarantinedFunds gets information about funds that have been quarantined.","description":"If both a to_address and from_address are provided, any such quarantined funds will be returned regardless of\\nwhether they\'ve been declined. If only a to_address is provided, the unaccepted and undeclined funds waiting on a\\nresponse from to_address will be returned. If neither a to_address nor from_address is provided, all non-declined\\nquarantined funds for any address will be returned. The request is invalid if only a from_address is provided.","operationId":"QuarantinedFunds2","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"quarantinedFunds":{"type":"array","items":{"type":"object","properties":{"to_address":{"type":"string","description":"to_address is the intended recipient of the coins that have been quarantined."},"unaccepted_from_addresses":{"type":"array","items":{"type":"string"},"description":"unaccepted_from_addresses are the senders that have not been part of an accept yet for these coins."},"coins":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"coins is the amount currently in quarantined for the two addresses."},"declined":{"type":"boolean","description":"declined is true if these funds were previously declined."}},"description":"QuarantinedFunds defines structure that represents coins that have been quarantined."},"description":"quarantinedFunds is info about coins sitting in quarantine."},"pagination":{"description":"pagination defines the pagination parameters of the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryQuarantinedFundsResponse defines the RPC response of a QuarantinedFunds query."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"to_address","description":"to_address is the intended recipient of the coins that have been quarantined.","in":"path","required":true,"schema":{"type":"string"}},{"name":"from_address","description":"from_address is the sender of the coins. If provided, a to_address must also be provided.","in":"query","required":false,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/quarantine/v1beta1/funds/{to_address}/{from_address}":{"get":{"summary":"QuarantinedFunds gets information about funds that have been quarantined.","description":"If both a to_address and from_address are provided, any such quarantined funds will be returned regardless of\\nwhether they\'ve been declined. If only a to_address is provided, the unaccepted and undeclined funds waiting on a\\nresponse from to_address will be returned. If neither a to_address nor from_address is provided, all non-declined\\nquarantined funds for any address will be returned. The request is invalid if only a from_address is provided.","operationId":"QuarantinedFunds3","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"quarantinedFunds":{"type":"array","items":{"type":"object","properties":{"to_address":{"type":"string","description":"to_address is the intended recipient of the coins that have been quarantined."},"unaccepted_from_addresses":{"type":"array","items":{"type":"string"},"description":"unaccepted_from_addresses are the senders that have not been part of an accept yet for these coins."},"coins":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"coins is the amount currently in quarantined for the two addresses."},"declined":{"type":"boolean","description":"declined is true if these funds were previously declined."}},"description":"QuarantinedFunds defines structure that represents coins that have been quarantined."},"description":"quarantinedFunds is info about coins sitting in quarantine."},"pagination":{"description":"pagination defines the pagination parameters of the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryQuarantinedFundsResponse defines the RPC response of a QuarantinedFunds query."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"to_address","description":"to_address is the intended recipient of the coins that have been quarantined.","in":"path","required":true,"schema":{"type":"string"}},{"name":"from_address","description":"from_address is the sender of the coins. If provided, a to_address must also be provided.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/slashing/v1beta1/params":{"get":{"summary":"Params queries the parameters of slashing module","operationId":"SlashingParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"type":"object","properties":{"signed_blocks_window":{"type":"string","format":"int64"},"min_signed_per_window":{"type":"string","format":"byte"},"downtime_jail_duration":{"type":"string"},"slash_fraction_double_sign":{"type":"string","format":"byte"},"slash_fraction_downtime":{"type":"string","format":"byte"}},"description":"Params represents the parameters used for by the slashing module."}},"title":"QueryParamsResponse is the response type for the Query/Params RPC method"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/cosmos/slashing/v1beta1/signing_infos":{"get":{"summary":"SigningInfos queries signing info of all validators","operationId":"SigningInfos","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"info":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string"},"start_height":{"type":"string","format":"int64","title":"Height at which validator was first a candidate OR was unjailed"},"index_offset":{"type":"string","format":"int64","description":"Index which is incremented each time the validator was a bonded\\nin a block and may have signed a precommit or not. This in conjunction with the\\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."},"jailed_until":{"type":"string","format":"date-time","description":"Timestamp until which the validator is jailed due to liveness downtime."},"tombstoned":{"type":"boolean","description":"Whether or not a validator has been tombstoned (killed out of validator set). It is set\\nonce the validator commits an equivocation or for any other configured misbehiavor."},"missed_blocks_counter":{"type":"string","format":"int64","description":"A counter kept to avoid unnecessary array reads.\\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."}},"description":"ValidatorSigningInfo defines a validator\'s signing info for monitoring their\\nliveness activity."},"title":"info is the signing info of all validators"},"pagination":{"type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}},"description":"PageResponse is to be embedded in gRPC response messages where the\\ncorresponding request message has used PageRequest.\\n\\n message SomeResponse {\\n         repeated Bar results = 1;\\n         PageResponse page = 2;\\n }"}},"title":"QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC\\nmethod"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/slashing/v1beta1/signing_infos/{cons_address}":{"get":{"summary":"SigningInfo queries the signing info of given cons address","operationId":"SigningInfo","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"val_signing_info":{"type":"object","properties":{"address":{"type":"string"},"start_height":{"type":"string","format":"int64","title":"Height at which validator was first a candidate OR was unjailed"},"index_offset":{"type":"string","format":"int64","description":"Index which is incremented each time the validator was a bonded\\nin a block and may have signed a precommit or not. This in conjunction with the\\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."},"jailed_until":{"type":"string","format":"date-time","description":"Timestamp until which the validator is jailed due to liveness downtime."},"tombstoned":{"type":"boolean","description":"Whether or not a validator has been tombstoned (killed out of validator set). It is set\\nonce the validator commits an equivocation or for any other configured misbehiavor."},"missed_blocks_counter":{"type":"string","format":"int64","description":"A counter kept to avoid unnecessary array reads.\\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."}},"description":"ValidatorSigningInfo defines a validator\'s signing info for monitoring their\\nliveness activity.","title":"val_signing_info is the signing info of requested val cons address"}},"title":"QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC\\nmethod"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"cons_address","description":"cons_address is the address to query signing info of","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/staking/v1beta1/delegations/{delegator_addr}":{"get":{"summary":"DelegatorDelegations queries all delegations of a given delegator address.","operationId":"DelegatorDelegations","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"delegation_responses":{"type":"array","items":{"type":"object","properties":{"delegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"shares":{"type":"string","description":"shares define the delegation shares received."}},"description":"Delegation represents the bond with tokens held by an account. It is\\nowned by one delegator, and is associated with the voting power of one\\nvalidator."},"balance":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"DelegationResponse is equivalent to Delegation except that it contains a\\nbalance in addition to shares which is more suitable for client responses."},"description":"delegation_responses defines all the delegations\' info of a delegator."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryDelegatorDelegationsResponse is response type for the\\nQuery/DelegatorDelegations RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"delegator_addr","description":"delegator_addr defines the delegator address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations":{"get":{"summary":"Redelegations queries redelegations of given address.","operationId":"Redelegations","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"redelegation_responses":{"type":"array","items":{"type":"object","properties":{"redelegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_src_address":{"type":"string","description":"validator_src_address is the validator redelegation source operator address."},"validator_dst_address":{"type":"string","description":"validator_dst_address is the validator redelegation destination operator address."},"entries":{"type":"array","items":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height  defines the height which the redelegation took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time defines the unix time for redelegation completion."},"initial_balance":{"type":"string","description":"initial_balance defines the initial balance when redelegation started."},"shares_dst":{"type":"string","description":"shares_dst is the amount of destination-validator shares created by redelegation."}},"description":"RedelegationEntry defines a redelegation object with relevant metadata."},"description":"entries are the redelegation entries."}},"description":"Redelegation contains the list of a particular delegator\'s redelegating bonds\\nfrom a particular source validator to a particular destination validator."},"entries":{"type":"array","items":{"type":"object","properties":{"redelegation_entry":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height  defines the height which the redelegation took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time defines the unix time for redelegation completion."},"initial_balance":{"type":"string","description":"initial_balance defines the initial balance when redelegation started."},"shares_dst":{"type":"string","description":"shares_dst is the amount of destination-validator shares created by redelegation."}},"description":"RedelegationEntry defines a redelegation object with relevant metadata."},"balance":{"type":"string"}},"description":"RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\\ncontains a balance in addition to shares which is more suitable for client\\nresponses."}}},"description":"RedelegationResponse is equivalent to a Redelegation except that its entries\\ncontain a balance in addition to shares which is more suitable for client\\nresponses."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryRedelegationsResponse is response type for the Query/Redelegations RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"delegator_addr","description":"delegator_addr defines the delegator address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"src_validator_addr","description":"src_validator_addr defines the validator address to redelegate from.","in":"query","required":false,"schema":{"type":"string"}},{"name":"dst_validator_addr","description":"dst_validator_addr defines the validator address to redelegate to.","in":"query","required":false,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations":{"get":{"summary":"DelegatorUnbondingDelegations queries all unbonding delegations of a given\\ndelegator address.","operationId":"DelegatorUnbondingDelegations","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"unbonding_responses":{"type":"array","items":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"entries":{"type":"array","items":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height is the height which the unbonding took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time is the unix time for unbonding completion."},"initial_balance":{"type":"string","description":"initial_balance defines the tokens initially scheduled to receive at completion."},"balance":{"type":"string","description":"balance defines the tokens to receive at completion."}},"description":"UnbondingDelegationEntry defines an unbonding object with relevant metadata."},"description":"entries are the unbonding delegation entries."}},"description":"UnbondingDelegation stores all of a single delegator\'s unbonding bonds\\nfor a single validator in an time-ordered list."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryUnbondingDelegatorDelegationsResponse is response type for the\\nQuery/UnbondingDelegatorDelegations RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"delegator_addr","description":"delegator_addr defines the delegator address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators":{"get":{"summary":"DelegatorValidators queries all validators info for given delegator\\naddress.","operationId":"StakingDelegatorValidators","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"operator_address":{"type":"string","description":"operator_address defines the address of the validator\'s operator; bech encoded in JSON."},"consensus_pubkey":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"jailed":{"type":"boolean","description":"jailed defined whether the validator has been jailed from bonded status or not."},"status":{"description":"status is the validator status (bonded/unbonding/unbonded).","type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED"},"tokens":{"type":"string","description":"tokens define the delegated tokens (incl. self-delegation)."},"delegator_shares":{"type":"string","description":"delegator_shares defines total shares issued to a validator\'s delegators."},"description":{"description":"description defines the description terms for the validator.","type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}}},"unbonding_height":{"type":"string","format":"int64","description":"unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."},"unbonding_time":{"type":"string","format":"date-time","description":"unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."},"commission":{"description":"commission defines the commission parameters.","type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}}},"min_self_delegation":{"type":"string","description":"min_self_delegation is the validator\'s self declared minimum self delegation.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Validator defines a validator, together with the total amount of the\\nValidator\'s bond shares and their exchange rate to coins. Slashing results in\\na decrease in the exchange rate, allowing correct calculation of future\\nundelegations without iterating over delegators. When coins are delegated to\\nthis validator, the validator is credited with a delegation whose number of\\nbond shares is based on the amount of coins delegated divided by the current\\nexchange rate. Voting power can be calculated as total bonded shares\\nmultiplied by exchange rate."},"description":"validators defines the validators\' info of a delegator."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryDelegatorValidatorsResponse is response type for the\\nQuery/DelegatorValidators RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"delegator_addr","description":"delegator_addr defines the delegator address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}":{"get":{"summary":"DelegatorValidator queries validator info for given delegator validator\\npair.","operationId":"DelegatorValidator","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"validator":{"type":"object","properties":{"operator_address":{"type":"string","description":"operator_address defines the address of the validator\'s operator; bech encoded in JSON."},"consensus_pubkey":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"jailed":{"type":"boolean","description":"jailed defined whether the validator has been jailed from bonded status or not."},"status":{"description":"status is the validator status (bonded/unbonding/unbonded).","type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED"},"tokens":{"type":"string","description":"tokens define the delegated tokens (incl. self-delegation)."},"delegator_shares":{"type":"string","description":"delegator_shares defines total shares issued to a validator\'s delegators."},"description":{"description":"description defines the description terms for the validator.","type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}}},"unbonding_height":{"type":"string","format":"int64","description":"unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."},"unbonding_time":{"type":"string","format":"date-time","description":"unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."},"commission":{"description":"commission defines the commission parameters.","type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}}},"min_self_delegation":{"type":"string","description":"min_self_delegation is the validator\'s self declared minimum self delegation.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Validator defines a validator, together with the total amount of the\\nValidator\'s bond shares and their exchange rate to coins. Slashing results in\\na decrease in the exchange rate, allowing correct calculation of future\\nundelegations without iterating over delegators. When coins are delegated to\\nthis validator, the validator is credited with a delegation whose number of\\nbond shares is based on the amount of coins delegated divided by the current\\nexchange rate. Voting power can be calculated as total bonded shares\\nmultiplied by exchange rate."}},"description":"QueryDelegatorValidatorResponse response type for the\\nQuery/DelegatorValidator RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"delegator_addr","description":"delegator_addr defines the delegator address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"validator_addr","description":"validator_addr defines the validator address to query for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/staking/v1beta1/historical_info/{height}":{"get":{"summary":"HistoricalInfo queries the historical info for given height.","operationId":"HistoricalInfo","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"hist":{"description":"hist defines the historical info at the given height.","type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"title":"prev block info","type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}}},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"valset":{"type":"array","items":{"type":"object","properties":{"operator_address":{"type":"string","description":"operator_address defines the address of the validator\'s operator; bech encoded in JSON."},"consensus_pubkey":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"jailed":{"type":"boolean","description":"jailed defined whether the validator has been jailed from bonded status or not."},"status":{"description":"status is the validator status (bonded/unbonding/unbonded).","type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED"},"tokens":{"type":"string","description":"tokens define the delegated tokens (incl. self-delegation)."},"delegator_shares":{"type":"string","description":"delegator_shares defines total shares issued to a validator\'s delegators."},"description":{"description":"description defines the description terms for the validator.","type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}}},"unbonding_height":{"type":"string","format":"int64","description":"unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."},"unbonding_time":{"type":"string","format":"date-time","description":"unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."},"commission":{"description":"commission defines the commission parameters.","type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}}},"min_self_delegation":{"type":"string","description":"min_self_delegation is the validator\'s self declared minimum self delegation.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Validator defines a validator, together with the total amount of the\\nValidator\'s bond shares and their exchange rate to coins. Slashing results in\\na decrease in the exchange rate, allowing correct calculation of future\\nundelegations without iterating over delegators. When coins are delegated to\\nthis validator, the validator is credited with a delegation whose number of\\nbond shares is based on the amount of coins delegated divided by the current\\nexchange rate. Voting power can be calculated as total bonded shares\\nmultiplied by exchange rate."}}}}},"description":"QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"height","description":"height defines at which height to query the historical info.","in":"path","required":true,"schema":{"type":"string","format":"int64"}}],"tags":["Query"]}},"/cosmos/staking/v1beta1/params":{"get":{"summary":"Parameters queries the staking parameters.","operationId":"StakingParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","type":"object","properties":{"unbonding_time":{"type":"string","description":"unbonding_time is the time duration of unbonding."},"max_validators":{"type":"integer","format":"int64","description":"max_validators is the maximum number of validators."},"max_entries":{"type":"integer","format":"int64","description":"max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio)."},"historical_entries":{"type":"integer","format":"int64","description":"historical_entries is the number of historical entries to persist."},"bond_denom":{"type":"string","description":"bond_denom defines the bondable coin denomination."},"min_commission_rate":{"type":"string","title":"min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators"}}}},"description":"QueryParamsResponse is response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"tags":["Query"]}},"/cosmos/staking/v1beta1/pool":{"get":{"summary":"Pool queries the pool info.","operationId":"Pool","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"pool":{"description":"pool defines the pool info.","type":"object","properties":{"not_bonded_tokens":{"type":"string"},"bonded_tokens":{"type":"string"}}}},"description":"QueryPoolResponse is response type for the Query/Pool RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"tags":["Query"]}},"/cosmos/staking/v1beta1/validators":{"get":{"summary":"Validators queries all validators that match the given status.","operationId":"Validators","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"operator_address":{"type":"string","description":"operator_address defines the address of the validator\'s operator; bech encoded in JSON."},"consensus_pubkey":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"jailed":{"type":"boolean","description":"jailed defined whether the validator has been jailed from bonded status or not."},"status":{"description":"status is the validator status (bonded/unbonding/unbonded).","type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED"},"tokens":{"type":"string","description":"tokens define the delegated tokens (incl. self-delegation)."},"delegator_shares":{"type":"string","description":"delegator_shares defines total shares issued to a validator\'s delegators."},"description":{"description":"description defines the description terms for the validator.","type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}}},"unbonding_height":{"type":"string","format":"int64","description":"unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."},"unbonding_time":{"type":"string","format":"date-time","description":"unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."},"commission":{"description":"commission defines the commission parameters.","type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}}},"min_self_delegation":{"type":"string","description":"min_self_delegation is the validator\'s self declared minimum self delegation.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Validator defines a validator, together with the total amount of the\\nValidator\'s bond shares and their exchange rate to coins. Slashing results in\\na decrease in the exchange rate, allowing correct calculation of future\\nundelegations without iterating over delegators. When coins are delegated to\\nthis validator, the validator is credited with a delegation whose number of\\nbond shares is based on the amount of coins delegated divided by the current\\nexchange rate. Voting power can be calculated as total bonded shares\\nmultiplied by exchange rate."},"description":"validators contains all the queried validators."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"title":"QueryValidatorsResponse is response type for the Query/Validators RPC method"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"status","description":"status enables to query for validators matching a given status.","in":"query","required":false,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/staking/v1beta1/validators/{validator_addr}":{"get":{"summary":"Validator queries validator info for given validator address.","operationId":"Validator","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"validator":{"type":"object","properties":{"operator_address":{"type":"string","description":"operator_address defines the address of the validator\'s operator; bech encoded in JSON."},"consensus_pubkey":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"jailed":{"type":"boolean","description":"jailed defined whether the validator has been jailed from bonded status or not."},"status":{"description":"status is the validator status (bonded/unbonding/unbonded).","type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED"},"tokens":{"type":"string","description":"tokens define the delegated tokens (incl. self-delegation)."},"delegator_shares":{"type":"string","description":"delegator_shares defines total shares issued to a validator\'s delegators."},"description":{"description":"description defines the description terms for the validator.","type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}}},"unbonding_height":{"type":"string","format":"int64","description":"unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."},"unbonding_time":{"type":"string","format":"date-time","description":"unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."},"commission":{"description":"commission defines the commission parameters.","type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}}},"min_self_delegation":{"type":"string","description":"min_self_delegation is the validator\'s self declared minimum self delegation.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Validator defines a validator, together with the total amount of the\\nValidator\'s bond shares and their exchange rate to coins. Slashing results in\\na decrease in the exchange rate, allowing correct calculation of future\\nundelegations without iterating over delegators. When coins are delegated to\\nthis validator, the validator is credited with a delegation whose number of\\nbond shares is based on the amount of coins delegated divided by the current\\nexchange rate. Voting power can be calculated as total bonded shares\\nmultiplied by exchange rate."}},"title":"QueryValidatorResponse is response type for the Query/Validator RPC method"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"validator_addr","description":"validator_addr defines the validator address to query for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/staking/v1beta1/validators/{validator_addr}/delegations":{"get":{"summary":"ValidatorDelegations queries delegate info for given validator.","operationId":"ValidatorDelegations","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"delegation_responses":{"type":"array","items":{"type":"object","properties":{"delegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"shares":{"type":"string","description":"shares define the delegation shares received."}},"description":"Delegation represents the bond with tokens held by an account. It is\\nowned by one delegator, and is associated with the voting power of one\\nvalidator."},"balance":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"DelegationResponse is equivalent to Delegation except that it contains a\\nbalance in addition to shares which is more suitable for client responses."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"title":"QueryValidatorDelegationsResponse is response type for the\\nQuery/ValidatorDelegations RPC method"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"validator_addr","description":"validator_addr defines the validator address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}":{"get":{"summary":"Delegation queries delegate info for given validator delegator pair.","operationId":"Delegation","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"delegation_response":{"type":"object","properties":{"delegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"shares":{"type":"string","description":"shares define the delegation shares received."}},"description":"Delegation represents the bond with tokens held by an account. It is\\nowned by one delegator, and is associated with the voting power of one\\nvalidator."},"balance":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"DelegationResponse is equivalent to Delegation except that it contains a\\nbalance in addition to shares which is more suitable for client responses."}},"description":"QueryDelegationResponse is response type for the Query/Delegation RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"validator_addr","description":"validator_addr defines the validator address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"delegator_addr","description":"delegator_addr defines the delegator address to query for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation":{"get":{"summary":"UnbondingDelegation queries unbonding info for given validator delegator\\npair.","operationId":"UnbondingDelegation","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"unbond":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"entries":{"type":"array","items":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height is the height which the unbonding took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time is the unix time for unbonding completion."},"initial_balance":{"type":"string","description":"initial_balance defines the tokens initially scheduled to receive at completion."},"balance":{"type":"string","description":"balance defines the tokens to receive at completion."}},"description":"UnbondingDelegationEntry defines an unbonding object with relevant metadata."},"description":"entries are the unbonding delegation entries."}},"description":"UnbondingDelegation stores all of a single delegator\'s unbonding bonds\\nfor a single validator in an time-ordered list."}},"description":"QueryDelegationResponse is response type for the Query/UnbondingDelegation\\nRPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"validator_addr","description":"validator_addr defines the validator address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"delegator_addr","description":"delegator_addr defines the delegator address to query for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations":{"get":{"summary":"ValidatorUnbondingDelegations queries unbonding delegations of a validator.","operationId":"ValidatorUnbondingDelegations","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"unbonding_responses":{"type":"array","items":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"entries":{"type":"array","items":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height is the height which the unbonding took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time is the unix time for unbonding completion."},"initial_balance":{"type":"string","description":"initial_balance defines the tokens initially scheduled to receive at completion."},"balance":{"type":"string","description":"balance defines the tokens to receive at completion."}},"description":"UnbondingDelegationEntry defines an unbonding object with relevant metadata."},"description":"entries are the unbonding delegation entries."}},"description":"UnbondingDelegation stores all of a single delegator\'s unbonding bonds\\nfor a single validator in an time-ordered list."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryValidatorUnbondingDelegationsResponse is response type for the\\nQuery/ValidatorUnbondingDelegations RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"validator_addr","description":"validator_addr defines the validator address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/tx/v1beta1/simulate":{"post":{"summary":"Simulate simulates executing a transaction for estimating gas usage.","operationId":"Simulate","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"gas_info":{"description":"gas_info is the information about gas used in the simulation.","type":"object","properties":{"gas_wanted":{"type":"string","format":"uint64","description":"GasWanted is the maximum units of work we allow this tx to perform."},"gas_used":{"type":"string","format":"uint64","description":"GasUsed is the amount of gas actually consumed."}}},"result":{"description":"result is the result of the simulation.","type":"object","properties":{"data":{"type":"string","format":"byte","description":"Data is any data returned from message or handler execution. It MUST be\\nlength prefixed in order to separate data from multiple message executions.\\nDeprecated. This field is still populated, but prefer msg_response instead\\nbecause it also contains the Msg response typeURL."},"log":{"type":"string","description":"Log contains the log information from message or handler execution."},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","format":"byte"},"value":{"type":"string","format":"byte"},"index":{"type":"boolean"}},"description":"EventAttribute is a single key-value pair, associated with an event."}}},"description":"Event allows application developers to attach additional information to\\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\\nLater, transactions may be queried using these events."},"description":"Events contains a slice of Event objects that were emitted during message\\nor handler execution."},"msg_responses":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"msg_responses contains the Msg handler responses type packed in Anys.\\n\\nSince: cosmos-sdk 0.46"}}}},"description":"SimulateResponse is the response type for the\\nService.SimulateRPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.SimulateRequest"}}},"required":true},"tags":["Service"]}},"/cosmos/tx/v1beta1/txs":{"get":{"summary":"GetTxsEvent fetches txs by event.","operationId":"GetTxsEvent","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.GetTxsEventResponse"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"events","description":"events is the list of transaction event type.","in":"query","required":false,"explode":true,"schema":{"type":"array","items":{"type":"string"}}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"order_by","description":" - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.\\n - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order\\n - ORDER_BY_DESC: ORDER_BY_DESC defines descending order","in":"query","required":false,"schema":{"type":"string","enum":["ORDER_BY_UNSPECIFIED","ORDER_BY_ASC","ORDER_BY_DESC"],"default":"ORDER_BY_UNSPECIFIED"}},{"name":"page","description":"page is the page number to query, starts at 1. If not provided, will default to first page.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}}],"tags":["Service"]},"post":{"summary":"BroadcastTx broadcast transaction.","operationId":"BroadcastTx","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"tx_response":{"type":"object","properties":{"height":{"type":"string","format":"int64","title":"The block height"},"txhash":{"type":"string","description":"The transaction hash."},"codespace":{"type":"string","title":"Namespace for the Code"},"code":{"type":"integer","format":"int64","description":"Response code."},"data":{"type":"string","description":"Result bytes, if any."},"raw_log":{"type":"string","description":"The output of the application\'s logger (raw string). May be\\nnon-deterministic."},"logs":{"type":"array","items":{"type":"object","properties":{"msg_index":{"type":"integer","format":"int64"},"log":{"type":"string"},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"value":{"type":"string"}},"description":"Attribute defines an attribute wrapper where the key and value are\\nstrings instead of raw bytes."}}},"description":"StringEvent defines en Event object wrapper where all the attributes\\ncontain key/value pairs that are strings instead of raw bytes."},"description":"Events contains a slice of Event objects that were emitted during some\\nexecution."}},"description":"ABCIMessageLog defines a structure containing an indexed tx ABCI message log."},"description":"The output of the application\'s logger (typed). May be non-deterministic."},"info":{"type":"string","description":"Additional information. May be non-deterministic."},"gas_wanted":{"type":"string","format":"int64","description":"Amount of gas requested for transaction."},"gas_used":{"type":"string","format":"int64","description":"Amount of gas consumed by transaction."},"tx":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"timestamp":{"type":"string","description":"Time of the previous block. For heights > 1, it\'s the weighted median of\\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\\nit\'s genesis time."},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","format":"byte"},"value":{"type":"string","format":"byte"},"index":{"type":"boolean"}},"description":"EventAttribute is a single key-value pair, associated with an event."}}},"description":"Event allows application developers to attach additional information to\\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\\nLater, transactions may be queried using these events."},"description":"Events defines all the events emitted by processing a transaction. Note,\\nthese events include those emitted by processing all the messages and those\\nemitted from the ante. Whereas Logs contains the events, with\\nadditional metadata, emitted only by processing the messages.\\n\\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"}},"description":"TxResponse defines a structure containing relevant tx data and metadata. The\\ntags are stringified and the log is JSON decoded."}},"description":"BroadcastTxResponse is the response type for the\\nService.BroadcastTx method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"requestBody":{"content":{"application/json":{"schema":{"type":"object","properties":{"tx_bytes":{"type":"string","format":"byte","description":"tx_bytes is the raw transaction."},"mode":{"type":"string","enum":["BROADCAST_MODE_UNSPECIFIED","BROADCAST_MODE_BLOCK","BROADCAST_MODE_SYNC","BROADCAST_MODE_ASYNC"],"default":"BROADCAST_MODE_UNSPECIFIED","description":"BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.\\n\\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\\n - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for\\nthe tx to be committed in a block.\\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for\\na CheckTx execution response only.\\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns\\nimmediately."}},"description":"BroadcastTxRequest is the request type for the Service.BroadcastTxRequest\\nRPC method."}}},"required":true},"tags":["Service"]}},"/cosmos/tx/v1beta1/txs/block/{height}":{"get":{"summary":"GetBlockWithTxs fetches a block with decoded txs.","description":"Since: cosmos-sdk 0.45.2","operationId":"GetBlockWithTxs","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.GetBlockWithTxsResponse"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"height","description":"height is the height of the block to query.","in":"path","required":true,"schema":{"type":"string","format":"int64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Service"]}},"/cosmos/tx/v1beta1/txs/{hash}":{"get":{"summary":"GetTx fetches a tx by hash.","operationId":"GetTx","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.GetTxResponse"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"hash","description":"hash is the tx hash to query, encoded as a hex string.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Service"]}},"/cosmos/upgrade/v1beta1/applied_plan/{name}":{"get":{"summary":"AppliedPlan queries a previously applied upgrade plan by its name.","operationId":"AppliedPlan","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"height":{"type":"string","format":"int64","description":"height is the block height at which the plan was applied."}},"description":"QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"name","description":"name is the name of the applied plan to query for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/upgrade/v1beta1/authority":{"get":{"summary":"Returns the account with authority to conduct upgrades","description":"Since: cosmos-sdk 0.46","operationId":"Authority","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"address":{"type":"string"}},"description":"Since: cosmos-sdk 0.46","title":"QueryAuthorityResponse is the response type for Query/Authority"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"tags":["Query"]}},"/cosmos/upgrade/v1beta1/current_plan":{"get":{"summary":"CurrentPlan queries the current upgrade plan.","operationId":"CurrentPlan","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"plan":{"description":"plan is the current upgrade plan.","type":"object","properties":{"name":{"type":"string","description":"Sets the name for the upgrade. This name will be used by the upgraded\\nversion of the software to apply any special \\"on-upgrade\\" commands during\\nthe first BeginBlock method after the upgrade is applied. It is also used\\nto detect whether a software version can handle a given upgrade. If no\\nupgrade handler with this name has been set in the software, it will be\\nassumed that the software is out-of-date when the upgrade Time or Height is\\nreached and the software will exit."},"time":{"type":"string","format":"date-time","description":"Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\\nhas been removed from the SDK.\\nIf this field is not empty, an error will be thrown."},"height":{"type":"string","format":"int64","description":"The height at which the upgrade must be performed.\\nOnly used if Time is not set."},"info":{"type":"string","title":"Any application specific upgrade info to be included on-chain\\nsuch as a git commit that validators could automatically upgrade to"},"upgraded_client_state":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}},"description":"QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC\\nmethod."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"tags":["Query"]}},"/cosmos/upgrade/v1beta1/module_versions":{"get":{"summary":"ModuleVersions queries the list of module versions from state.","description":"Since: cosmos-sdk 0.43","operationId":"ModuleVersions","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"module_versions":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name of the app module"},"version":{"type":"string","format":"uint64","title":"consensus version of the app module"}},"description":"ModuleVersion specifies a module and its consensus version.\\n\\nSince: cosmos-sdk 0.43"},"description":"module_versions is a list of module names with their consensus versions."}},"description":"QueryModuleVersionsResponse is the response type for the Query/ModuleVersions\\nRPC method.\\n\\nSince: cosmos-sdk 0.43"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"module_name","description":"module_name is a field to query a specific module\\nconsensus version from state. Leaving this empty will\\nfetch the full list of module versions from state.","in":"query","required":false,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}":{"get":{"summary":"UpgradedConsensusState queries the consensus state that will serve\\nas a trusted kernel for the next version of this chain. It will only be\\nstored at the last height of this chain.\\nUpgradedConsensusState RPC not supported with legacy querier\\nThis rpc is deprecated now that IBC has its own replacement\\n(https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)","operationId":"UpgradedConsensusState","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"upgraded_consensus_state":{"type":"string","format":"byte","title":"Since: cosmos-sdk 0.43"}},"description":"QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState\\nRPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"last_height","description":"last height of the current chain must be sent in request\\nas this is the height under which next consensus state is stored","in":"path","required":true,"schema":{"type":"string","format":"int64"}}],"tags":["Query"]}},"/cosmos/authz/v1beta1/grants":{"get":{"summary":"Returns list of `Authorization`, granted to the grantee by the granter.","operationId":"Grants","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"grants":{"type":"array","items":{"type":"object","properties":{"authorization":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"expiration":{"type":"string","format":"date-time","title":"time when the grant will expire and will be pruned. If null, then the grant\\ndoesn\'t have a time expiration (other conditions  in `authorization`\\nmay apply to invalidate the grant)"}},"description":"Grant gives permissions to execute\\nthe provide method with expiration time."},"description":"authorizations is a list of grants granted for grantee by granter."},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGrantsResponse is the response type for the Query/Authorizations RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"granter","in":"query","required":false,"schema":{"type":"string"}},{"name":"grantee","in":"query","required":false,"schema":{"type":"string"}},{"name":"msg_type_url","description":"Optional, msg_type_url, when set, will query only grants matching given msg type.","in":"query","required":false,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/authz/v1beta1/grants/grantee/{grantee}":{"get":{"summary":"GranteeGrants returns a list of `GrantAuthorization` by grantee.","description":"Since: cosmos-sdk 0.46","operationId":"GranteeGrants","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"grants":{"type":"array","items":{"type":"object","properties":{"granter":{"type":"string"},"grantee":{"type":"string"},"authorization":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"expiration":{"type":"string","format":"date-time"}},"title":"GrantAuthorization extends a grant with both the addresses of the grantee and granter.\\nIt is used in genesis.proto and query.proto"},"description":"grants is a list of grants granted to the grantee."},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"grantee","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/authz/v1beta1/grants/granter/{granter}":{"get":{"summary":"GranterGrants returns list of `GrantAuthorization`, granted by granter.","description":"Since: cosmos-sdk 0.46","operationId":"GranterGrants","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"grants":{"type":"array","items":{"type":"object","properties":{"granter":{"type":"string"},"grantee":{"type":"string"},"authorization":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"expiration":{"type":"string","format":"date-time"}},"title":"GrantAuthorization extends a grant with both the addresses of the grantee and granter.\\nIt is used in genesis.proto and query.proto"},"description":"grants is a list of grants granted by the granter."},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"granter","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}":{"get":{"summary":"Allowance returns fee granted to the grantee by the granter.","operationId":"Allowance","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"allowance":{"description":"allowance is a allowance granted for grantee by granter.","type":"object","properties":{"granter":{"type":"string","description":"granter is the address of the user granting an allowance of their funds."},"grantee":{"type":"string","description":"grantee is the address of the user being granted an allowance of another user\'s funds."},"allowance":{"description":"allowance can be any of basic, periodic, allowed fee allowance.","type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}}}},"title":"Grant is stored in the KVStore to record a grant with full context"}},"description":"QueryAllowanceResponse is the response type for the Query/Allowance RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"granter","description":"granter is the address of the user granting an allowance of their funds.","in":"path","required":true,"schema":{"type":"string"}},{"name":"grantee","description":"grantee is the address of the user being granted an allowance of another user\'s funds.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/feegrant/v1beta1/allowances/{grantee}":{"get":{"summary":"Allowances returns all the grants for address.","operationId":"Allowances","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"allowances":{"type":"array","items":{"type":"object","properties":{"granter":{"type":"string","description":"granter is the address of the user granting an allowance of their funds."},"grantee":{"type":"string","description":"grantee is the address of the user being granted an allowance of another user\'s funds."},"allowance":{"description":"allowance can be any of basic, periodic, allowed fee allowance.","type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}}}},"title":"Grant is stored in the KVStore to record a grant with full context"},"description":"allowances are allowance\'s granted for grantee by granter."},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAllowancesResponse is the response type for the Query/Allowances RPC method."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"grantee","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/feegrant/v1beta1/issued/{granter}":{"get":{"summary":"AllowancesByGranter returns all the grants given by an address","description":"Since: cosmos-sdk 0.46","operationId":"AllowancesByGranter","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"allowances":{"type":"array","items":{"type":"object","properties":{"granter":{"type":"string","description":"granter is the address of the user granting an allowance of their funds."},"grantee":{"type":"string","description":"grantee is the address of the user being granted an allowance of another user\'s funds."},"allowance":{"description":"allowance can be any of basic, periodic, allowed fee allowance.","type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}}}},"title":"Grant is stored in the KVStore to record a grant with full context"},"description":"allowances that have been issued by the granter."},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method.\\n\\nSince: cosmos-sdk 0.46"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"granter","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/group/v1/group_info/{group_id}":{"get":{"summary":"GroupInfo queries group info based on group id.","operationId":"GroupInfo","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"info":{"description":"info is the GroupInfo for the group.","type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group\'s admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group."},"version":{"type":"string","format":"uint64","title":"version is used to track changes to a group\'s membership structure that\\nwould break existing proposals. Whenever any members weight is changed,\\nor any member is added or removed this version is incremented and will\\ncause proposals based on older versions of this group to fail"},"total_weight":{"type":"string","description":"total_weight is the sum of the group members\' weights."},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group was created."}}}},"description":"QueryGroupInfoResponse is the Query/GroupInfo response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"group_id","description":"group_id is the unique ID of the group.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}}],"tags":["Query"]}},"/cosmos/group/v1/group_members/{group_id}":{"get":{"summary":"GroupMembers queries members of a group","operationId":"GroupMembers","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"members":{"type":"array","items":{"type":"object","properties":{"group_id":{"type":"string","format":"uint64","description":"group_id is the unique ID of the group."},"member":{"description":"member is the member data.","type":"object","properties":{"address":{"type":"string","description":"address is the member\'s account address."},"weight":{"type":"string","description":"weight is the member\'s voting weight that should be greater than 0."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata attached to the member."},"added_at":{"type":"string","format":"date-time","description":"added_at is a timestamp specifying when a member was added."}}}},"description":"GroupMember represents the relationship between a group and a member."},"description":"members are the members of the group with given group_id."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGroupMembersResponse is the Query/GroupMembersResponse response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"group_id","description":"group_id is the unique ID of the group.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/group/v1/group_policies_by_admin/{admin}":{"get":{"summary":"GroupsByAdmin queries group policies by admin address.","operationId":"GroupPoliciesByAdmin","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"group_policies":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address is the account address of group policy."},"group_id":{"type":"string","format":"uint64","description":"group_id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group policy."},"version":{"type":"string","format":"uint64","description":"version is used to track changes to a group\'s GroupPolicyInfo structure that\\nwould create a different result on a running proposal."},"decision_policy":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group policy was created."}},"description":"GroupPolicyInfo represents the high-level on-chain information for a group policy."},"description":"group_policies are the group policies info with provided admin."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGroupPoliciesByAdminResponse is the Query/GroupPoliciesByAdmin response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"admin","description":"admin is the admin address of the group policy.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/group/v1/group_policies_by_group/{group_id}":{"get":{"summary":"GroupPoliciesByGroup queries group policies by group id.","operationId":"GroupPoliciesByGroup","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"group_policies":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address is the account address of group policy."},"group_id":{"type":"string","format":"uint64","description":"group_id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group policy."},"version":{"type":"string","format":"uint64","description":"version is used to track changes to a group\'s GroupPolicyInfo structure that\\nwould create a different result on a running proposal."},"decision_policy":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group policy was created."}},"description":"GroupPolicyInfo represents the high-level on-chain information for a group policy."},"description":"group_policies are the group policies info associated with the provided group."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGroupPoliciesByGroupResponse is the Query/GroupPoliciesByGroup response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"group_id","description":"group_id is the unique ID of the group policy\'s group.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/group/v1/group_policy_info/{address}":{"get":{"summary":"GroupPolicyInfo queries group policy info based on account address of group policy.","operationId":"GroupPolicyInfo","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"info":{"type":"object","properties":{"address":{"type":"string","description":"address is the account address of group policy."},"group_id":{"type":"string","format":"uint64","description":"group_id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group policy."},"version":{"type":"string","format":"uint64","description":"version is used to track changes to a group\'s GroupPolicyInfo structure that\\nwould create a different result on a running proposal."},"decision_policy":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group policy was created."}},"description":"GroupPolicyInfo represents the high-level on-chain information for a group policy."}},"description":"QueryGroupPolicyInfoResponse is the Query/GroupPolicyInfo response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"address","description":"address is the account address of the group policy.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/group/v1/groups":{"get":{"summary":"Groups queries all groups in state.","description":"Since: cosmos-sdk 0.47.1","operationId":"Groups","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"groups":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group\'s admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group."},"version":{"type":"string","format":"uint64","title":"version is used to track changes to a group\'s membership structure that\\nwould break existing proposals. Whenever any members weight is changed,\\nor any member is added or removed this version is incremented and will\\ncause proposals based on older versions of this group to fail"},"total_weight":{"type":"string","description":"total_weight is the sum of the group members\' weights."},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group was created."}},"description":"GroupInfo represents the high-level on-chain information for a group."},"description":"`groups` is all the groups present in state."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGroupsResponse is the Query/Groups response type.\\n\\nSince: cosmos-sdk 0.47.1"}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/group/v1/groups_by_admin/{admin}":{"get":{"summary":"GroupsByAdmin queries groups by admin address.","operationId":"GroupsByAdmin","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"groups":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group\'s admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group."},"version":{"type":"string","format":"uint64","title":"version is used to track changes to a group\'s membership structure that\\nwould break existing proposals. Whenever any members weight is changed,\\nor any member is added or removed this version is incremented and will\\ncause proposals based on older versions of this group to fail"},"total_weight":{"type":"string","description":"total_weight is the sum of the group members\' weights."},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group was created."}},"description":"GroupInfo represents the high-level on-chain information for a group."},"description":"groups are the groups info with the provided admin."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGroupsByAdminResponse is the Query/GroupsByAdminResponse response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"admin","description":"admin is the account address of a group\'s admin.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/group/v1/groups_by_member/{address}":{"get":{"summary":"GroupsByMember queries groups by member address.","operationId":"GroupsByMember","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"groups":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group\'s admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group."},"version":{"type":"string","format":"uint64","title":"version is used to track changes to a group\'s membership structure that\\nwould break existing proposals. Whenever any members weight is changed,\\nor any member is added or removed this version is incremented and will\\ncause proposals based on older versions of this group to fail"},"total_weight":{"type":"string","description":"total_weight is the sum of the group members\' weights."},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group was created."}},"description":"GroupInfo represents the high-level on-chain information for a group."},"description":"groups are the groups info with the provided group member."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGroupsByMemberResponse is the Query/GroupsByMember response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"address","description":"address is the group member address.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/group/v1/proposal/{proposal_id}":{"get":{"summary":"Proposal queries a proposal based on proposal id.","operationId":"GroupProposal","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"proposal":{"description":"proposal is the proposal info.","type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique id of the proposal."},"group_policy_address":{"type":"string","description":"group_policy_address is the account address of group policy."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the proposal."},"proposers":{"type":"array","items":{"type":"string"},"description":"proposers are the account addresses of the proposers."},"submit_time":{"type":"string","format":"date-time","description":"submit_time is a timestamp specifying when a proposal was submitted."},"group_version":{"type":"string","format":"uint64","description":"group_version tracks the version of the group at proposal submission.\\nThis field is here for informational purposes only."},"group_policy_version":{"type":"string","format":"uint64","description":"group_policy_version tracks the version of the group policy at proposal submission.\\nWhen a decision policy is changed, existing proposals from previous policy\\nversions will become invalid with the `ABORTED` status.\\nThis field is here for informational purposes only."},"status":{"description":"status represents the high level position in the life cycle of the proposal. Initial value is Submitted.","type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_SUBMITTED","PROPOSAL_STATUS_ACCEPTED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_ABORTED","PROPOSAL_STATUS_WITHDRAWN"],"default":"PROPOSAL_STATUS_UNSPECIFIED"},"final_tally_result":{"description":"final_tally_result contains the sums of all weighted votes for this\\nproposal for each vote option. It is empty at submission, and only\\npopulated after tallying, at voting period end or at proposal execution,\\nwhichever happens first.","type":"object","properties":{"yes_count":{"type":"string","description":"yes_count is the weighted sum of yes votes."},"abstain_count":{"type":"string","description":"abstain_count is the weighted sum of abstainers."},"no_count":{"type":"string","description":"no_count is the weighted sum of no votes."},"no_with_veto_count":{"type":"string","description":"no_with_veto_count is the weighted sum of veto."}}},"voting_period_end":{"type":"string","format":"date-time","description":"voting_period_end is the timestamp before which voting must be done.\\nUnless a successfull MsgExec is called before (to execute a proposal whose\\ntally is successful before the voting period ends), tallying will be done\\nat this point, and the `final_tally_result`and `status` fields will be\\naccordingly updated."},"executor_result":{"description":"executor_result is the final result of the proposal execution. Initial value is NotRun.","type":"string","enum":["PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED","PROPOSAL_EXECUTOR_RESULT_NOT_RUN","PROPOSAL_EXECUTOR_RESULT_SUCCESS","PROPOSAL_EXECUTOR_RESULT_FAILURE"],"default":"PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED"},"messages":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"messages is a list of `sdk.Msg`s that will be executed if the proposal passes."}}}},"description":"QueryProposalResponse is the Query/Proposal response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id is the unique ID of a proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}}],"tags":["Query"]}},"/cosmos/group/v1/proposals/{proposal_id}/tally":{"get":{"summary":"TallyResult returns the tally result of a proposal. If the proposal is\\nstill in voting period, then this query computes the current tally state,\\nwhich might not be final. On the other hand, if the proposal is final,\\nthen it simply returns the `final_tally_result` state stored in the\\nproposal itself.","operationId":"GroupTallyResult","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"tally":{"description":"tally defines the requested tally.","type":"object","properties":{"yes_count":{"type":"string","description":"yes_count is the weighted sum of yes votes."},"abstain_count":{"type":"string","description":"abstain_count is the weighted sum of abstainers."},"no_count":{"type":"string","description":"no_count is the weighted sum of no votes."},"no_with_veto_count":{"type":"string","description":"no_with_veto_count is the weighted sum of veto."}}}},"description":"QueryTallyResultResponse is the Query/TallyResult response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id is the unique id of a proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}}],"tags":["Query"]}},"/cosmos/group/v1/proposals_by_group_policy/{address}":{"get":{"summary":"ProposalsByGroupPolicy queries proposals based on account address of group policy.","operationId":"ProposalsByGroupPolicy","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"proposals":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique id of the proposal."},"group_policy_address":{"type":"string","description":"group_policy_address is the account address of group policy."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the proposal."},"proposers":{"type":"array","items":{"type":"string"},"description":"proposers are the account addresses of the proposers."},"submit_time":{"type":"string","format":"date-time","description":"submit_time is a timestamp specifying when a proposal was submitted."},"group_version":{"type":"string","format":"uint64","description":"group_version tracks the version of the group at proposal submission.\\nThis field is here for informational purposes only."},"group_policy_version":{"type":"string","format":"uint64","description":"group_policy_version tracks the version of the group policy at proposal submission.\\nWhen a decision policy is changed, existing proposals from previous policy\\nversions will become invalid with the `ABORTED` status.\\nThis field is here for informational purposes only."},"status":{"description":"status represents the high level position in the life cycle of the proposal. Initial value is Submitted.","type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_SUBMITTED","PROPOSAL_STATUS_ACCEPTED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_ABORTED","PROPOSAL_STATUS_WITHDRAWN"],"default":"PROPOSAL_STATUS_UNSPECIFIED"},"final_tally_result":{"description":"final_tally_result contains the sums of all weighted votes for this\\nproposal for each vote option. It is empty at submission, and only\\npopulated after tallying, at voting period end or at proposal execution,\\nwhichever happens first.","type":"object","properties":{"yes_count":{"type":"string","description":"yes_count is the weighted sum of yes votes."},"abstain_count":{"type":"string","description":"abstain_count is the weighted sum of abstainers."},"no_count":{"type":"string","description":"no_count is the weighted sum of no votes."},"no_with_veto_count":{"type":"string","description":"no_with_veto_count is the weighted sum of veto."}}},"voting_period_end":{"type":"string","format":"date-time","description":"voting_period_end is the timestamp before which voting must be done.\\nUnless a successfull MsgExec is called before (to execute a proposal whose\\ntally is successful before the voting period ends), tallying will be done\\nat this point, and the `final_tally_result`and `status` fields will be\\naccordingly updated."},"executor_result":{"description":"executor_result is the final result of the proposal execution. Initial value is NotRun.","type":"string","enum":["PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED","PROPOSAL_EXECUTOR_RESULT_NOT_RUN","PROPOSAL_EXECUTOR_RESULT_SUCCESS","PROPOSAL_EXECUTOR_RESULT_FAILURE"],"default":"PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED"},"messages":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"messages is a list of `sdk.Msg`s that will be executed if the proposal passes."}},"description":"Proposal defines a group proposal. Any member of a group can submit a proposal\\nfor a group policy to decide upon.\\nA proposal consists of a set of `sdk.Msg`s that will be executed if the proposal\\npasses as well as some optional metadata associated with the proposal."},"description":"proposals are the proposals with given group policy."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryProposalsByGroupPolicyResponse is the Query/ProposalByGroupPolicy response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"address","description":"address is the account address of the group policy related to proposals.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/group/v1/vote_by_proposal_voter/{proposal_id}/{voter}":{"get":{"summary":"VoteByProposalVoter queries a vote by proposal id and voter.","operationId":"VoteByProposalVoter","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"vote":{"description":"vote is the vote with given proposal_id and voter.","type":"object","properties":{"proposal_id":{"type":"string","format":"uint64","description":"proposal is the unique ID of the proposal."},"voter":{"type":"string","description":"voter is the account address of the voter."},"option":{"description":"option is the voter\'s choice on the proposal.","type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED"},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the vote."},"submit_time":{"type":"string","format":"date-time","description":"submit_time is the timestamp when the vote was submitted."}}}},"description":"QueryVoteByProposalVoterResponse is the Query/VoteByProposalVoter response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id is the unique ID of a proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"voter","description":"voter is a proposal voter account address.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/cosmos/group/v1/votes_by_proposal/{proposal_id}":{"get":{"summary":"VotesByProposal queries a vote by proposal.","operationId":"VotesByProposal","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"votes":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64","description":"proposal is the unique ID of the proposal."},"voter":{"type":"string","description":"voter is the account address of the voter."},"option":{"description":"option is the voter\'s choice on the proposal.","type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED"},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the vote."},"submit_time":{"type":"string","format":"date-time","description":"submit_time is the timestamp when the vote was submitted."}},"description":"Vote represents a vote for a proposal."},"description":"votes are the list of votes for given proposal_id."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryVotesByProposalResponse is the Query/VotesByProposal response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"proposal_id","description":"proposal_id is the unique ID of a proposal.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/cosmos/group/v1/votes_by_voter/{voter}":{"get":{"summary":"VotesByVoter queries a vote by voter.","operationId":"VotesByVoter","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"votes":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64","description":"proposal is the unique ID of the proposal."},"voter":{"type":"string","description":"voter is the account address of the voter."},"option":{"description":"option is the voter\'s choice on the proposal.","type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED"},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the vote."},"submit_time":{"type":"string","format":"date-time","description":"submit_time is the timestamp when the vote was submitted."}},"description":"Vote represents a vote for a proposal."},"description":"votes are the list of votes by given voter."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryVotesByVoterResponse is the Query/VotesByVoter response type."}}}},"default":{"description":"An unexpected error response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"voter","description":"voter is a proposal voter account address.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean"}}],"tags":["Query"]}},"/provenance/attribute/v1/accountdata/{account}":{"get":{"summary":"AccountData returns the accountdata for a specified account.","operationId":"AccountData","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"value":{"type":"string","description":"value is the accountdata attribute value for the requested account."}},"description":"QueryAccountDataResponse is the response type for the Query/AccountData method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"account","description":"account is the bech32 address of the account to get the data for","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/attribute/v1/accounts/{attribute_name}":{"get":{"summary":"AttributeAccounts queries accounts on a given attribute name","operationId":"AttributeAccounts","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"accounts":{"type":"array","items":{"type":"string"},"title":"list of account addresses that have attributes of request name"},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAttributeAccountsResponse is the response type for the Query/AttributeAccounts method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"attribute_name","description":"name is the attribute name to query for","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/attribute/v1/attribute/{account}/scan/{suffix}":{"get":{"summary":"Scan queries attributes on a given account (address) for any that match the provided suffix","operationId":"Scan","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"account":{"type":"string","title":"a string containing the address of the account the attributes are assigned to="},"attributes":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"The attribute name."},"value":{"type":"string","format":"byte","description":"The attribute value."},"attribute_type":{"description":"The attribute value type.","type":"string","enum":["ATTRIBUTE_TYPE_UNSPECIFIED","ATTRIBUTE_TYPE_UUID","ATTRIBUTE_TYPE_JSON","ATTRIBUTE_TYPE_STRING","ATTRIBUTE_TYPE_URI","ATTRIBUTE_TYPE_INT","ATTRIBUTE_TYPE_FLOAT","ATTRIBUTE_TYPE_PROTO","ATTRIBUTE_TYPE_BYTES"],"default":"ATTRIBUTE_TYPE_UNSPECIFIED","title":"AttributeType defines the type of the data stored in the attribute value"},"address":{"type":"string","title":"The address the attribute is bound to"},"expiration_date":{"type":"string","format":"date-time","description":"Time that an attribute will expire."}},"title":"Attribute holds a typed key/value structure for data associated with an account"},"title":"a list of attribute values"},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryScanResponse is the response type for the Query/Scan method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"account","description":"account defines the address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"suffix","description":"name defines the partial attribute name to search for base on names being in RDNS format.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/attribute/v1/attribute/{account}/{name}":{"get":{"summary":"Attribute queries attributes on a given account (address) for one (or more) with the given name","operationId":"Attribute","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"account":{"type":"string","description":"a string containing the address of the account the attributes are assigned to."},"attributes":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"The attribute name."},"value":{"type":"string","format":"byte","description":"The attribute value."},"attribute_type":{"description":"The attribute value type.","type":"string","enum":["ATTRIBUTE_TYPE_UNSPECIFIED","ATTRIBUTE_TYPE_UUID","ATTRIBUTE_TYPE_JSON","ATTRIBUTE_TYPE_STRING","ATTRIBUTE_TYPE_URI","ATTRIBUTE_TYPE_INT","ATTRIBUTE_TYPE_FLOAT","ATTRIBUTE_TYPE_PROTO","ATTRIBUTE_TYPE_BYTES"],"default":"ATTRIBUTE_TYPE_UNSPECIFIED","title":"AttributeType defines the type of the data stored in the attribute value"},"address":{"type":"string","title":"The address the attribute is bound to"},"expiration_date":{"type":"string","format":"date-time","description":"Time that an attribute will expire."}},"title":"Attribute holds a typed key/value structure for data associated with an account"},"title":"a list of attribute values"},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAttributeResponse is the response type for the Query/Attribute method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"account","description":"account defines the address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"name","description":"name is the attribute name to query for","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/attribute/v1/attributes/{account}":{"get":{"summary":"Attributes queries attributes on a given account (address) for any defined attributes","operationId":"Attributes","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"account":{"type":"string","title":"a string containing the address of the account the attributes are assigned to="},"attributes":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"The attribute name."},"value":{"type":"string","format":"byte","description":"The attribute value."},"attribute_type":{"description":"The attribute value type.","type":"string","enum":["ATTRIBUTE_TYPE_UNSPECIFIED","ATTRIBUTE_TYPE_UUID","ATTRIBUTE_TYPE_JSON","ATTRIBUTE_TYPE_STRING","ATTRIBUTE_TYPE_URI","ATTRIBUTE_TYPE_INT","ATTRIBUTE_TYPE_FLOAT","ATTRIBUTE_TYPE_PROTO","ATTRIBUTE_TYPE_BYTES"],"default":"ATTRIBUTE_TYPE_UNSPECIFIED","title":"AttributeType defines the type of the data stored in the attribute value"},"address":{"type":"string","title":"The address the attribute is bound to"},"expiration_date":{"type":"string","format":"date-time","description":"Time that an attribute will expire."}},"title":"Attribute holds a typed key/value structure for data associated with an account"},"title":"a list of attribute values"},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAttributesResponse is the response type for the Query/Attributes method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"account","description":"account defines the address to query for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/attribute/v1/params":{"get":{"summary":"Params queries params of the attribute module.","operationId":"AttributeParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"max_value_length":{"type":"integer","format":"int64","title":"maximum length of data to allow in an attribute value"}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/provenance/exchange/v1/commitments":{"get":{"summary":"GetAllCommitments gets all fund committed to any market from any account.","operationId":"GetAllCommitments","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"commitments":{"type":"array","items":{"type":"object","properties":{"account":{"type":"string","description":"account is the bech32 address string with the committed funds."},"market_id":{"type":"integer","format":"int64","description":"market_id is the numeric identifier of the market the funds are committed to."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds that have been committed by the account to the market."}},"description":"Commitment contains information on committed funds."},"description":"commitments is the requested commitment information."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetAllCommitmentsResponse is a response message for the GetAllCommitments query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/exchange/v1/commitments/account/{account}":{"get":{"summary":"GetAccountCommitments gets all the funds in an account that are committed to any market.","operationId":"GetAccountCommitments","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"commitments":{"type":"array","items":{"type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id is the numeric identifier the amount has been committed to."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds associated with the address."}},"description":"MarketAmount associates a market with a coins amount."},"description":"commitments is the amounts committed from the account to the any market."}},"description":"QueryGetAccountCommitmentsResponse is a response message for the GetAccountCommitments query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"account","description":"account is the bech32 address string of the account with the commitments.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/exchange/v1/commitments/market/{market_id}":{"get":{"summary":"GetMarketCommitments gets all the funds committed to a market from any account.","operationId":"GetMarketCommitments","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"commitments":{"type":"array","items":{"type":"object","properties":{"account":{"type":"string","description":"account is the bech32 address string of the account associated with the amount."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds associated with the address."}},"description":"AccountAmount associates an account with a coins amount."},"description":"commitments is the amounts committed to the market from any account."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetMarketCommitmentsResponse is a response message for the GetMarketCommitments query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"market_id","description":"market_id is the numeric identifier of the market with the commitment.","in":"path","required":true,"schema":{"type":"integer","format":"int64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/exchange/v1/fees/commitment_settlement":{"get":{"summary":"CommitmentSettlementFeeCalc calculates the fees a market will pay for a commitment settlement using current NAVs.","operationId":"CommitmentSettlementFeeCalc","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"exchange_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"exchange_fees is the total that the exchange would currently pay for the provided settlement."},"input_total":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"input_total is the sum of all the inputs in the provided settlement."},"converted_total":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"converted_total is the input_total converted to a single intermediary denom or left as the fee denom."},"conversion_navs":{"type":"array","items":{"type":"object","properties":{"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"NetAssetPrice is an association of assets and price used to record the value of things.\\nIt is related to the NetAssetValue message from the x/marker module, and is therefore often referred to as \\"a NAV\\"."},"description":"conversion_navs are the NAVs used to convert the input_total to the converted_total."},"to_fee_nav":{"type":"object","properties":{"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"NetAssetPrice is an association of assets and price used to record the value of things.\\nIt is related to the NetAssetValue message from the x/marker module, and is therefore often referred to as \\"a NAV\\"."}},"description":"QueryCommitmentSettlementFeeCalcResponse is a response message for the CommitmentSettlementFeeCalc query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"settlement.admin","description":"admin is the account with \\"settle\\" permission requesting this settlement.","in":"query","required":false,"schema":{"type":"string"}},{"name":"settlement.market_id","description":"market_id is the numerical identifier of the market requesting this settlement.","in":"query","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"settlement.event_tag","description":"event_tag is a string that is included in the funds-committed/released events. Max length is 100 characters.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_breakdown_fields","description":"include_breakdown_fields controls the fields that are populated in the response.\\nIf false, only the exchange_fees field is populated.\\nIf true, all of the fields are populated as possible.\\nIf the settlement does not have any inputs, this field defaults to true.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/exchange/v1/fees/order":{"get":{"summary":"OrderFeeCalc calculates the fees that will be associated with the provided order.","operationId":"OrderFeeCalc","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"creation_fee_options":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"creation_fee_options are the order creation flat fee options available for creating the provided order.\\nIf it\'s empty, no order creation fee is required.\\nWhen creating the order, you should include exactly one of these."},"settlement_flat_fee_options":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"settlement_flat_fee_options are the settlement flat fee options available for the provided order.\\nIf it\'s empty, no settlement flat fee is required.\\nWhen creating an order, you should include exactly one of these in the settlement fees field."},"settlement_ratio_fee_options":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"settlement_ratio_fee_options are the settlement ratio fee options available for the provided order.\\nIf it\'s empty, no settlement ratio fee is required.\\n\\nIf the provided order was a bid order, you should include exactly one of these in the settlement fees field.\\nIf the flat and ratio options you\'ve chose have the same denom, a single entry should be included with their sum.\\n\\nIf the provided order was an ask order, these are purely informational and represent how much will be removed\\nfrom your price if it settles at that price. If it settles for more, the actual amount will probably be larger."}},"description":"QueryOrderFeeCalcResponse is a response message for the OrderFeeCalc query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"ask_order.market_id","description":"market_id identifies the market that this order belongs to.","in":"query","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"ask_order.seller","description":"seller is the address of the account that owns this order and has the assets to sell.","in":"query","required":false,"schema":{"type":"string"}},{"name":"ask_order.assets.denom","in":"query","required":false,"schema":{"type":"string"}},{"name":"ask_order.assets.amount","in":"query","required":false,"schema":{"type":"string"}},{"name":"ask_order.price.denom","in":"query","required":false,"schema":{"type":"string"}},{"name":"ask_order.price.amount","in":"query","required":false,"schema":{"type":"string"}},{"name":"ask_order.seller_settlement_flat_fee.denom","in":"query","required":false,"schema":{"type":"string"}},{"name":"ask_order.seller_settlement_flat_fee.amount","in":"query","required":false,"schema":{"type":"string"}},{"name":"ask_order.allow_partial","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"ask_order.external_id","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected.","in":"query","required":false,"schema":{"type":"string"}},{"name":"bid_order.market_id","description":"market_id identifies the market that this order belongs to.","in":"query","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"bid_order.buyer","description":"buyer is the address of the account that owns this order and has the price to spend.","in":"query","required":false,"schema":{"type":"string"}},{"name":"bid_order.assets.denom","in":"query","required":false,"schema":{"type":"string"}},{"name":"bid_order.assets.amount","in":"query","required":false,"schema":{"type":"string"}},{"name":"bid_order.price.denom","in":"query","required":false,"schema":{"type":"string"}},{"name":"bid_order.price.amount","in":"query","required":false,"schema":{"type":"string"}},{"name":"bid_order.allow_partial","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"bid_order.external_id","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected.","in":"query","required":false,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/exchange/v1/market/{market_id}":{"get":{"summary":"GetMarket returns all the information and details about a market.","operationId":"GetMarket","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"address":{"type":"string","description":"address is the bech32 address string of this market\'s account."},"market":{"description":"market is all information and details of the market.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id is the numerical identifier for this market."},"market_details":{"description":"market_details is some information about this market.","type":"object","properties":{"name":{"type":"string","description":"name is a moniker that people can use to refer to this market."},"description":{"type":"string","description":"description extra information about this market. The field is meant to be human-readable."},"website_url":{"type":"string","description":"website_url is a url people can use to get to this market, or at least get more information about this market."},"icon_uri":{"type":"string","description":"icon_uri is a uri for an icon to associate with this market."}}},"fee_create_ask_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_create_ask_flat is the flat fee charged for creating an ask order.\\nEach coin entry is a separate option. When an ask is created, one of these must be paid.\\nIf empty, no fee is required to create an ask order."},"fee_create_bid_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_create_bid_flat is the flat fee charged for creating a bid order.\\nEach coin entry is a separate option. When a bid is created, one of these must be paid.\\nIf empty, no fee is required to create a bid order."},"fee_seller_settlement_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_seller_settlement_flat is the flat fee charged to the seller during settlement.\\nEach coin entry is a separate option.\\nWhen an ask is settled, the seller will pay the amount in the denom that matches the price they received."},"fee_seller_settlement_ratios":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"description":"fee_seller_settlement_ratios is the fee to charge a seller during settlement based on the price they are receiving.\\nThe price and fee denoms must be equal for each entry, and only one entry for any given denom is allowed."},"fee_buyer_settlement_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_buyer_settlement_flat is the flat fee charged to the buyer during settlement.\\nEach coin entry is a separate option.\\nWhen a bid is created, the settlement fees provided must contain one of these."},"fee_buyer_settlement_ratios":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"description":"fee_buyer_settlement_ratios is the fee to charge a buyer during settlement based on the price they are spending.\\nThe price and fee denoms do not have to equal. Multiple entries for any given price or fee denom are allowed, but\\neach price denom to fee denom pair can only have one entry."},"accepting_orders":{"type":"boolean","format":"boolean","description":"accepting_orders is whether this market is allowing orders to be created for it."},"allow_user_settlement":{"type":"boolean","format":"boolean","description":"allow_user_settlement is whether this market allows users to initiate their own settlements.\\nFor example, the FillBids and FillAsks endpoints are available if and only if this is true.\\nThe MarketSettle endpoint is only available to market actors regardless of the value of this field."},"access_grants":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address is the address that these permissions apply to."},"permissions":{"type":"array","items":{"type":"string","enum":["PERMISSION_UNSPECIFIED","PERMISSION_SETTLE","PERMISSION_SET_IDS","PERMISSION_CANCEL","PERMISSION_WITHDRAW","PERMISSION_UPDATE","PERMISSION_PERMISSIONS","PERMISSION_ATTRIBUTES"],"default":"PERMISSION_UNSPECIFIED","description":"Permission defines the different types of permission that can be given to an account for a market.\\n\\n - PERMISSION_UNSPECIFIED: PERMISSION_UNSPECIFIED is the zero-value Permission; it is an error to use it.\\n - PERMISSION_SETTLE: PERMISSION_SETTLE is the ability to use the Settle Tx endpoint on behalf of a market.\\n - PERMISSION_SET_IDS: PERMISSION_SET_IDS is the ability to use the SetOrderExternalID Tx endpoint on behalf of a market.\\n - PERMISSION_CANCEL: PERMISSION_CANCEL is the ability to use the Cancel Tx endpoint on behalf of a market.\\n - PERMISSION_WITHDRAW: PERMISSION_WITHDRAW is the ability to use the MarketWithdraw Tx endpoint.\\n - PERMISSION_UPDATE: PERMISSION_UPDATE is the ability to use the MarketUpdate* Tx endpoints.\\n - PERMISSION_PERMISSIONS: PERMISSION_PERMISSIONS is the ability to use the MarketManagePermissions Tx endpoint.\\n - PERMISSION_ATTRIBUTES: PERMISSION_ATTRIBUTES is the ability to use the MarketManageReqAttrs Tx endpoint."},"description":"allowed is the list of permissions available for the address."}},"description":"AddrPermissions associates an address with a list of permissions available for that address."},"description":"access_grants is the list of addresses and permissions granted for this market."},"req_attr_create_ask":{"type":"array","items":{"type":"string"},"description":"req_attr_create_ask is a list of attributes required on an account for it to be allowed to create an ask order.\\nAn account must have all of these attributes in order to create an ask order in this market.\\nIf the list is empty, any account can create ask orders in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"b.x.a\\", or \\"c.b.a.x\\"."},"req_attr_create_bid":{"type":"array","items":{"type":"string"},"description":"req_attr_create_ask is a list of attributes required on an account for it to be allowed to create a bid order.\\nAn account must have all of these attributes in order to create a bid order in this market.\\nIf the list is empty, any account can create bid orders in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"c.b.x.a\\", or \\"c.b.a.x\\"."},"accepting_commitments":{"type":"boolean","format":"boolean","description":"accepting_commitments is whether the market is allowing users to commit funds to it."},"fee_create_commitment_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_create_commitment_flat is the flat fee charged for creating a commitment.\\nEach coin entry is a separate option. When a commitment is created, one of these must be paid.\\nIf empty, no fee is required to create a commitment."},"commitment_settlement_bips":{"type":"integer","format":"int64","description":"commitment_settlement_bips is the fraction of a commitment settlement that will be paid to the exchange.\\nIt is represented in basis points (1/100th of 1%, e.g. 0.0001) and is limited to 0 to 10,000 inclusive.\\nDuring a commitment settlement, the inputs are summed and NAVs are used to convert that total to the\\nintermediary denom, then to the fee denom. That is then multiplied by this value to get the fee amount\\nthat will be transferred out of the market\'s account into the exchange for that settlement.\\n\\nSumming the inputs effectively doubles the value of the settlement from what what is usually thought of\\nas the value of a trade. That should be taken into account when setting this value.\\nE.g. if two accounts are trading 10apples for 100grapes, the inputs total will be 10apples,100grapes\\n(which might then be converted to USD then nhash before applying this ratio); Usually, though, the value\\nof that trade would be viewed as either just 10apples or just 100grapes."},"intermediary_denom":{"type":"string","description":"intermediary_denom is the denom that funds get converted to (before being converted to the chain\'s fee denom)\\nwhen calculating the fees that are paid to the exchange. NAVs are used for this conversion and actions will fail\\nif a NAV is needed but not available."},"req_attr_create_commitment":{"type":"array","items":{"type":"string"},"description":"req_attr_create_commitment is a list of attributes required on an account for it to be allowed to create a\\ncommitment. An account must have all of these attributes in order to create a commitment in this market.\\nIf the list is empty, any account can create commitments in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"c.b.x.a\\", or \\"c.b.a.x\\"."}}}},"description":"QueryGetMarketResponse is a response message for the GetMarket query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"market_id","description":"market_id is the id of the market to look up.","in":"path","required":true,"schema":{"type":"integer","format":"int64"}}],"tags":["Query"]}},"/provenance/exchange/v1/market/{market_id}/commitment/{account}":{"get":{"summary":"GetCommitment gets the funds in an account that are committed to the market.","operationId":"GetCommitment","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the total funds committed to the market by the account."}},"description":"QueryGetCommitmentResponse is a response message for the GetCommitment query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"market_id","description":"market_id is the numeric identifier of the market in the commitment.","in":"path","required":true,"schema":{"type":"integer","format":"int64"}},{"name":"account","description":"account is the bech32 address string of the account in the commitment.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/exchange/v1/market/{market_id}/commitments":{"get":{"summary":"GetMarketCommitments gets all the funds committed to a market from any account.","operationId":"GetMarketCommitments2","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"commitments":{"type":"array","items":{"type":"object","properties":{"account":{"type":"string","description":"account is the bech32 address string of the account associated with the amount."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds associated with the address."}},"description":"AccountAmount associates an account with a coins amount."},"description":"commitments is the amounts committed to the market from any account."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetMarketCommitmentsResponse is a response message for the GetMarketCommitments query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"market_id","description":"market_id is the numeric identifier of the market with the commitment.","in":"path","required":true,"schema":{"type":"integer","format":"int64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/exchange/v1/market/{market_id}/order/{external_id}":{"get":{"summary":"GetOrderByExternalID looks up an order by market id and external id.","operationId":"GetOrderByExternalID2","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"order":{"description":"order is the requested order.","type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}}}},"description":"QueryGetOrderByExternalIDResponse is a response message for the GetOrderByExternalID query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"market_id","description":"market_id is the id of the market that\'s expected to have the order.","in":"path","required":true,"schema":{"type":"integer","format":"int64"}},{"name":"external_id","description":"external_id the external id to look up.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/exchange/v1/market/{market_id}/orders":{"get":{"summary":"GetMarketOrders looks up the orders in a market.","operationId":"GetMarketOrders2","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"orders":{"type":"array","items":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}},"description":"Order associates an order id with one of the order types."},"description":"orders are a page of the orders in the provided market."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetMarketOrdersResponse is a response message for the GetMarketOrders query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"market_id","description":"market_id is the id of the market to get all the orders for.","in":"path","required":true,"schema":{"type":"integer","format":"int64"}},{"name":"order_type","description":"order_type is optional and can limit orders to only \\"ask\\" or \\"bid\\" orders.","in":"query","required":false,"schema":{"type":"string"}},{"name":"after_order_id","description":"after_order_id is a minimum (exclusive) order id. All results will be strictly greater than this.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/exchange/v1/market/{market_id}/validate":{"get":{"summary":"ValidateMarket checks for any problems with a market\'s setup.","operationId":"ValidateMarket2","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string","description":"error is any problems or inconsistencies in the provided market."}},"description":"QueryValidateMarketResponse is a response message for the ValidateMarket query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"market_id","description":"market_id is the id of the market to check.","in":"path","required":true,"schema":{"type":"integer","format":"int64"}}],"tags":["Query"]}},"/provenance/exchange/v1/markets":{"get":{"summary":"GetAllMarkets returns brief information about each market.","operationId":"GetAllMarkets","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"markets":{"type":"array","items":{"type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id is the numerical identifier for this market."},"market_address":{"type":"string","description":"market_address is the bech32 address string of this market\'s account."},"market_details":{"description":"market_details is some information about this market.","type":"object","properties":{"name":{"type":"string","description":"name is a moniker that people can use to refer to this market."},"description":{"type":"string","description":"description extra information about this market. The field is meant to be human-readable."},"website_url":{"type":"string","description":"website_url is a url people can use to get to this market, or at least get more information about this market."},"icon_uri":{"type":"string","description":"icon_uri is a uri for an icon to associate with this market."}}}},"description":"MarketBrief is a message containing brief, superficial information about a market."},"description":"markets are a page of the briefs for all markets."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetAllMarketsResponse is a response message for the GetAllMarkets query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/exchange/v1/order/{order_id}":{"get":{"summary":"GetOrder looks up an order by id.","operationId":"GetOrder","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"order":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}},"description":"Order associates an order id with one of the order types."}},"description":"QueryGetOrderResponse is a response message for the GetOrder query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"order_id","description":"order_id is the id of the order to look up.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}}],"tags":["Query"]}},"/provenance/exchange/v1/orders":{"get":{"summary":"GetAllOrders gets all orders in the exchange module.","operationId":"GetAllOrders","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"orders":{"type":"array","items":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}},"description":"Order associates an order id with one of the order types."},"description":"orders are a page of the all orders."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetAllOrdersResponse is a response message for the GetAllOrders query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/exchange/v1/orders/asset/{asset}":{"get":{"summary":"GetAssetOrders looks up the orders for a specific asset denom.","operationId":"GetAssetOrders","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"orders":{"type":"array","items":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}},"description":"Order associates an order id with one of the order types."},"description":"orders are a page of the orders for the provided asset."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetAssetOrdersResponse is a response message for the GetAssetOrders query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"asset","description":"asset is the denom of assets to get orders for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"order_type","description":"order_type is optional and can limit orders to only \\"ask\\" or \\"bid\\" orders.","in":"query","required":false,"schema":{"type":"string"}},{"name":"after_order_id","description":"after_order_id is a minimum (exclusive) order id. All results will be strictly greater than this.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/exchange/v1/orders/market/{market_id}":{"get":{"summary":"GetMarketOrders looks up the orders in a market.","operationId":"GetMarketOrders","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"orders":{"type":"array","items":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}},"description":"Order associates an order id with one of the order types."},"description":"orders are a page of the orders in the provided market."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetMarketOrdersResponse is a response message for the GetMarketOrders query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"market_id","description":"market_id is the id of the market to get all the orders for.","in":"path","required":true,"schema":{"type":"integer","format":"int64"}},{"name":"order_type","description":"order_type is optional and can limit orders to only \\"ask\\" or \\"bid\\" orders.","in":"query","required":false,"schema":{"type":"string"}},{"name":"after_order_id","description":"after_order_id is a minimum (exclusive) order id. All results will be strictly greater than this.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/exchange/v1/orders/market/{market_id}/{external_id}":{"get":{"summary":"GetOrderByExternalID looks up an order by market id and external id.","operationId":"GetOrderByExternalID","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"order":{"description":"order is the requested order.","type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}}}},"description":"QueryGetOrderByExternalIDResponse is a response message for the GetOrderByExternalID query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"market_id","description":"market_id is the id of the market that\'s expected to have the order.","in":"path","required":true,"schema":{"type":"integer","format":"int64"}},{"name":"external_id","description":"external_id the external id to look up.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/exchange/v1/orders/owner/{owner}":{"get":{"summary":"GetOwnerOrders looks up the orders from the provided owner address.","operationId":"GetOwnerOrders","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"orders":{"type":"array","items":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}},"description":"Order associates an order id with one of the order types."},"description":"orders are a page of the orders for the provided address."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetOwnerOrdersResponse is a response message for the GetOwnerOrders query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"owner","description":"owner is the bech32 address string of the owner to get the orders for.","in":"path","required":true,"schema":{"type":"string"}},{"name":"order_type","description":"order_type is optional and can limit orders to only \\"ask\\" or \\"bid\\" orders.","in":"query","required":false,"schema":{"type":"string"}},{"name":"after_order_id","description":"after_order_id is a minimum (exclusive) order id. All results will be strictly greater than this.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/exchange/v1/params":{"get":{"summary":"Params returns the exchange module parameters.","operationId":"ExchangeParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"description":"params are the exchange module parameter values.","type":"object","properties":{"default_split":{"type":"integer","format":"int64","description":"default_split is the default proportion of fees the exchange receives in basis points.\\nIt is used if there isn\'t an applicable denom-specific split defined.\\nE.g. 100 = 1%. Min = 0, Max = 10000."},"denom_splits":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string","description":"denom is the coin denomination this split applies to."},"split":{"type":"integer","format":"int64","description":"split is the proportion of fees the exchange receives for this denom in basis points.\\nE.g. 100 = 1%. Min = 0, Max = 10000."}},"description":"DenomSplit associates a coin denomination with an amount the exchange receives for that denom."},"description":"denom_splits are the denom-specific amounts the exchange receives."}}}},"description":"QueryParamsResponse is a response message for the Params query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"tags":["Query"]}},"/provenance/exchange/v1/validate/create_market":{"get":{"summary":"ValidateCreateMarket checks the provided MsgGovCreateMarketResponse and returns any errors it might have.","operationId":"ValidateCreateMarket","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string","description":"error is any problems or inconsistencies in the provided gov prop msg.\\nThis goes above and beyond the validation done when actually processing the governance proposal.\\nIf an error is returned, and gov_prop_will_pass is true, it means the error is more of an\\ninconsistency that might cause certain aspects of the market to behave unexpectedly."},"gov_prop_will_pass":{"type":"boolean","format":"boolean","description":"gov_prop_will_pass will be true if the the provided msg will be successfully processed at the end of it\'s voting\\nperiod (assuming it passes)."}},"description":"QueryValidateCreateMarketResponse is a response message for the ValidateCreateMarket query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"create_market_request.authority","description":"authority should be the governance module account address.","in":"query","required":false,"schema":{"type":"string"}},{"name":"create_market_request.market.market_id","description":"market_id is the numerical identifier for this market.","in":"query","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"create_market_request.market.market_details.name","description":"name is a moniker that people can use to refer to this market.","in":"query","required":false,"schema":{"type":"string"}},{"name":"create_market_request.market.market_details.description","description":"description extra information about this market. The field is meant to be human-readable.","in":"query","required":false,"schema":{"type":"string"}},{"name":"create_market_request.market.market_details.website_url","description":"website_url is a url people can use to get to this market, or at least get more information about this market.","in":"query","required":false,"schema":{"type":"string"}},{"name":"create_market_request.market.market_details.icon_uri","description":"icon_uri is a uri for an icon to associate with this market.","in":"query","required":false,"schema":{"type":"string"}},{"name":"create_market_request.market.accepting_orders","description":"accepting_orders is whether this market is allowing orders to be created for it.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"create_market_request.market.allow_user_settlement","description":"allow_user_settlement is whether this market allows users to initiate their own settlements.\\nFor example, the FillBids and FillAsks endpoints are available if and only if this is true.\\nThe MarketSettle endpoint is only available to market actors regardless of the value of this field.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"create_market_request.market.req_attr_create_ask","description":"req_attr_create_ask is a list of attributes required on an account for it to be allowed to create an ask order.\\nAn account must have all of these attributes in order to create an ask order in this market.\\nIf the list is empty, any account can create ask orders in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"b.x.a\\", or \\"c.b.a.x\\".","in":"query","required":false,"explode":true,"schema":{"type":"array","items":{"type":"string"}}},{"name":"create_market_request.market.req_attr_create_bid","description":"req_attr_create_ask is a list of attributes required on an account for it to be allowed to create a bid order.\\nAn account must have all of these attributes in order to create a bid order in this market.\\nIf the list is empty, any account can create bid orders in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"c.b.x.a\\", or \\"c.b.a.x\\".","in":"query","required":false,"explode":true,"schema":{"type":"array","items":{"type":"string"}}},{"name":"create_market_request.market.accepting_commitments","description":"accepting_commitments is whether the market is allowing users to commit funds to it.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"create_market_request.market.commitment_settlement_bips","description":"commitment_settlement_bips is the fraction of a commitment settlement that will be paid to the exchange.\\nIt is represented in basis points (1/100th of 1%, e.g. 0.0001) and is limited to 0 to 10,000 inclusive.\\nDuring a commitment settlement, the inputs are summed and NAVs are used to convert that total to the\\nintermediary denom, then to the fee denom. That is then multiplied by this value to get the fee amount\\nthat will be transferred out of the market\'s account into the exchange for that settlement.\\n\\nSumming the inputs effectively doubles the value of the settlement from what what is usually thought of\\nas the value of a trade. That should be taken into account when setting this value.\\nE.g. if two accounts are trading 10apples for 100grapes, the inputs total will be 10apples,100grapes\\n(which might then be converted to USD then nhash before applying this ratio); Usually, though, the value\\nof that trade would be viewed as either just 10apples or just 100grapes.","in":"query","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"create_market_request.market.intermediary_denom","description":"intermediary_denom is the denom that funds get converted to (before being converted to the chain\'s fee denom)\\nwhen calculating the fees that are paid to the exchange. NAVs are used for this conversion and actions will fail\\nif a NAV is needed but not available.","in":"query","required":false,"schema":{"type":"string"}},{"name":"create_market_request.market.req_attr_create_commitment","description":"req_attr_create_commitment is a list of attributes required on an account for it to be allowed to create a\\ncommitment. An account must have all of these attributes in order to create a commitment in this market.\\nIf the list is empty, any account can create commitments in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"c.b.x.a\\", or \\"c.b.a.x\\".","in":"query","required":false,"explode":true,"schema":{"type":"array","items":{"type":"string"}}}],"tags":["Query"]}},"/provenance/exchange/v1/validate/manage_fees":{"get":{"summary":"ValidateManageFees checks the provided MsgGovManageFeesRequest and returns any errors that it might have.","operationId":"ValidateManageFees","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string","description":"error is any problems or inconsistencies in the provided gov prop msg.\\nThis goes above and beyond the validation done when actually processing the governance proposal.\\nIf an error is returned, and gov_prop_will_pass is true, it means the error is more of an\\ninconsistency that might cause certain aspects of the market to behave unexpectedly."},"gov_prop_will_pass":{"type":"boolean","format":"boolean","description":"gov_prop_will_pass will be true if the the provided msg will be successfully processed at the end of it\'s voting\\nperiod (assuming it passes)."}},"description":"QueryValidateManageFeesResponse is a response message for the ValidateManageFees query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"manage_fees_request.authority","description":"authority should be the governance module account address.","in":"query","required":false,"schema":{"type":"string"}},{"name":"manage_fees_request.market_id","description":"market_id is the market id that will get these fee updates.","in":"query","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"manage_fees_request.set_fee_commitment_settlement_bips","description":"set_fee_commitment_settlement_bips is the new fee_commitment_settlement_bips for the market.\\nIt is ignored if it is zero. To set it to zero set unset_fee_commitment_settlement_bips to true.","in":"query","required":false,"schema":{"type":"integer","format":"int64"}},{"name":"manage_fees_request.unset_fee_commitment_settlement_bips","description":"unset_fee_commitment_settlement_bips, if true, sets the fee_commitment_settlement_bips to zero.\\nIf false, it is ignored.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/exchange/v1/validate/market/{market_id}":{"get":{"summary":"ValidateMarket checks for any problems with a market\'s setup.","operationId":"ValidateMarket","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string","description":"error is any problems or inconsistencies in the provided market."}},"description":"QueryValidateMarketResponse is a response message for the ValidateMarket query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"market_id","description":"market_id is the id of the market to check.","in":"path","required":true,"schema":{"type":"integer","format":"int64"}}],"tags":["Query"]}},"/provenance/hold/v1/funds":{"get":{"summary":"GetAllHolds returns all addresses with funds on hold, and the amount held.","operationId":"GetAllHolds","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"holds":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address is the account address that holds the funds on hold."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the balances that are on hold for the address."}},"description":"AccountHold associates an address with an amount on hold for that address."},"description":"holds is a list of addresses with funds on hold and the amounts being held."},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"GetAllHoldsResponse is the response type for the Query/GetAllHolds query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/hold/v1/funds/{address}":{"get":{"summary":"GetHolds looks up the funds that are on hold for an address.","operationId":"GetHolds","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the total on hold for the requested address."}},"description":"GetHoldsResponse is the response type for the Query/GetHolds query."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"address","description":"address is the account address to get on-hold balances for.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/ibcratelimit/v1/params":{"get":{"summary":"Params defines a gRPC query method that returns the ibcratelimit module\'s\\nparameters.","operationId":"IBCRateLimitParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"contract_address":{"type":"string","description":"contract_address is the address of the rate limiter contract."}}}},"description":"ParamsResponse is the response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/provenance/marker/v1/accesscontrol/{id}":{"get":{"summary":"query for access records on an account","operationId":"Access","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"accounts":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string"},"permissions":{"type":"array","items":{"type":"string","enum":["ACCESS_UNSPECIFIED","ACCESS_MINT","ACCESS_BURN","ACCESS_DEPOSIT","ACCESS_WITHDRAW","ACCESS_DELETE","ACCESS_ADMIN","ACCESS_TRANSFER","ACCESS_FORCE_TRANSFER"],"default":"ACCESS_UNSPECIFIED","description":"Access defines the different types of permissions that a marker supports granting to an address.\\n\\n - ACCESS_UNSPECIFIED: ACCESS_UNSPECIFIED defines a no-op vote option.\\n - ACCESS_MINT: ACCESS_MINT is the ability to increase the supply of a marker.\\n - ACCESS_BURN: ACCESS_BURN is the ability to decrease the supply of the marker using coin held by the marker.\\n - ACCESS_DEPOSIT: ACCESS_DEPOSIT is the ability to transfer funds from another account to this marker account\\nor to set a reference to this marker in the metadata/scopes module.\\n - ACCESS_WITHDRAW: ACCESS_WITHDRAW is the ability to transfer funds from this marker account to another account\\nor to remove a reference to this marker in the metadata/scopes module.\\n - ACCESS_DELETE: ACCESS_DELETE is the ability to move a proposed, finalized or active marker into the cancelled state.\\nThis access also allows cancelled markers to be marked for deletion.\\n - ACCESS_ADMIN: ACCESS_ADMIN is the ability to add access grants for accounts to the list of marker permissions.\\nThis access also gives the ability to update the marker\'s denom metadata.\\n - ACCESS_TRANSFER: ACCESS_TRANSFER is the ability to manage transfer settings and broker transfers of the marker.\\nAccounts with this access can:\\n - Update the marker\'s required attributes.\\n - Update the send-deny list.\\n - Use the transfer or bank send endpoints to move marker funds out of their own account.\\nThis access right is only supported on RESTRICTED markers.\\n - ACCESS_FORCE_TRANSFER: ACCESS_FORCE_TRANSFER is the ability to transfer restricted coins from a 3rd-party account without their signature.\\nThis access right is only supported on RESTRICTED markers and only has meaning when allow_forced_transfer is true."}}},"description":"AccessGrant associates a collection of permissions with an address for delegated marker account control."}}},"description":"QueryAccessResponse is the response type for the Query/MarkerAccess method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"id","description":"address or denom for the marker","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/marker/v1/accountdata/{denom}":{"get":{"summary":"query for account data associated with a denom","operationId":"MarkerAccountData","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"value":{"type":"string","description":"The accountdata for the requested denom."}},"title":"QueryAccountDataResponse is the response type for the Query/AccountData"}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"denom","description":"The denomination to look up.","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/marker/v1/all":{"get":{"summary":"Returns a list of all markers on the blockchain","operationId":"AllMarkers","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"markers":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAllMarkersResponse is the response type for the Query/AllMarkers method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"status","description":"Optional status to filter request.\\n\\n - MARKER_STATUS_UNSPECIFIED: MARKER_STATUS_UNSPECIFIED - Unknown/Invalid Marker Status\\n - MARKER_STATUS_PROPOSED: MARKER_STATUS_PROPOSED - Initial configuration period, updates allowed, token supply not created.\\n - MARKER_STATUS_FINALIZED: MARKER_STATUS_FINALIZED - Configuration finalized, ready for supply creation\\n - MARKER_STATUS_ACTIVE: MARKER_STATUS_ACTIVE - Supply is created, rules are in force.\\n - MARKER_STATUS_CANCELLED: MARKER_STATUS_CANCELLED - Marker has been cancelled, pending destroy\\n - MARKER_STATUS_DESTROYED: MARKER_STATUS_DESTROYED - Marker supply has all been recalled, marker is considered destroyed and no further\\nactions allowed.","in":"query","required":false,"schema":{"type":"string","enum":["MARKER_STATUS_UNSPECIFIED","MARKER_STATUS_PROPOSED","MARKER_STATUS_FINALIZED","MARKER_STATUS_ACTIVE","MARKER_STATUS_CANCELLED","MARKER_STATUS_DESTROYED"],"default":"MARKER_STATUS_UNSPECIFIED"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/marker/v1/detail/{id}":{"get":{"summary":"query for a single marker by denom or address","operationId":"Marker","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"marker":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"description":"QueryMarkerResponse is the response type for the Query/Marker method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"id","description":"the address or denom of the marker","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/marker/v1/escrow/{id}":{"get":{"summary":"query for coins on a marker account","operationId":"Escrow","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"escrow":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}}},"description":"QueryEscrowResponse is the response type for the Query/MarkerEscrow method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"id","description":"address or denom for the marker","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/marker/v1/getdenommetadata/{denom}":{"get":{"summary":"query for access records on an account","operationId":"MarkerDenomMetadata","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"metadata":{"type":"object","properties":{"description":{"type":"string"},"denom_units":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string","description":"denom represents the string name of the given denom unit (e.g uatom)."},"exponent":{"type":"integer","format":"int64","description":"exponent represents power of 10 exponent that one must\\nraise the base_denom to in order to equal the given DenomUnit\'s denom\\n1 denom = 10^exponent base_denom\\n(e.g. with a base_denom of uatom, one can create a DenomUnit of \'atom\' with\\nexponent = 6, thus: 1 atom = 10^6 uatom)."},"aliases":{"type":"array","items":{"type":"string"},"title":"aliases is a list of string aliases for the given denom"}},"description":"DenomUnit represents a struct that describes a given\\ndenomination unit of the basic token."},"title":"denom_units represents the list of DenomUnit\'s for a given coin"},"base":{"type":"string","description":"base represents the base denom (should be the DenomUnit with exponent = 0)."},"display":{"type":"string","description":"display indicates the suggested denom that should be\\ndisplayed in clients."},"name":{"type":"string","description":"Since: cosmos-sdk 0.43","title":"name defines the name of the token (eg: Cosmos Atom)"},"symbol":{"type":"string","description":"symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\\nbe the same as the display.\\n\\nSince: cosmos-sdk 0.43"},"uri":{"type":"string","description":"URI to a document (on or off-chain) that contains additional information. Optional.\\n\\nSince: cosmos-sdk 0.46"},"uri_hash":{"type":"string","description":"URIHash is a sha256 hash of a document pointed by URI. It\'s used to verify that\\nthe document didn\'t change. Optional.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Metadata represents a struct that describes\\na basic token."}},"title":"QueryDenomMetadataResponse is the response type for the Query/DenomMetadata"}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"denom","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/marker/v1/holding/{id}":{"get":{"summary":"query for all accounts holding the given marker coins","operationId":"Holding","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"balances":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address is the address of the balance holder."},"coins":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"coins defines the different coins this balance holds."}},"title":"Balance defines an account address and balance pair used in queries for accounts holding a marker"}},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryHoldingResponse is the response type for the Query/MarkerHolders method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"id","description":"the address or denom of the marker","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/marker/v1/netassetvalues/{id}":{"get":{"summary":"NetAssetValues returns net asset values for marker","operationId":"NetAssetValues","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"net_asset_values":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto.","title":"price is the complete value of the asset\'s volume"},"volume":{"type":"string","format":"uint64","title":"volume is the number of tokens of the marker that were purchased for the price"},"updated_block_height":{"type":"string","format":"uint64","title":"updated_block_height is the block height of last update"}},"title":"NetAssetValue defines a marker\'s net asset value"},"title":"net asset values for marker denom"}},"description":"QueryNetAssetValuesRequest is the response type for the Query/NetAssetValues method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"id","description":"address or denom for the marker","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/marker/v1/params":{"get":{"summary":"Params queries the parameters of x/bank module.","operationId":"MarkerParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"max_total_supply":{"type":"string","format":"uint64","title":"Deprecated: Prefer to use `max_supply` instead. Maximum amount of supply to allow a marker to be created with"},"enable_governance":{"type":"boolean","format":"boolean","description":"indicates if governance based controls of markers is allowed."},"unrestricted_denom_regex":{"type":"string","title":"a regular expression used to validate marker denom values from normal create requests (governance\\nrequests are only subject to platform coin validation denom expression)"},"max_supply":{"type":"string","title":"maximum amount of supply to allow a marker to be created with"}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"tags":["Query"]}},"/provenance/marker/v1/supply/{id}":{"get":{"summary":"query for supply of coin on a marker account","operationId":"Supply","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"amount":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"QuerySupplyResponse is the response type for the Query/MarkerSupply method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"id","description":"address or denom for the marker","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/metadata/v1/accountdata/{metadata_addr}":{"get":{"summary":"AccountData gets the account data associated with a metadata address.\\nCurrently, only scope ids are supported.","operationId":"MetadataAccountData","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"value":{"type":"string","description":"The accountdata for the requested metadata address."}},"description":"AccountDataResponse is the response type for the Query/AccountData RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"metadata_addr","description":"The metadata address to look up.\\nCurrently, only scope ids are supported.","in":"path","required":true,"schema":{"type":"string","format":"byte"}}],"tags":["Query"]}},"/provenance/metadata/v1/addr/{addrs}":{"get":{"summary":"GetByAddr retrieves metadata given any address(es).","operationId":"GetByAddr","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scopes":{"type":"array","items":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"description":"scopes contains any scopes that were requested and found."},"sessions":{"type":"array","items":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"description":"sessions contains any sessions that were requested and found."},"records":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract"},"description":"records contains any records that were requested and found."},"scope_specs":{"type":"array","items":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"description":"General information about this scope specification.","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}}},"owner_addresses":{"type":"array","items":{"type":"string"},"description":"Addresses of the owners of this scope specification."},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"A list of parties that must be present on a scope (and their associated roles)"},"contract_spec_ids":{"type":"array","items":{"type":"string","format":"byte"},"description":"A list of contract specification ids allowed for a scope based on this specification."}},"title":"ScopeSpecification defines the required parties, resources, conditions, and consideration outputs for a contract"},"description":"scope_specs contains any scope specifications that were requested and found."},"contract_specs":{"type":"array","items":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"title":"Description information for this contract specification","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}},"description":"Description holds general information that is handy to associate with a structure."},"owner_addresses":{"type":"array","items":{"type":"string"},"title":"Address of the account that owns this specificaiton"},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"a list of party roles that must be fullfilled when signing a transaction for this contract specification"},"resource_id":{"type":"string","format":"byte","title":"the address of a record on chain that represents this contract"},"hash":{"type":"string","title":"the hash of contract binary (off-chain instance)"},"class_name":{"type":"string","title":"name of the class/type of this contract executable"}},"title":"ContractSpecification defines the required parties, resources, conditions, and consideration outputs for a contract"},"description":"contract_specs contains any contract specifications that were requested and found."},"record_specs":{"type":"array","items":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs"},"description":"record_specs contains any record specifications that were requested and found."},"not_found":{"type":"array","items":{"type":"string"},"description":"not_found contains any addrs requested but not found."}},"description":"GetByAddrResponse is the response type for the Query/GetByAddr RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"addrs","description":"ids are the metadata addresses of the things to look up.","in":"path","required":true,"style":"simple","schema":{"type":"array","items":{"type":"string"},"minItems":1}}],"tags":["Query"]}},"/provenance/metadata/v1/contractspec/{specification_id}":{"get":{"summary":"ContractSpecification returns a contract specification for the given specification id.","description":"The specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84, a bech32 contract\\nspecification address, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn, or a bech32 record specification\\naddress, e.g. recspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44. If it is a record specification\\naddress, then the contract specification that contains that record specification is looked up.\\n\\nBy default, the record specifications for this contract specification are not included.\\nSet include_record_specs to true to include them in the result.","operationId":"ContractSpecification","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"contract_specification":{"description":"contract_specification is the wrapped contract specification.","type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"title":"Description information for this contract specification","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}},"description":"Description holds general information that is handy to associate with a structure."},"owner_addresses":{"type":"array","items":{"type":"string"},"title":"Address of the account that owns this specificaiton"},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"a list of party roles that must be fullfilled when signing a transaction for this contract specification"},"resource_id":{"type":"string","format":"byte","title":"the address of a record on chain that represents this contract"},"hash":{"type":"string","title":"the hash of contract binary (off-chain instance)"},"class_name":{"type":"string","title":"name of the class/type of this contract executable"}},"title":"ContractSpecification defines the required parties, resources, conditions, and consideration outputs for a contract","description":"specification is the on-chain contract specification message."},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}},"record_specifications":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs","description":"specification is the on-chain record specification message."},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordSpecificationWrapper contains a single record specification and some extra identifiers for it."},"description":"record_specifications is any number or wrapped record specifications associated with this contract_specification\\n(if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44."},"include_record_specs":{"type":"boolean","format":"boolean","description":"include_record_specs is a flag for whether to include the the record specifications of this contract specification\\nin the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"ContractSpecificationResponse is the response type for the Query/ContractSpecification RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"specification_id","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44.","in":"path","required":true,"schema":{"type":"string"}},{"name":"include_record_specs","description":"include_record_specs is a flag for whether to include the the record specifications of this contract specification\\nin the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/contractspec/{specification_id}/recordspec/{name}":{"get":{"summary":"RecordSpecification returns a record specification for the given input.","operationId":"RecordSpecification2","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"record_specification":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs","description":"specification is the on-chain record specification message."},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordSpecificationWrapper contains a single record specification and some extra identifiers for it."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44."},"name":{"type":"string","description":"name is the name of the record to look up.\\nIt is required if the specification_id is a uuid or contract specification address.\\nIt is ignored if the specification_id is a record specification address."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordSpecificationResponse is the response type for the Query/RecordSpecification RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"specification_id","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44.","in":"path","required":true,"schema":{"type":"string"}},{"name":"name","description":"name is the name of the record to look up.\\nIt is required if the specification_id is a uuid or contract specification address.\\nIt is ignored if the specification_id is a record specification address.","in":"path","required":true,"schema":{"type":"string"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/contractspec/{specification_id}/recordspecs":{"get":{"summary":"RecordSpecificationsForContractSpecification returns the record specifications for the given input.","description":"The specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84, a bech32 contract\\nspecification address, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn, or a bech32 record specification\\naddress, e.g. recspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44. If it is a record specification\\naddress, then the contract specification that contains that record specification is used.","operationId":"RecordSpecificationsForContractSpecification","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"record_specifications":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs","description":"specification is the on-chain record specification message."},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordSpecificationWrapper contains a single record specification and some extra identifiers for it."},"description":"record_specifications is any number of wrapped record specifications associated with this contract_specification."},"contract_specification_uuid":{"type":"string","description":"contract_specification_uuid is the uuid of this contract specification."},"contract_specification_addr":{"type":"string","description":"contract_specification_addr is the contract specification address as a bech32 encoded string."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordSpecificationsForContractSpecificationResponse is the response type for the\\nQuery/RecordSpecificationsForContractSpecification RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"specification_id","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44.","in":"path","required":true,"schema":{"type":"string"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/contractspecs/all":{"get":{"summary":"ContractSpecificationsAll retrieves all contract specifications.","operationId":"ContractSpecificationsAll","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"contract_specifications":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"title":"Description information for this contract specification","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}},"description":"Description holds general information that is handy to associate with a structure."},"owner_addresses":{"type":"array","items":{"type":"string"},"title":"Address of the account that owns this specificaiton"},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"a list of party roles that must be fullfilled when signing a transaction for this contract specification"},"resource_id":{"type":"string","format":"byte","title":"the address of a record on chain that represents this contract"},"hash":{"type":"string","title":"the hash of contract binary (off-chain instance)"},"class_name":{"type":"string","title":"name of the class/type of this contract executable"}},"title":"ContractSpecification defines the required parties, resources, conditions, and consideration outputs for a contract","description":"specification is the on-chain contract specification message."},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"ContractSpecificationWrapper contains a single contract specification and some extra identifiers for it."},"description":"contract_specifications are the wrapped contract specifications."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"ContractSpecificationsAllResponse is the response type for the Query/ContractSpecificationsAll RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/locator/params":{"get":{"summary":"OSLocatorParams returns all parameters for the object store locator sub module.","operationId":"OSLocatorParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"max_uri_length":{"type":"integer","format":"int64"}}},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"OSLocatorParamsResponse is the response type for the Query/OSLocatorParams RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/locator/scope/{scope_id}":{"get":{"summary":"OSLocatorsByScope returns all ObjectStoreLocator entries for a for all signer\'s present in the specified scope.","operationId":"OSLocatorsByScope","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"locators":{"type":"array","items":{"type":"object","properties":{"owner":{"type":"string","title":"account address the endpoint is owned by"},"locator_uri":{"type":"string","title":"locator endpoint uri"},"encryption_key":{"type":"string","title":"owners encryption key address"}},"description":"Defines an Locator object stored on chain, which represents a owner( blockchain address) associated with a endpoint\\nuri for it\'s associated object store."}},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"scope_id":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"OSLocatorsByScopeResponse is the response type for the Query/OSLocatorsByScope RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"scope_id","in":"path","required":true,"schema":{"type":"string"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/locator/uri/{uri}":{"get":{"summary":"OSLocatorsByURI returns all ObjectStoreLocator entries for a locator uri.","operationId":"OSLocatorsByURI","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"locators":{"type":"array","items":{"type":"object","properties":{"owner":{"type":"string","title":"account address the endpoint is owned by"},"locator_uri":{"type":"string","title":"locator endpoint uri"},"encryption_key":{"type":"string","title":"owners encryption key address"}},"description":"Defines an Locator object stored on chain, which represents a owner( blockchain address) associated with a endpoint\\nuri for it\'s associated object store."}},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"uri":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"OSLocatorsByURIResponse is the response type for the Query/OSLocatorsByURI RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"uri","in":"path","required":true,"schema":{"type":"string"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/locator/{owner}":{"get":{"summary":"OSLocator returns an ObjectStoreLocator by its owner\'s address.","operationId":"OSLocator","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"locator":{"type":"object","properties":{"owner":{"type":"string","title":"account address the endpoint is owned by"},"locator_uri":{"type":"string","title":"locator endpoint uri"},"encryption_key":{"type":"string","title":"owners encryption key address"}},"description":"Defines an Locator object stored on chain, which represents a owner( blockchain address) associated with a endpoint\\nuri for it\'s associated object store."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"owner":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"OSLocatorResponse is the response type for the Query/OSLocator RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"owner","in":"path","required":true,"schema":{"type":"string"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/locators/all":{"get":{"summary":"OSAllLocators returns all ObjectStoreLocator entries.","operationId":"OSAllLocators","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"locators":{"type":"array","items":{"type":"object","properties":{"owner":{"type":"string","title":"account address the endpoint is owned by"},"locator_uri":{"type":"string","title":"locator endpoint uri"},"encryption_key":{"type":"string","title":"owners encryption key address"}},"description":"Defines an Locator object stored on chain, which represents a owner( blockchain address) associated with a endpoint\\nuri for it\'s associated object store."}},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"OSAllLocatorsResponse is the response type for the Query/OSAllLocators RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/netassetvalues/{id}":{"get":{"summary":"ScopeNetAssetValues returns net asset values for scope","operationId":"ScopeNetAssetValues","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"net_asset_values":{"type":"array","items":{"type":"object","properties":{"price":{"title":"price is the complete value of the asset\'s volume","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"updated_block_height":{"type":"string","format":"uint64","title":"updated_block_height is the block height of last update"}},"title":"NetAssetValue defines a scope\'s net asset value"},"title":"net asset values for scope"}},"description":"QueryNetAssetValuesRequest is the response type for the Query/NetAssetValues method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"id","description":"scopeid metadata address","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/metadata/v1/ownership/{address}":{"get":{"summary":"Ownership returns the scope identifiers that list the given address as either a data or value owner.","operationId":"Ownership","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope_uuids":{"type":"array","items":{"type":"string"},"description":"A list of scope ids (uuid) associated with the given address."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"address":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"OwnershipResponse is the response type for the Query/Ownership RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"address","in":"path","required":true,"schema":{"type":"string"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/params":{"get":{"summary":"Params queries the parameters of x/metadata module.","operationId":"MetadataParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object"},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/record/{record_addr}":{"get":{"summary":"Records searches for records.","description":"The record_addr, if provided, must be a bech32 record address, e.g.\\nrecord1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3. The scope-id can either be scope uuid, e.g.\\n91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address, e.g. scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. Similarly,\\nthe session_id can either be a uuid or session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The name is the name of the record you\'re\\ninterested in.\\n\\n* If only a record_addr is provided, that single record will be returned.\\n* If only a scope_id is provided, all records in that scope will be returned.\\n* If only a session_id (or scope_id/session_id), all records in that session will be returned.\\n* If a name is provided with a scope_id and/or session_id, that single record will be returned.\\n\\nA bad request is returned if:\\n* The session_id is a uuid and no scope_id is provided.\\n* There are two or more of record_addr, session_id, and scope_id, and they don\'t all refer to the same scope.\\n* A name is provided, but not a scope_id and/or a session_id.\\n* A name and record_addr are provided and the name doesn\'t match the record_addr.\\n\\nBy default, the scope and sessions are not included.\\nSet include_scope and/or include_sessions to true to include the scope and/or sessions.","operationId":"Records","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these records (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped sessions that hold these records (if requested)."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped record results."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"name":{"type":"string","title":"name is the name of the record to look for"},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the the scope containing these records in the response."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions containing these records in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordsResponse is the response type for the Query/Records RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"path","required":true,"schema":{"type":"string"}},{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"query","required":false,"schema":{"type":"string"}},{"name":"session_id","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided.","in":"query","required":false,"schema":{"type":"string"}},{"name":"name","description":"name is the name of the record to look for.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_scope","description":"include_scope is a flag for whether to include the the scope containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_sessions","description":"include_sessions is a flag for whether to include the sessions containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/record/{record_addr}/scope":{"get":{"summary":"Scope searches for a scope.","description":"The scope id, if provided, must either be scope uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address,\\ne.g. scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. The session addr, if provided, must be a bech32 session address,\\ne.g. session1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The record_addr, if provided, must be a\\nbech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.\\n\\n* If only a scope_id is provided, that scope is returned.\\n* If only a session_addr is provided, the scope containing that session is returned.\\n* If only a record_addr is provided, the scope containing that record is returned.\\n* If more than one of scope_id, session_addr, and record_addr are provided, and they don\'t refer to the same scope,\\na bad request is returned.\\n\\nProviding a session addr or record addr does not limit the sessions and records returned (if requested).\\nThose parameters are only used to find the scope.\\n\\nBy default, sessions and records are not included.\\nSet include_sessions and/or include_records to true to include sessions and/or records.","operationId":"Scope3","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope result.","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped sessions in this scope (if requested)."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped records in this scope (if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_addr":{"type":"string","description":"session_addr is a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr."},"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions of the scope in the response."},"include_records":{"type":"boolean","format":"boolean","description":"include_records is a flag for whether to include the records of the scope in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"ScopeResponse is the response type for the Query/Scope RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"path","required":true,"schema":{"type":"string"}},{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"query","required":false,"schema":{"type":"string"}},{"name":"session_addr","description":"session_addr is a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_sessions","description":"include_sessions is a flag for whether to include the sessions of the scope in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_records","description":"include_records is a flag for whether to include the records of the scope in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/record/{record_addr}/session":{"get":{"summary":"Sessions searches for sessions.","description":"The scope_id can either be scope uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. Similarly, the session_id can either be a uuid or session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The record_addr, if provided, must be a\\nbech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.\\n\\n* If only a scope_id is provided, all sessions in that scope are returned.\\n* If only a session_id is provided, it must be an address, and that single session is returned.\\n* If the session_id is a uuid, then either a scope_id or record_addr must also be provided, and that single session\\nis returned.\\n* If only a record_addr is provided, the session containing that record will be returned.\\n* If a record_name is provided then either a scope_id, session_id as an address, or record_addr must also be\\nprovided, and the session containing that record will be returned.\\n\\nA bad request is returned if:\\n* The session_id is a uuid and is provided without a scope_id or record_addr.\\n* A record_name is provided without any way to identify the scope (e.g. a scope_id, a session_id as an address, or\\na record_addr).\\n* Two or more of scope_id, session_id as an address, and record_addr are provided and don\'t all refer to the same\\nscope.\\n* A record_addr (or scope_id and record_name) is provided with a session_id and that session does not contain such\\na record.\\n* A record_addr and record_name are both provided, but reference different records.\\n\\nBy default, the scope and records are not included.\\nSet include_scope and/or include_records to true to include the scope and/or records.","operationId":"Sessions4","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these sessions (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped session results."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped records contained in these sessions (if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"record_name":{"type":"string","description":"record_name is the name of the record to find the session for in the provided scope."},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the scope containing these sessions in the response."},"include_records":{"type":"boolean","format":"boolean","description":"include_records is a flag for whether to include the records of these sessions in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"SessionsResponse is the response type for the Query/Sessions RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"path","required":true,"schema":{"type":"string"}},{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"query","required":false,"schema":{"type":"string"}},{"name":"session_id","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided.","in":"query","required":false,"schema":{"type":"string"}},{"name":"record_name","description":"record_name is the name of the record to find the session for in the provided scope.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_scope","description":"include_scope is a flag for whether to include the scope containing these sessions in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_records","description":"include_records is a flag for whether to include the records of these sessions in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/records/all":{"get":{"summary":"RecordsAll retrieves all records.","operationId":"RecordsAll","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records are the wrapped records."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"RecordsAllResponse is the response type for the Query/RecordsAll RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/recordspec/{specification_id}":{"get":{"summary":"RecordSpecification returns a record specification for the given input.","operationId":"RecordSpecification","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"record_specification":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs","description":"specification is the on-chain record specification message."},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordSpecificationWrapper contains a single record specification and some extra identifiers for it."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44."},"name":{"type":"string","description":"name is the name of the record to look up.\\nIt is required if the specification_id is a uuid or contract specification address.\\nIt is ignored if the specification_id is a record specification address."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordSpecificationResponse is the response type for the Query/RecordSpecification RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"specification_id","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44.","in":"path","required":true,"schema":{"type":"string"}},{"name":"name","description":"name is the name of the record to look up.\\nIt is required if the specification_id is a uuid or contract specification address.\\nIt is ignored if the specification_id is a record specification address.","in":"query","required":false,"schema":{"type":"string"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/recordspecs/all":{"get":{"summary":"RecordSpecificationsAll retrieves all record specifications.","operationId":"RecordSpecificationsAll","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"record_specifications":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs","description":"specification is the on-chain record specification message."},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordSpecificationWrapper contains a single record specification and some extra identifiers for it."},"description":"record_specifications are the wrapped record specifications."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"RecordSpecificationsAllResponse is the response type for the Query/RecordSpecificationsAll RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/scope/{scope_id}":{"get":{"summary":"Scope searches for a scope.","description":"The scope id, if provided, must either be scope uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address,\\ne.g. scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. The session addr, if provided, must be a bech32 session address,\\ne.g. session1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The record_addr, if provided, must be a\\nbech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.\\n\\n* If only a scope_id is provided, that scope is returned.\\n* If only a session_addr is provided, the scope containing that session is returned.\\n* If only a record_addr is provided, the scope containing that record is returned.\\n* If more than one of scope_id, session_addr, and record_addr are provided, and they don\'t refer to the same scope,\\na bad request is returned.\\n\\nProviding a session addr or record addr does not limit the sessions and records returned (if requested).\\nThose parameters are only used to find the scope.\\n\\nBy default, sessions and records are not included.\\nSet include_sessions and/or include_records to true to include sessions and/or records.","operationId":"Scope","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope result.","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped sessions in this scope (if requested)."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped records in this scope (if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_addr":{"type":"string","description":"session_addr is a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr."},"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions of the scope in the response."},"include_records":{"type":"boolean","format":"boolean","description":"include_records is a flag for whether to include the records of the scope in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"ScopeResponse is the response type for the Query/Scope RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"path","required":true,"schema":{"type":"string"}},{"name":"session_addr","description":"session_addr is a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr.","in":"query","required":false,"schema":{"type":"string"}},{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_sessions","description":"include_sessions is a flag for whether to include the sessions of the scope in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_records","description":"include_records is a flag for whether to include the records of the scope in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/scope/{scope_id}/record/{name}":{"get":{"summary":"Records searches for records.","description":"The record_addr, if provided, must be a bech32 record address, e.g.\\nrecord1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3. The scope-id can either be scope uuid, e.g.\\n91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address, e.g. scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. Similarly,\\nthe session_id can either be a uuid or session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The name is the name of the record you\'re\\ninterested in.\\n\\n* If only a record_addr is provided, that single record will be returned.\\n* If only a scope_id is provided, all records in that scope will be returned.\\n* If only a session_id (or scope_id/session_id), all records in that session will be returned.\\n* If a name is provided with a scope_id and/or session_id, that single record will be returned.\\n\\nA bad request is returned if:\\n* The session_id is a uuid and no scope_id is provided.\\n* There are two or more of record_addr, session_id, and scope_id, and they don\'t all refer to the same scope.\\n* A name is provided, but not a scope_id and/or a session_id.\\n* A name and record_addr are provided and the name doesn\'t match the record_addr.\\n\\nBy default, the scope and sessions are not included.\\nSet include_scope and/or include_sessions to true to include the scope and/or sessions.","operationId":"Records3","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these records (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped sessions that hold these records (if requested)."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped record results."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"name":{"type":"string","title":"name is the name of the record to look for"},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the the scope containing these records in the response."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions containing these records in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordsResponse is the response type for the Query/Records RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"path","required":true,"schema":{"type":"string"}},{"name":"name","description":"name is the name of the record to look for","in":"path","required":true,"schema":{"type":"string"}},{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"query","required":false,"schema":{"type":"string"}},{"name":"session_id","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_scope","description":"include_scope is a flag for whether to include the the scope containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_sessions","description":"include_sessions is a flag for whether to include the sessions containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/scope/{scope_id}/record/{record_name}/session":{"get":{"summary":"Sessions searches for sessions.","description":"The scope_id can either be scope uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. Similarly, the session_id can either be a uuid or session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The record_addr, if provided, must be a\\nbech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.\\n\\n* If only a scope_id is provided, all sessions in that scope are returned.\\n* If only a session_id is provided, it must be an address, and that single session is returned.\\n* If the session_id is a uuid, then either a scope_id or record_addr must also be provided, and that single session\\nis returned.\\n* If only a record_addr is provided, the session containing that record will be returned.\\n* If a record_name is provided then either a scope_id, session_id as an address, or record_addr must also be\\nprovided, and the session containing that record will be returned.\\n\\nA bad request is returned if:\\n* The session_id is a uuid and is provided without a scope_id or record_addr.\\n* A record_name is provided without any way to identify the scope (e.g. a scope_id, a session_id as an address, or\\na record_addr).\\n* Two or more of scope_id, session_id as an address, and record_addr are provided and don\'t all refer to the same\\nscope.\\n* A record_addr (or scope_id and record_name) is provided with a session_id and that session does not contain such\\na record.\\n* A record_addr and record_name are both provided, but reference different records.\\n\\nBy default, the scope and records are not included.\\nSet include_scope and/or include_records to true to include the scope and/or records.","operationId":"Sessions5","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these sessions (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped session results."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped records contained in these sessions (if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"record_name":{"type":"string","description":"record_name is the name of the record to find the session for in the provided scope."},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the scope containing these sessions in the response."},"include_records":{"type":"boolean","format":"boolean","description":"include_records is a flag for whether to include the records of these sessions in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"SessionsResponse is the response type for the Query/Sessions RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"path","required":true,"schema":{"type":"string"}},{"name":"record_name","description":"record_name is the name of the record to find the session for in the provided scope.","in":"path","required":true,"schema":{"type":"string"}},{"name":"session_id","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided.","in":"query","required":false,"schema":{"type":"string"}},{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_scope","description":"include_scope is a flag for whether to include the scope containing these sessions in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_records","description":"include_records is a flag for whether to include the records of these sessions in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/scope/{scope_id}/records":{"get":{"summary":"Records searches for records.","description":"The record_addr, if provided, must be a bech32 record address, e.g.\\nrecord1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3. The scope-id can either be scope uuid, e.g.\\n91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address, e.g. scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. Similarly,\\nthe session_id can either be a uuid or session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The name is the name of the record you\'re\\ninterested in.\\n\\n* If only a record_addr is provided, that single record will be returned.\\n* If only a scope_id is provided, all records in that scope will be returned.\\n* If only a session_id (or scope_id/session_id), all records in that session will be returned.\\n* If a name is provided with a scope_id and/or session_id, that single record will be returned.\\n\\nA bad request is returned if:\\n* The session_id is a uuid and no scope_id is provided.\\n* There are two or more of record_addr, session_id, and scope_id, and they don\'t all refer to the same scope.\\n* A name is provided, but not a scope_id and/or a session_id.\\n* A name and record_addr are provided and the name doesn\'t match the record_addr.\\n\\nBy default, the scope and sessions are not included.\\nSet include_scope and/or include_sessions to true to include the scope and/or sessions.","operationId":"Records2","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these records (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped sessions that hold these records (if requested)."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped record results."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"name":{"type":"string","title":"name is the name of the record to look for"},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the the scope containing these records in the response."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions containing these records in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordsResponse is the response type for the Query/Records RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"path","required":true,"schema":{"type":"string"}},{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"query","required":false,"schema":{"type":"string"}},{"name":"session_id","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided.","in":"query","required":false,"schema":{"type":"string"}},{"name":"name","description":"name is the name of the record to look for.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_scope","description":"include_scope is a flag for whether to include the the scope containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_sessions","description":"include_sessions is a flag for whether to include the sessions containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/scope/{scope_id}/session/{session_id}":{"get":{"summary":"Sessions searches for sessions.","description":"The scope_id can either be scope uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. Similarly, the session_id can either be a uuid or session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The record_addr, if provided, must be a\\nbech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.\\n\\n* If only a scope_id is provided, all sessions in that scope are returned.\\n* If only a session_id is provided, it must be an address, and that single session is returned.\\n* If the session_id is a uuid, then either a scope_id or record_addr must also be provided, and that single session\\nis returned.\\n* If only a record_addr is provided, the session containing that record will be returned.\\n* If a record_name is provided then either a scope_id, session_id as an address, or record_addr must also be\\nprovided, and the session containing that record will be returned.\\n\\nA bad request is returned if:\\n* The session_id is a uuid and is provided without a scope_id or record_addr.\\n* A record_name is provided without any way to identify the scope (e.g. a scope_id, a session_id as an address, or\\na record_addr).\\n* Two or more of scope_id, session_id as an address, and record_addr are provided and don\'t all refer to the same\\nscope.\\n* A record_addr (or scope_id and record_name) is provided with a session_id and that session does not contain such\\na record.\\n* A record_addr and record_name are both provided, but reference different records.\\n\\nBy default, the scope and records are not included.\\nSet include_scope and/or include_records to true to include the scope and/or records.","operationId":"Sessions3","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these sessions (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped session results."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped records contained in these sessions (if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"record_name":{"type":"string","description":"record_name is the name of the record to find the session for in the provided scope."},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the scope containing these sessions in the response."},"include_records":{"type":"boolean","format":"boolean","description":"include_records is a flag for whether to include the records of these sessions in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"SessionsResponse is the response type for the Query/Sessions RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"path","required":true,"schema":{"type":"string"}},{"name":"session_id","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided.","in":"path","required":true,"schema":{"type":"string"}},{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"query","required":false,"schema":{"type":"string"}},{"name":"record_name","description":"record_name is the name of the record to find the session for in the provided scope.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_scope","description":"include_scope is a flag for whether to include the scope containing these sessions in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_records","description":"include_records is a flag for whether to include the records of these sessions in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/scope/{scope_id}/session/{session_id}/record/{name}":{"get":{"summary":"Records searches for records.","description":"The record_addr, if provided, must be a bech32 record address, e.g.\\nrecord1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3. The scope-id can either be scope uuid, e.g.\\n91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address, e.g. scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. Similarly,\\nthe session_id can either be a uuid or session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The name is the name of the record you\'re\\ninterested in.\\n\\n* If only a record_addr is provided, that single record will be returned.\\n* If only a scope_id is provided, all records in that scope will be returned.\\n* If only a session_id (or scope_id/session_id), all records in that session will be returned.\\n* If a name is provided with a scope_id and/or session_id, that single record will be returned.\\n\\nA bad request is returned if:\\n* The session_id is a uuid and no scope_id is provided.\\n* There are two or more of record_addr, session_id, and scope_id, and they don\'t all refer to the same scope.\\n* A name is provided, but not a scope_id and/or a session_id.\\n* A name and record_addr are provided and the name doesn\'t match the record_addr.\\n\\nBy default, the scope and sessions are not included.\\nSet include_scope and/or include_sessions to true to include the scope and/or sessions.","operationId":"Records5","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these records (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped sessions that hold these records (if requested)."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped record results."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"name":{"type":"string","title":"name is the name of the record to look for"},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the the scope containing these records in the response."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions containing these records in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordsResponse is the response type for the Query/Records RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"path","required":true,"schema":{"type":"string"}},{"name":"session_id","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided.","in":"path","required":true,"schema":{"type":"string"}},{"name":"name","description":"name is the name of the record to look for","in":"path","required":true,"schema":{"type":"string"}},{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_scope","description":"include_scope is a flag for whether to include the the scope containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_sessions","description":"include_sessions is a flag for whether to include the sessions containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/scope/{scope_id}/session/{session_id}/records":{"get":{"summary":"Records searches for records.","description":"The record_addr, if provided, must be a bech32 record address, e.g.\\nrecord1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3. The scope-id can either be scope uuid, e.g.\\n91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address, e.g. scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. Similarly,\\nthe session_id can either be a uuid or session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The name is the name of the record you\'re\\ninterested in.\\n\\n* If only a record_addr is provided, that single record will be returned.\\n* If only a scope_id is provided, all records in that scope will be returned.\\n* If only a session_id (or scope_id/session_id), all records in that session will be returned.\\n* If a name is provided with a scope_id and/or session_id, that single record will be returned.\\n\\nA bad request is returned if:\\n* The session_id is a uuid and no scope_id is provided.\\n* There are two or more of record_addr, session_id, and scope_id, and they don\'t all refer to the same scope.\\n* A name is provided, but not a scope_id and/or a session_id.\\n* A name and record_addr are provided and the name doesn\'t match the record_addr.\\n\\nBy default, the scope and sessions are not included.\\nSet include_scope and/or include_sessions to true to include the scope and/or sessions.","operationId":"Records4","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these records (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped sessions that hold these records (if requested)."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped record results."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"name":{"type":"string","title":"name is the name of the record to look for"},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the the scope containing these records in the response."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions containing these records in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordsResponse is the response type for the Query/Records RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"path","required":true,"schema":{"type":"string"}},{"name":"session_id","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided.","in":"path","required":true,"schema":{"type":"string"}},{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"query","required":false,"schema":{"type":"string"}},{"name":"name","description":"name is the name of the record to look for.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_scope","description":"include_scope is a flag for whether to include the the scope containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_sessions","description":"include_sessions is a flag for whether to include the sessions containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/scope/{scope_id}/sessions":{"get":{"summary":"Sessions searches for sessions.","description":"The scope_id can either be scope uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. Similarly, the session_id can either be a uuid or session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The record_addr, if provided, must be a\\nbech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.\\n\\n* If only a scope_id is provided, all sessions in that scope are returned.\\n* If only a session_id is provided, it must be an address, and that single session is returned.\\n* If the session_id is a uuid, then either a scope_id or record_addr must also be provided, and that single session\\nis returned.\\n* If only a record_addr is provided, the session containing that record will be returned.\\n* If a record_name is provided then either a scope_id, session_id as an address, or record_addr must also be\\nprovided, and the session containing that record will be returned.\\n\\nA bad request is returned if:\\n* The session_id is a uuid and is provided without a scope_id or record_addr.\\n* A record_name is provided without any way to identify the scope (e.g. a scope_id, a session_id as an address, or\\na record_addr).\\n* Two or more of scope_id, session_id as an address, and record_addr are provided and don\'t all refer to the same\\nscope.\\n* A record_addr (or scope_id and record_name) is provided with a session_id and that session does not contain such\\na record.\\n* A record_addr and record_name are both provided, but reference different records.\\n\\nBy default, the scope and records are not included.\\nSet include_scope and/or include_records to true to include the scope and/or records.","operationId":"Sessions2","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these sessions (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped session results."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped records contained in these sessions (if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"record_name":{"type":"string","description":"record_name is the name of the record to find the session for in the provided scope."},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the scope containing these sessions in the response."},"include_records":{"type":"boolean","format":"boolean","description":"include_records is a flag for whether to include the records of these sessions in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"SessionsResponse is the response type for the Query/Sessions RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"path","required":true,"schema":{"type":"string"}},{"name":"session_id","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided.","in":"query","required":false,"schema":{"type":"string"}},{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"query","required":false,"schema":{"type":"string"}},{"name":"record_name","description":"record_name is the name of the record to find the session for in the provided scope.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_scope","description":"include_scope is a flag for whether to include the scope containing these sessions in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_records","description":"include_records is a flag for whether to include the records of these sessions in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/scopes/all":{"get":{"summary":"ScopesAll retrieves all scopes.","operationId":"ScopesAll","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scopes":{"type":"array","items":{"type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}},"description":"SessionWrapper contains a single scope and its uuid."},"description":"scopes are the wrapped scopes."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"ScopesAllResponse is the response type for the Query/ScopesAll RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/scopespec/{specification_id}":{"get":{"summary":"ScopeSpecification returns a scope specification for the given specification id.","description":"The specification_id can either be a uuid, e.g. dc83ea70-eacd-40fe-9adf-1cf6148bf8a2 or a bech32 scope\\nspecification address, e.g. scopespec1qnwg86nsatx5pl56muw0v9ytlz3qu3jx6m.\\n\\nBy default, the contract and record specifications are not included.\\nSet include_contract_specs and/or include_record_specs to true to include contract and/or record specifications.","operationId":"ScopeSpecification","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope_specification":{"description":"scope_specification is the wrapped scope specification.","type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"description":"General information about this scope specification.","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}}},"owner_addresses":{"type":"array","items":{"type":"string"},"description":"Addresses of the owners of this scope specification."},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"A list of parties that must be present on a scope (and their associated roles)"},"contract_spec_ids":{"type":"array","items":{"type":"string","format":"byte"},"description":"A list of contract specification ids allowed for a scope based on this specification."}},"title":"ScopeSpecification defines the required parties, resources, conditions, and consideration outputs for a contract","description":"specification is the on-chain scope specification message."},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"contract_specs":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"title":"Description information for this contract specification","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}},"description":"Description holds general information that is handy to associate with a structure."},"owner_addresses":{"type":"array","items":{"type":"string"},"title":"Address of the account that owns this specificaiton"},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"a list of party roles that must be fullfilled when signing a transaction for this contract specification"},"resource_id":{"type":"string","format":"byte","title":"the address of a record on chain that represents this contract"},"hash":{"type":"string","title":"the hash of contract binary (off-chain instance)"},"class_name":{"type":"string","title":"name of the class/type of this contract executable"}},"title":"ContractSpecification defines the required parties, resources, conditions, and consideration outputs for a contract","description":"specification is the on-chain contract specification message."},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"ContractSpecificationWrapper contains a single contract specification and some extra identifiers for it."},"description":"contract_specs is any number of wrapped contract specifications in this scope specification (if requested)."},"record_specs":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs","description":"specification is the on-chain record specification message."},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordSpecificationWrapper contains a single record specification and some extra identifiers for it."},"description":"record_specs is any number of wrapped record specifications in this scope specification (if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. dc83ea70-eacd-40fe-9adf-1cf6148bf8a2 or a bech32 scope specification\\naddress, e.g. scopespec1qnwg86nsatx5pl56muw0v9ytlz3qu3jx6m."},"include_contract_specs":{"type":"boolean","format":"boolean","description":"include_contract_specs is a flag for whether to include the contract specifications of the scope specification in\\nthe response."},"include_record_specs":{"type":"boolean","format":"boolean","description":"include_record_specs is a flag for whether to include the record specifications of the scope specification in the\\nresponse."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"ScopeSpecificationResponse is the response type for the Query/ScopeSpecification RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"specification_id","description":"specification_id can either be a uuid, e.g. dc83ea70-eacd-40fe-9adf-1cf6148bf8a2 or a bech32 scope specification\\naddress, e.g. scopespec1qnwg86nsatx5pl56muw0v9ytlz3qu3jx6m.","in":"path","required":true,"schema":{"type":"string"}},{"name":"include_contract_specs","description":"include_contract_specs is a flag for whether to include the contract specifications of the scope specification in\\nthe response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_record_specs","description":"include_record_specs is a flag for whether to include the record specifications of the scope specification in the\\nresponse.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/scopespecs/all":{"get":{"summary":"ScopeSpecificationsAll retrieves all scope specifications.","operationId":"ScopeSpecificationsAll","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope_specifications":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"description":"General information about this scope specification.","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}}},"owner_addresses":{"type":"array","items":{"type":"string"},"description":"Addresses of the owners of this scope specification."},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"A list of parties that must be present on a scope (and their associated roles)"},"contract_spec_ids":{"type":"array","items":{"type":"string","format":"byte"},"description":"A list of contract specification ids allowed for a scope based on this specification."}},"title":"ScopeSpecification defines the required parties, resources, conditions, and consideration outputs for a contract","description":"specification is the on-chain scope specification message."},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}},"description":"ScopeSpecificationWrapper contains a single scope specification and some extra identifiers for it."},"description":"scope_specifications are the wrapped scope specifications."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"ScopeSpecificationsAllResponse is the response type for the Query/ScopeSpecificationsAll RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/session/{session_addr}/scope":{"get":{"summary":"Scope searches for a scope.","description":"The scope id, if provided, must either be scope uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address,\\ne.g. scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. The session addr, if provided, must be a bech32 session address,\\ne.g. session1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The record_addr, if provided, must be a\\nbech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.\\n\\n* If only a scope_id is provided, that scope is returned.\\n* If only a session_addr is provided, the scope containing that session is returned.\\n* If only a record_addr is provided, the scope containing that record is returned.\\n* If more than one of scope_id, session_addr, and record_addr are provided, and they don\'t refer to the same scope,\\na bad request is returned.\\n\\nProviding a session addr or record addr does not limit the sessions and records returned (if requested).\\nThose parameters are only used to find the scope.\\n\\nBy default, sessions and records are not included.\\nSet include_sessions and/or include_records to true to include sessions and/or records.","operationId":"Scope2","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope result.","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped sessions in this scope (if requested)."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped records in this scope (if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_addr":{"type":"string","description":"session_addr is a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr."},"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions of the scope in the response."},"include_records":{"type":"boolean","format":"boolean","description":"include_records is a flag for whether to include the records of the scope in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"ScopeResponse is the response type for the Query/Scope RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"session_addr","description":"session_addr is a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr.","in":"path","required":true,"schema":{"type":"string"}},{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"query","required":false,"schema":{"type":"string"}},{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_sessions","description":"include_sessions is a flag for whether to include the sessions of the scope in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_records","description":"include_records is a flag for whether to include the records of the scope in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/session/{session_id}":{"get":{"summary":"Sessions searches for sessions.","description":"The scope_id can either be scope uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. Similarly, the session_id can either be a uuid or session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The record_addr, if provided, must be a\\nbech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.\\n\\n* If only a scope_id is provided, all sessions in that scope are returned.\\n* If only a session_id is provided, it must be an address, and that single session is returned.\\n* If the session_id is a uuid, then either a scope_id or record_addr must also be provided, and that single session\\nis returned.\\n* If only a record_addr is provided, the session containing that record will be returned.\\n* If a record_name is provided then either a scope_id, session_id as an address, or record_addr must also be\\nprovided, and the session containing that record will be returned.\\n\\nA bad request is returned if:\\n* The session_id is a uuid and is provided without a scope_id or record_addr.\\n* A record_name is provided without any way to identify the scope (e.g. a scope_id, a session_id as an address, or\\na record_addr).\\n* Two or more of scope_id, session_id as an address, and record_addr are provided and don\'t all refer to the same\\nscope.\\n* A record_addr (or scope_id and record_name) is provided with a session_id and that session does not contain such\\na record.\\n* A record_addr and record_name are both provided, but reference different records.\\n\\nBy default, the scope and records are not included.\\nSet include_scope and/or include_records to true to include the scope and/or records.","operationId":"Sessions","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these sessions (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped session results."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped records contained in these sessions (if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"record_name":{"type":"string","description":"record_name is the name of the record to find the session for in the provided scope."},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the scope containing these sessions in the response."},"include_records":{"type":"boolean","format":"boolean","description":"include_records is a flag for whether to include the records of these sessions in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"SessionsResponse is the response type for the Query/Sessions RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"session_id","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided.","in":"path","required":true,"schema":{"type":"string"}},{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"query","required":false,"schema":{"type":"string"}},{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"query","required":false,"schema":{"type":"string"}},{"name":"record_name","description":"record_name is the name of the record to find the session for in the provided scope.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_scope","description":"include_scope is a flag for whether to include the scope containing these sessions in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_records","description":"include_records is a flag for whether to include the records of these sessions in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/session/{session_id}/record/{name}":{"get":{"summary":"Records searches for records.","description":"The record_addr, if provided, must be a bech32 record address, e.g.\\nrecord1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3. The scope-id can either be scope uuid, e.g.\\n91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address, e.g. scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. Similarly,\\nthe session_id can either be a uuid or session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The name is the name of the record you\'re\\ninterested in.\\n\\n* If only a record_addr is provided, that single record will be returned.\\n* If only a scope_id is provided, all records in that scope will be returned.\\n* If only a session_id (or scope_id/session_id), all records in that session will be returned.\\n* If a name is provided with a scope_id and/or session_id, that single record will be returned.\\n\\nA bad request is returned if:\\n* The session_id is a uuid and no scope_id is provided.\\n* There are two or more of record_addr, session_id, and scope_id, and they don\'t all refer to the same scope.\\n* A name is provided, but not a scope_id and/or a session_id.\\n* A name and record_addr are provided and the name doesn\'t match the record_addr.\\n\\nBy default, the scope and sessions are not included.\\nSet include_scope and/or include_sessions to true to include the scope and/or sessions.","operationId":"Records7","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these records (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped sessions that hold these records (if requested)."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped record results."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"name":{"type":"string","title":"name is the name of the record to look for"},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the the scope containing these records in the response."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions containing these records in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordsResponse is the response type for the Query/Records RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"session_id","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided.","in":"path","required":true,"schema":{"type":"string"}},{"name":"name","description":"name is the name of the record to look for","in":"path","required":true,"schema":{"type":"string"}},{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"query","required":false,"schema":{"type":"string"}},{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_scope","description":"include_scope is a flag for whether to include the the scope containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_sessions","description":"include_sessions is a flag for whether to include the sessions containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/session/{session_id}/records":{"get":{"summary":"Records searches for records.","description":"The record_addr, if provided, must be a bech32 record address, e.g.\\nrecord1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3. The scope-id can either be scope uuid, e.g.\\n91978ba2-5f35-459a-86a7-feca1b0512e0 or a scope address, e.g. scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel. Similarly,\\nthe session_id can either be a uuid or session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. The name is the name of the record you\'re\\ninterested in.\\n\\n* If only a record_addr is provided, that single record will be returned.\\n* If only a scope_id is provided, all records in that scope will be returned.\\n* If only a session_id (or scope_id/session_id), all records in that session will be returned.\\n* If a name is provided with a scope_id and/or session_id, that single record will be returned.\\n\\nA bad request is returned if:\\n* The session_id is a uuid and no scope_id is provided.\\n* There are two or more of record_addr, session_id, and scope_id, and they don\'t all refer to the same scope.\\n* A name is provided, but not a scope_id and/or a session_id.\\n* A name and record_addr are provided and the name doesn\'t match the record_addr.\\n\\nBy default, the scope and sessions are not included.\\nSet include_scope and/or include_sessions to true to include the scope and/or sessions.","operationId":"Records6","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these records (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped sessions that hold these records (if requested)."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped record results."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"name":{"type":"string","title":"name is the name of the record to look for"},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the the scope containing these records in the response."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions containing these records in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordsResponse is the response type for the Query/Records RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"session_id","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided.","in":"path","required":true,"schema":{"type":"string"}},{"name":"record_addr","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3.","in":"query","required":false,"schema":{"type":"string"}},{"name":"scope_id","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel.","in":"query","required":false,"schema":{"type":"string"}},{"name":"name","description":"name is the name of the record to look for.","in":"query","required":false,"schema":{"type":"string"}},{"name":"include_scope","description":"include_scope is a flag for whether to include the the scope containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_sessions","description":"include_sessions is a flag for whether to include the sessions containing these records in the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/sessions/all":{"get":{"summary":"SessionsAll retrieves all sessions.","operationId":"SessionsAll","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions are the wrapped sessions."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"SessionsAllResponse is the response type for the Query/SessionsAll RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"exclude_id_info","description":"exclude_id_info is a flag for whether to exclude the id info from the response.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/metadata/v1/valueownership/{address}":{"get":{"summary":"ValueOwnership returns the scope identifiers that list the given address as the value owner.","operationId":"ValueOwnership","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"scope_uuids":{"type":"array","items":{"type":"string"},"description":"A list of scope ids (uuid) associated with the given address."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"address":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"ValueOwnershipResponse is the response type for the Query/ValueOwnership RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"address","in":"path","required":true,"schema":{"type":"string"}},{"name":"include_request","description":"include_request is a flag for whether to include this request in your result.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/msgfees/v1/all":{"get":{"summary":"Query all Msgs which have fees associated with them.","operationId":"QueryAllMsgFees","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"msg_fees":{"type":"array","items":{"type":"object","properties":{"msg_type_url":{"type":"string"},"additional_fee":{"title":"additional_fee can pay in any Coin( basically a Denom and Amount, Amount can be zero)","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"recipient":{"type":"string"},"recipient_basis_points":{"type":"integer","format":"int64"}},"title":"MsgFee is the core of what gets stored on the blockchain\\nit consists of four parts\\n1. the msg type url, i.e. /cosmos.bank.v1beta1.MsgSend\\n2. minimum additional fees(can be of any denom)\\n3. optional recipient of fee based on `recipient_basis_points`\\n4. if recipient is declared they will recieve the basis points of the fee (0-10,000)"}},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"title":"response for querying all msg\'s with fees associated with them"}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/msgfees/v1/params":{"get":{"summary":"Params queries the parameters for x/msgfees","operationId":"MsgFeeParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"floor_gas_price":{"description":"floor_gas_price is the constant used to calculate fees when gas fees shares denom with msg fee.\\n\\nConversions:\\n  - x nhash/usd-mil = 1,000,000/x usd/hash\\n  - y usd/hash = 1,000,000/y nhash/usd-mil\\n\\nExamples:\\n  - 40,000,000 nhash/usd-mil = 1,000,000/40,000,000 usd/hash = $0.025/hash,\\n  - $0.040/hash = 1,000,000/0.040 nhash/usd-mil = 25,000,000 nhash/usd-mil","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"nhash_per_usd_mil":{"type":"string","format":"uint64","description":"nhash_per_usd_mil is the total nhash per usd mil for converting usd to nhash."},"conversion_fee_denom":{"type":"string","description":"conversion_fee_denom is the denom usd is converted to."}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/provenance/tx/v1/calculate_msg_based_fee":{"post":{"summary":"CalculateTxFees simulates executing a transaction for estimating gas usage and additional fees.","operationId":"CalculateTxFees","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"additional_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"title":"additional_fees are the amount of coins to be for addition msg fees"},"total_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"total_fees are the total amount of fees needed for the transactions (msg fees + gas fee)\\nnote: the gas fee is calculated with the floor gas price module param."},"estimated_gas":{"type":"string","format":"uint64","title":"estimated_gas is the amount of gas needed for the transaction"}},"description":"CalculateTxFeesResponse is the response type for the Query RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"requestBody":{"content":{"application/json":{"schema":{"type":"object","properties":{"tx_bytes":{"type":"string","format":"byte","description":"tx_bytes is the transaction to simulate."},"default_base_denom":{"type":"string","description":"default_base_denom is used to set the denom used for gas fees\\nif not set it will default to nhash."},"gas_adjustment":{"type":"number","format":"float","title":"gas_adjustment is the adjustment factor to be multiplied against the estimate returned by the tx simulation"}},"description":"CalculateTxFeesRequest is the request type for the Query RPC method."}}},"required":true},"tags":["Query"]}},"/provenance/name/v1/lookup/{address}":{"get":{"summary":"ReverseLookup queries for all names bound against a given address","operationId":"ReverseLookup","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"name":{"type":"array","items":{"type":"string"},"title":"an array of names bound against a given address"},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryReverseLookupResponse is the response type for the Query/Resolve method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"address","description":"address to find name records for","in":"path","required":true,"schema":{"type":"string"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/name/v1/params":{"get":{"summary":"Params queries params of the name module.","operationId":"NameParams","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"max_segment_length":{"type":"integer","format":"int64","title":"maximum length of name segment to allow"},"min_segment_length":{"type":"integer","format":"int64","title":"minimum length of name segment to allow"},"max_name_levels":{"type":"integer","format":"int64","title":"maximum number of name segments to allow.  Example: `foo.bar.baz` would be 3"},"allow_unrestricted_names":{"type":"boolean","format":"boolean","title":"determines if unrestricted name keys are allowed or not"}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/provenance/name/v1/resolve/{name}":{"get":{"summary":"Resolve queries for the address associated with a given name","operationId":"Resolve","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"address":{"type":"string","title":"a string containing the address the name resolves to"},"restricted":{"type":"boolean","format":"boolean","description":"Whether owner signature is required to add sub-names."}},"description":"QueryResolveResponse is the response type for the Query/Resolve method."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"name","description":"name to resolve the address for","in":"path","required":true,"schema":{"type":"string"}}],"tags":["Query"]}},"/provenance/oracle/v1/oracle":{"get":{"summary":"Oracle forwards a query to the module\'s oracle","operationId":"Oracle","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"data":{"type":"string","format":"byte","description":"Data contains the json data returned from the oracle."}},"description":"QueryOracleResponse contains the result of the query sent to the oracle."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"query","description":"Query contains the query data passed to the oracle.","in":"query","required":false,"schema":{"type":"string","format":"byte"}}],"tags":["Query"]}},"/provenance/oracle/v1/oracle_address":{"get":{"summary":"OracleAddress returns the address of the oracle","operationId":"OracleAddress","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"address":{"type":"string","title":"The address of the oracle"}},"description":"QueryOracleAddressResponse contains the address of the oracle."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"tags":["Query"]}},"/provenance/rewards/v1/claim_period_reward_distributions":{"get":{"summary":"ClaimPeriodRewardDistributions returns a list of claim period reward distributions matching the claim_status.","operationId":"ClaimPeriodRewardDistributions","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"claim_period_reward_distributions":{"type":"array","items":{"type":"object","properties":{"claim_period_id":{"type":"string","format":"uint64","description":"The claim period id."},"reward_program_id":{"type":"string","format":"uint64","description":"The id of the reward program that this reward belongs to."},"total_rewards_pool_for_claim_period":{"description":"The sum of all the granted rewards for this claim period.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"rewards_pool":{"description":"The final allocated rewards for this claim period.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"total_shares":{"type":"string","format":"int64","description":"The total number of granted shares for this claim period."},"claim_period_ended":{"type":"boolean","format":"boolean","description":"A flag representing if the claim period for this reward has ended."}},"description":"ClaimPeriodRewardDistribution, this is updated at the end of every claim period."},"description":"List of all ClaimPeriodRewardDistribution objects queried for."},"pagination":{"description":"pagination defines an optional pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"title":"QueryClaimPeriodRewardDistributionsResponse returns the list of paginated ClaimPeriodRewardDistributions"}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/rewards/v1/claim_period_reward_distributions/{reward_id}/claim_periods/{claim_period_id}":{"get":{"summary":"ClaimPeriodRewardDistributionsByID returns a claim period reward distribution matching the ID.","operationId":"ClaimPeriodRewardDistributionsByID","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"claim_period_reward_distribution":{"type":"object","properties":{"claim_period_id":{"type":"string","format":"uint64","description":"The claim period id."},"reward_program_id":{"type":"string","format":"uint64","description":"The id of the reward program that this reward belongs to."},"total_rewards_pool_for_claim_period":{"description":"The sum of all the granted rewards for this claim period.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"rewards_pool":{"description":"The final allocated rewards for this claim period.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"total_shares":{"type":"string","format":"int64","description":"The total number of granted shares for this claim period."},"claim_period_ended":{"type":"boolean","format":"boolean","description":"A flag representing if the claim period for this reward has ended."}},"description":"ClaimPeriodRewardDistribution, this is updated at the end of every claim period."}},"title":"QueryClaimPeriodRewardDistributionsByIDResponse returns the requested ClaimPeriodRewardDistribution"}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"reward_id","description":"The reward program that the claim period reward distribution belongs to.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}},{"name":"claim_period_id","description":"The claim period that the claim period reward distribution was created for.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}}],"tags":["Query"]}},"/provenance/rewards/v1/reward_claims/{address}":{"get":{"summary":"RewardDistributionsByAddress returns a list of reward claims belonging to the account and matching the claim\\nstatus.","operationId":"RewardDistributionsByAddress","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"address":{"type":"string","description":"The address that the reward account belongs to."},"reward_account_state":{"type":"array","items":{"type":"object","properties":{"reward_program_id":{"type":"string","format":"uint64","description":"The id of the reward program that this claim belongs to."},"total_reward_claim":{"description":"total rewards claimed for all eligible claim periods in program.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claim_status":{"description":"The status of the claim.","type":"string","enum":["CLAIM_STATUS_UNSPECIFIED","CLAIM_STATUS_UNCLAIMABLE","CLAIM_STATUS_CLAIMABLE","CLAIM_STATUS_CLAIMED","CLAIM_STATUS_EXPIRED"],"default":"CLAIM_STATUS_UNSPECIFIED","title":"ClaimStatus is the state a claim is in"},"claim_id":{"type":"string","format":"uint64","description":"The claim period that the claim belongs to."}},"description":"RewardAccountResponse is an address\' reward claim for a reward program\'s claim period."},"description":"List of RewardAccounts queried for."},"pagination":{"description":"pagination defines an optional pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryRewardDistributionsByAddressResponse returns the reward claims for an address that match the claim_status."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"address","description":"The address that the claim belongs to.","in":"path","required":true,"schema":{"type":"string"}},{"name":"claim_status","description":"The status that the reward account must have.\\n\\n - CLAIM_STATUS_UNSPECIFIED: undefined state\\n - CLAIM_STATUS_UNCLAIMABLE: unclaimable status\\n - CLAIM_STATUS_CLAIMABLE: unclaimable claimable\\n - CLAIM_STATUS_CLAIMED: unclaimable claimed\\n - CLAIM_STATUS_EXPIRED: unclaimable expired","in":"query","required":false,"schema":{"type":"string","enum":["CLAIM_STATUS_UNSPECIFIED","CLAIM_STATUS_UNCLAIMABLE","CLAIM_STATUS_CLAIMABLE","CLAIM_STATUS_CLAIMED","CLAIM_STATUS_EXPIRED"],"default":"CLAIM_STATUS_UNSPECIFIED"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/rewards/v1/reward_programs":{"get":{"summary":"RewardPrograms returns a list of reward programs matching the query type.","operationId":"RewardPrograms","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"reward_programs":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"An integer to uniquely identify the reward program."},"title":{"type":"string","title":"Name to help identify the Reward Program.(MaxTitleLength=140)"},"description":{"type":"string","title":"Short summary describing the Reward Program.(MaxDescriptionLength=10000)"},"distribute_from_address":{"type":"string","description":"address that provides funds for the total reward pool."},"total_reward_pool":{"description":"The total amount of funding given to the RewardProgram.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"remaining_pool_balance":{"description":"The remaining funds available to distribute after n claim periods have passed.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claimed_amount":{"description":"The total amount of all funds claimed by participants for all past claim periods.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"max_reward_by_address":{"description":"Maximum reward per claim period per address.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"minimum_rollover_amount":{"description":"Minimum amount of coins for a program to rollover.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claim_period_seconds":{"type":"string","format":"uint64","description":"Number of seconds that a claim period lasts."},"program_start_time":{"type":"string","format":"date-time","description":"Time that a RewardProgram should start and switch to STARTED state."},"expected_program_end_time":{"type":"string","format":"date-time","description":"Time that a RewardProgram is expected to end, based on data when it was setup."},"program_end_time_max":{"type":"string","format":"date-time","description":"Time that a RewardProgram MUST end."},"claim_period_end_time":{"type":"string","format":"date-time","description":"Used internally to calculate and track the current claim period\'s ending time."},"actual_program_end_time":{"type":"string","format":"date-time","description":"Time the RewardProgram switched to FINISHED state. Initially set as empty."},"claim_periods":{"type":"string","format":"uint64","description":"Number of claim periods this program will run for."},"current_claim_period":{"type":"string","format":"uint64","description":"Current claim period of the RewardProgram. Uses 1-based indexing."},"max_rollover_claim_periods":{"type":"string","format":"uint64","description":"maximum number of claim periods a reward program can rollover."},"state":{"description":"Current state of the RewardProgram.","type":"string","enum":["STATE_UNSPECIFIED","STATE_PENDING","STATE_STARTED","STATE_FINISHED","STATE_EXPIRED"],"default":"STATE_UNSPECIFIED","title":"State is the state of the reward program"},"expiration_offset":{"type":"string","format":"uint64","description":"Grace period after a RewardProgram FINISHED. It is the number of seconds until a RewardProgram enters the EXPIRED\\nstate."},"qualifying_actions":{"type":"array","items":{"type":"object","properties":{"delegate":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful delegates."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful delegates."},"minimum_delegation_amount":{"description":"Minimum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"maximum_delegation_amount":{"description":"Maximum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"minimum_active_stake_percentile":{"type":"string","description":"Minimum percentile that can be below the validator\'s power ranking."},"maximum_active_stake_percentile":{"type":"string","description":"Maximum percentile that can be below the validator\'s power ranking."}},"description":"ActionDelegate represents the delegate action and its required eligibility criteria."},"transfer":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful transfers."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful transfers."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the transfer action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}}},"description":"ActionTransfer represents the transfer action and its required eligibility criteria."},"vote":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful votes."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful votes."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the vote action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"validator_multiplier":{"type":"string","format":"uint64","title":"Positive multiplier that is applied to the shares awarded by the vote action when conditions\\nare met(for now the only condition is the current vote is a validator vote). A value of zero will behave the same\\nas one"}},"description":"ActionVote represents the voting action and its required eligibility criteria."}},"description":"QualifyingAction can be one of many action types."},"description":"Actions that count towards the reward."}},"title":"RewardProgram"},"description":"List of RewardProgram objects matching the query_type."},"pagination":{"description":"pagination defines an optional pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"title":"QueryRewardProgramsResponse contains the list of RewardPrograms matching the query"}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"query_type","description":"A filter on the types of reward programs.\\n\\n - QUERY_TYPE_UNSPECIFIED: unspecified type\\n - QUERY_TYPE_ALL: all reward programs states\\n - QUERY_TYPE_PENDING: pending reward program state=\\n - QUERY_TYPE_ACTIVE: active reward program state\\n - QUERY_TYPE_OUTSTANDING: pending and active reward program states\\n - QUERY_TYPE_FINISHED: finished reward program state","in":"query","required":false,"schema":{"type":"string","enum":["QUERY_TYPE_UNSPECIFIED","QUERY_TYPE_ALL","QUERY_TYPE_PENDING","QUERY_TYPE_ACTIVE","QUERY_TYPE_OUTSTANDING","QUERY_TYPE_FINISHED"],"default":"QUERY_TYPE_UNSPECIFIED"}},{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/rewards/v1/reward_programs/{id}":{"get":{"summary":"RewardProgramByID returns a reward program matching the ID.","operationId":"RewardProgramByID","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"reward_program":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"An integer to uniquely identify the reward program."},"title":{"type":"string","title":"Name to help identify the Reward Program.(MaxTitleLength=140)"},"description":{"type":"string","title":"Short summary describing the Reward Program.(MaxDescriptionLength=10000)"},"distribute_from_address":{"type":"string","description":"address that provides funds for the total reward pool."},"total_reward_pool":{"description":"The total amount of funding given to the RewardProgram.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"remaining_pool_balance":{"description":"The remaining funds available to distribute after n claim periods have passed.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claimed_amount":{"description":"The total amount of all funds claimed by participants for all past claim periods.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"max_reward_by_address":{"description":"Maximum reward per claim period per address.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"minimum_rollover_amount":{"description":"Minimum amount of coins for a program to rollover.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claim_period_seconds":{"type":"string","format":"uint64","description":"Number of seconds that a claim period lasts."},"program_start_time":{"type":"string","format":"date-time","description":"Time that a RewardProgram should start and switch to STARTED state."},"expected_program_end_time":{"type":"string","format":"date-time","description":"Time that a RewardProgram is expected to end, based on data when it was setup."},"program_end_time_max":{"type":"string","format":"date-time","description":"Time that a RewardProgram MUST end."},"claim_period_end_time":{"type":"string","format":"date-time","description":"Used internally to calculate and track the current claim period\'s ending time."},"actual_program_end_time":{"type":"string","format":"date-time","description":"Time the RewardProgram switched to FINISHED state. Initially set as empty."},"claim_periods":{"type":"string","format":"uint64","description":"Number of claim periods this program will run for."},"current_claim_period":{"type":"string","format":"uint64","description":"Current claim period of the RewardProgram. Uses 1-based indexing."},"max_rollover_claim_periods":{"type":"string","format":"uint64","description":"maximum number of claim periods a reward program can rollover."},"state":{"description":"Current state of the RewardProgram.","type":"string","enum":["STATE_UNSPECIFIED","STATE_PENDING","STATE_STARTED","STATE_FINISHED","STATE_EXPIRED"],"default":"STATE_UNSPECIFIED","title":"State is the state of the reward program"},"expiration_offset":{"type":"string","format":"uint64","description":"Grace period after a RewardProgram FINISHED. It is the number of seconds until a RewardProgram enters the EXPIRED\\nstate."},"qualifying_actions":{"type":"array","items":{"type":"object","properties":{"delegate":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful delegates."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful delegates."},"minimum_delegation_amount":{"description":"Minimum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"maximum_delegation_amount":{"description":"Maximum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"minimum_active_stake_percentile":{"type":"string","description":"Minimum percentile that can be below the validator\'s power ranking."},"maximum_active_stake_percentile":{"type":"string","description":"Maximum percentile that can be below the validator\'s power ranking."}},"description":"ActionDelegate represents the delegate action and its required eligibility criteria."},"transfer":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful transfers."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful transfers."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the transfer action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}}},"description":"ActionTransfer represents the transfer action and its required eligibility criteria."},"vote":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful votes."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful votes."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the vote action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"validator_multiplier":{"type":"string","format":"uint64","title":"Positive multiplier that is applied to the shares awarded by the vote action when conditions\\nare met(for now the only condition is the current vote is a validator vote). A value of zero will behave the same\\nas one"}},"description":"ActionVote represents the voting action and its required eligibility criteria."}},"description":"QualifyingAction can be one of many action types."},"description":"Actions that count towards the reward."}},"title":"RewardProgram","description":"The reward program object that was queried for."}},"title":"QueryRewardProgramByIDResponse contains the requested RewardProgram"}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string"},"value":{"type":"string","format":"byte"}}}}}}}}}},"parameters":[{"name":"id","description":"The id of the reward program to query.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}}],"tags":["Query"]}},"/provenance/trigger/v1/triggers":{"get":{"summary":"Triggers returns the list of triggers.","operationId":"Triggers","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"triggers":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"An integer to uniquely identify the trigger."},"owner":{"type":"string","description":"The owner of the trigger."},"event":{"description":"The event that must be detected for the trigger to fire.","type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}}},"actions":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"The messages to run when the trigger fires."}},"title":"Trigger"},"description":"List of Trigger objects."},"pagination":{"description":"pagination defines an optional pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryTriggersResponse contains the list of Triggers."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"pagination.key","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set.","in":"query","required":false,"schema":{"type":"string","format":"byte"}},{"name":"pagination.offset","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.limit","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app.","in":"query","required":false,"schema":{"type":"string","format":"uint64"}},{"name":"pagination.count_total","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}},{"name":"pagination.reverse","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","in":"query","required":false,"schema":{"type":"boolean","format":"boolean"}}],"tags":["Query"]}},"/provenance/trigger/v1/triggers/{id}":{"get":{"summary":"TriggerByID returns a trigger matching the ID.","operationId":"TriggerByID","responses":{"200":{"description":"A successful response.","content":{"*/*":{"schema":{"type":"object","properties":{"trigger":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"An integer to uniquely identify the trigger."},"owner":{"type":"string","description":"The owner of the trigger."},"event":{"description":"The event that must be detected for the trigger to fire.","type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}}},"actions":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"The messages to run when the trigger fires."}},"title":"Trigger","description":"The trigger object that was queried for."}},"description":"QueryTriggerByIDResponse contains the requested Trigger."}}}},"default":{"description":"An unexpected error response","content":{"*/*":{"schema":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}}}}}},"parameters":[{"name":"id","description":"The id of the trigger to query.","in":"path","required":true,"schema":{"type":"string","format":"uint64"}}],"tags":["Query"]}}},"components":{"schemas":{"cosmos.auth.v1beta1.AddressBytesToStringResponse":{"type":"object","properties":{"address_string":{"type":"string"}},"description":"AddressBytesToStringResponse is the response type for AddressString rpc method.\\n\\nSince: cosmos-sdk 0.46"},"cosmos.auth.v1beta1.AddressStringToBytesResponse":{"type":"object","properties":{"address_bytes":{"type":"string","format":"byte"}},"description":"AddressStringToBytesResponse is the response type for AddressBytes rpc method.\\n\\nSince: cosmos-sdk 0.46"},"cosmos.auth.v1beta1.Bech32PrefixResponse":{"type":"object","properties":{"bech32_prefix":{"type":"string"}},"description":"Bech32PrefixResponse is the response type for Bech32Prefix rpc method.\\n\\nSince: cosmos-sdk 0.46"},"cosmos.auth.v1beta1.Params":{"type":"object","properties":{"max_memo_characters":{"type":"string","format":"uint64"},"tx_sig_limit":{"type":"string","format":"uint64"},"tx_size_cost_per_byte":{"type":"string","format":"uint64"},"sig_verify_cost_ed25519":{"type":"string","format":"uint64"},"sig_verify_cost_secp256k1":{"type":"string","format":"uint64"}},"description":"Params defines the parameters for the auth module."},"cosmos.auth.v1beta1.QueryAccountAddressByIDResponse":{"type":"object","properties":{"account_address":{"type":"string"}},"description":"Since: cosmos-sdk 0.46.2","title":"QueryAccountAddressByIDResponse is the response type for AccountAddressByID rpc method"},"cosmos.auth.v1beta1.QueryAccountResponse":{"type":"object","properties":{"account":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"description":"QueryAccountResponse is the response type for the Query/Account RPC method."},"cosmos.auth.v1beta1.QueryAccountsResponse":{"type":"object","properties":{"accounts":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"title":"accounts are the existing accounts"},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAccountsResponse is the response type for the Query/Accounts RPC method.\\n\\nSince: cosmos-sdk 0.43"},"cosmos.auth.v1beta1.QueryModuleAccountByNameResponse":{"type":"object","properties":{"account":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"description":"QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method."},"cosmos.auth.v1beta1.QueryModuleAccountsResponse":{"type":"object","properties":{"accounts":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}},"description":"QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method.\\n\\nSince: cosmos-sdk 0.46"},"cosmos.auth.v1beta1.QueryParamsResponse":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"max_memo_characters":{"type":"string","format":"uint64"},"tx_sig_limit":{"type":"string","format":"uint64"},"tx_size_cost_per_byte":{"type":"string","format":"uint64"},"sig_verify_cost_ed25519":{"type":"string","format":"uint64"},"sig_verify_cost_secp256k1":{"type":"string","format":"uint64"}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."},"cosmos.base.query.v1beta1.PageRequest":{"type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set.","format":"boolean"},"reverse":{"type":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43","format":"boolean"}},"description":"message SomeRequest {\\n         Foo some_parameter = 1;\\n         PageRequest pagination = 2;\\n }","title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"},"cosmos.base.query.v1beta1.PageResponse":{"type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}},"description":"PageResponse is to be embedded in gRPC response messages where the\\ncorresponding request message has used PageRequest.\\n\\n message SomeResponse {\\n         repeated Bar results = 1;\\n         PageResponse page = 2;\\n }"},"google.protobuf.Any":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"grpc.gateway.runtime.Error":{"type":"object","properties":{"error":{"type":"string"},"code":{"type":"integer","format":"int32"},"message":{"type":"string"},"details":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}},"cosmos.bank.v1beta1.DenomOwner":{"type":"object","properties":{"address":{"type":"string","description":"address defines the address that owns a particular denomination."},"balance":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"DenomOwner defines structure representing an account that owns or holds a\\nparticular denominated token. It contains the account address and account\\nbalance of the denominated token.\\n\\nSince: cosmos-sdk 0.46"},"cosmos.bank.v1beta1.DenomUnit":{"type":"object","properties":{"denom":{"type":"string","description":"denom represents the string name of the given denom unit (e.g uatom)."},"exponent":{"type":"integer","format":"int64","description":"exponent represents power of 10 exponent that one must\\nraise the base_denom to in order to equal the given DenomUnit\'s denom\\n1 denom = 10^exponent base_denom\\n(e.g. with a base_denom of uatom, one can create a DenomUnit of \'atom\' with\\nexponent = 6, thus: 1 atom = 10^6 uatom)."},"aliases":{"type":"array","items":{"type":"string"},"title":"aliases is a list of string aliases for the given denom"}},"description":"DenomUnit represents a struct that describes a given\\ndenomination unit of the basic token."},"cosmos.bank.v1beta1.Metadata":{"type":"object","properties":{"description":{"type":"string"},"denom_units":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string","description":"denom represents the string name of the given denom unit (e.g uatom)."},"exponent":{"type":"integer","format":"int64","description":"exponent represents power of 10 exponent that one must\\nraise the base_denom to in order to equal the given DenomUnit\'s denom\\n1 denom = 10^exponent base_denom\\n(e.g. with a base_denom of uatom, one can create a DenomUnit of \'atom\' with\\nexponent = 6, thus: 1 atom = 10^6 uatom)."},"aliases":{"type":"array","items":{"type":"string"},"title":"aliases is a list of string aliases for the given denom"}},"description":"DenomUnit represents a struct that describes a given\\ndenomination unit of the basic token."},"title":"denom_units represents the list of DenomUnit\'s for a given coin"},"base":{"type":"string","description":"base represents the base denom (should be the DenomUnit with exponent = 0)."},"display":{"type":"string","description":"display indicates the suggested denom that should be\\ndisplayed in clients."},"name":{"type":"string","description":"Since: cosmos-sdk 0.43","title":"name defines the name of the token (eg: Cosmos Atom)"},"symbol":{"type":"string","description":"symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\\nbe the same as the display.\\n\\nSince: cosmos-sdk 0.43"},"uri":{"type":"string","description":"URI to a document (on or off-chain) that contains additional information. Optional.\\n\\nSince: cosmos-sdk 0.46"},"uri_hash":{"type":"string","description":"URIHash is a sha256 hash of a document pointed by URI. It\'s used to verify that\\nthe document didn\'t change. Optional.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Metadata represents a struct that describes\\na basic token."},"cosmos.bank.v1beta1.Params":{"type":"object","properties":{"send_enabled":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"enabled":{"type":"boolean"}},"description":"SendEnabled maps coin denom to a send_enabled status (whether a denom is\\nsendable)."},"description":"Deprecated: Use of SendEnabled in params is deprecated.\\nFor genesis, use the newly added send_enabled field in the genesis object.\\nStorage, lookup, and manipulation of this information is now in the keeper.\\n\\nAs of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files."},"default_send_enabled":{"type":"boolean"}},"description":"Params defines the parameters for the bank module."},"cosmos.bank.v1beta1.QueryAllBalancesResponse":{"type":"object","properties":{"balances":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"balances is the balances of all the coins."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAllBalancesResponse is the response type for the Query/AllBalances RPC\\nmethod."},"cosmos.bank.v1beta1.QueryBalanceResponse":{"type":"object","properties":{"balance":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"QueryBalanceResponse is the response type for the Query/Balance RPC method."},"cosmos.bank.v1beta1.QueryDenomMetadataResponse":{"type":"object","properties":{"metadata":{"type":"object","properties":{"description":{"type":"string"},"denom_units":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string","description":"denom represents the string name of the given denom unit (e.g uatom)."},"exponent":{"type":"integer","format":"int64","description":"exponent represents power of 10 exponent that one must\\nraise the base_denom to in order to equal the given DenomUnit\'s denom\\n1 denom = 10^exponent base_denom\\n(e.g. with a base_denom of uatom, one can create a DenomUnit of \'atom\' with\\nexponent = 6, thus: 1 atom = 10^6 uatom)."},"aliases":{"type":"array","items":{"type":"string"},"title":"aliases is a list of string aliases for the given denom"}},"description":"DenomUnit represents a struct that describes a given\\ndenomination unit of the basic token."},"title":"denom_units represents the list of DenomUnit\'s for a given coin"},"base":{"type":"string","description":"base represents the base denom (should be the DenomUnit with exponent = 0)."},"display":{"type":"string","description":"display indicates the suggested denom that should be\\ndisplayed in clients."},"name":{"type":"string","description":"Since: cosmos-sdk 0.43","title":"name defines the name of the token (eg: Cosmos Atom)"},"symbol":{"type":"string","description":"symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\\nbe the same as the display.\\n\\nSince: cosmos-sdk 0.43"},"uri":{"type":"string","description":"URI to a document (on or off-chain) that contains additional information. Optional.\\n\\nSince: cosmos-sdk 0.46"},"uri_hash":{"type":"string","description":"URIHash is a sha256 hash of a document pointed by URI. It\'s used to verify that\\nthe document didn\'t change. Optional.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Metadata represents a struct that describes\\na basic token."}},"description":"QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC\\nmethod."},"cosmos.bank.v1beta1.QueryDenomOwnersResponse":{"type":"object","properties":{"denom_owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address defines the address that owns a particular denomination."},"balance":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"DenomOwner defines structure representing an account that owns or holds a\\nparticular denominated token. It contains the account address and account\\nbalance of the denominated token.\\n\\nSince: cosmos-sdk 0.46"}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.\\n\\nSince: cosmos-sdk 0.46"},"cosmos.bank.v1beta1.QueryDenomsMetadataResponse":{"type":"object","properties":{"metadatas":{"type":"array","items":{"type":"object","properties":{"description":{"type":"string"},"denom_units":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string","description":"denom represents the string name of the given denom unit (e.g uatom)."},"exponent":{"type":"integer","format":"int64","description":"exponent represents power of 10 exponent that one must\\nraise the base_denom to in order to equal the given DenomUnit\'s denom\\n1 denom = 10^exponent base_denom\\n(e.g. with a base_denom of uatom, one can create a DenomUnit of \'atom\' with\\nexponent = 6, thus: 1 atom = 10^6 uatom)."},"aliases":{"type":"array","items":{"type":"string"},"title":"aliases is a list of string aliases for the given denom"}},"description":"DenomUnit represents a struct that describes a given\\ndenomination unit of the basic token."},"title":"denom_units represents the list of DenomUnit\'s for a given coin"},"base":{"type":"string","description":"base represents the base denom (should be the DenomUnit with exponent = 0)."},"display":{"type":"string","description":"display indicates the suggested denom that should be\\ndisplayed in clients."},"name":{"type":"string","description":"Since: cosmos-sdk 0.43","title":"name defines the name of the token (eg: Cosmos Atom)"},"symbol":{"type":"string","description":"symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\\nbe the same as the display.\\n\\nSince: cosmos-sdk 0.43"},"uri":{"type":"string","description":"URI to a document (on or off-chain) that contains additional information. Optional.\\n\\nSince: cosmos-sdk 0.46"},"uri_hash":{"type":"string","description":"URIHash is a sha256 hash of a document pointed by URI. It\'s used to verify that\\nthe document didn\'t change. Optional.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Metadata represents a struct that describes\\na basic token."},"description":"metadata provides the client information for all the registered tokens."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC\\nmethod."},"cosmos.bank.v1beta1.QueryParamsResponse":{"type":"object","properties":{"params":{"type":"object","properties":{"send_enabled":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"enabled":{"type":"boolean"}},"description":"SendEnabled maps coin denom to a send_enabled status (whether a denom is\\nsendable)."},"description":"Deprecated: Use of SendEnabled in params is deprecated.\\nFor genesis, use the newly added send_enabled field in the genesis object.\\nStorage, lookup, and manipulation of this information is now in the keeper.\\n\\nAs of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files."},"default_send_enabled":{"type":"boolean"}},"description":"Params defines the parameters for the bank module."}},"description":"QueryParamsResponse defines the response type for querying x/bank parameters."},"cosmos.bank.v1beta1.QuerySendEnabledResponse":{"type":"object","properties":{"send_enabled":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"enabled":{"type":"boolean"}},"description":"SendEnabled maps coin denom to a send_enabled status (whether a denom is\\nsendable)."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QuerySendEnabledResponse defines the RPC response of a SendEnable query.\\n\\nSince: cosmos-sdk 0.47"},"cosmos.bank.v1beta1.QuerySpendableBalancesResponse":{"type":"object","properties":{"balances":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"balances is the spendable balances of all the coins."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QuerySpendableBalancesResponse defines the gRPC response structure for querying\\nan account\'s spendable balances.\\n\\nSince: cosmos-sdk 0.46"},"cosmos.bank.v1beta1.QuerySupplyOfResponse":{"type":"object","properties":{"amount":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method."},"cosmos.bank.v1beta1.QueryTotalSupplyResponse":{"type":"object","properties":{"supply":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"title":"supply is the supply of the coins"},"pagination":{"description":"pagination defines the pagination in the response.\\n\\nSince: cosmos-sdk 0.43","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"title":"QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC\\nmethod"},"cosmos.bank.v1beta1.SendEnabled":{"type":"object","properties":{"denom":{"type":"string"},"enabled":{"type":"boolean"}},"description":"SendEnabled maps coin denom to a send_enabled status (whether a denom is\\nsendable)."},"cosmos.base.v1beta1.Coin":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"cosmos.base.tendermint.v1beta1.ABCIQueryResponse":{"type":"object","properties":{"code":{"type":"integer","format":"int64"},"log":{"type":"string"},"info":{"type":"string"},"index":{"type":"string","format":"int64"},"key":{"type":"string","format":"byte"},"value":{"type":"string","format":"byte"},"proof_ops":{"type":"object","properties":{"ops":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"key":{"type":"string","format":"byte"},"data":{"type":"string","format":"byte"}},"description":"ProofOp defines an operation used for calculating Merkle root. The data could\\nbe arbitrary format, providing nessecary data for example neighbouring node\\nhash.\\n\\nNote: This type is a duplicate of the ProofOp proto type defined in\\nTendermint."}}},"description":"ProofOps is Merkle proof defined by the list of ProofOps.\\n\\nNote: This type is a duplicate of the ProofOps proto type defined in\\nTendermint."},"height":{"type":"string","format":"int64"},"codespace":{"type":"string"}},"description":"ABCIQueryResponse defines the response structure for the ABCIQuery gRPC\\nquery.\\n\\nNote: This type is a duplicate of the ResponseQuery proto type defined in\\nTendermint."},"cosmos.base.tendermint.v1beta1.Block":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","description":"proposer_address is the original block proposer address, formatted as a Bech32 string.\\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\\nfor better UX."}},"description":"Header defines the structure of a Tendermint block header."},"data":{"type":"object","properties":{"txs":{"type":"array","items":{"type":"string","format":"byte"},"description":"Txs that will be applied by state @ block.Height+1.\\nNOTE: not all txs here are valid.  We\'re just agreeing on the order first.\\nThis means that block.AppHash does not include these txs."}},"title":"Data contains the set of transactions included in the block"},"evidence":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}}}}},"last_commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}},"description":"Block is tendermint type Block, with the Header proposer address\\nfield converted to bech32 string."},"cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse":{"type":"object","properties":{"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"block":{"title":"Deprecated: please use `sdk_block` instead","type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"data":{"type":"object","properties":{"txs":{"type":"array","items":{"type":"string","format":"byte"},"description":"Txs that will be applied by state @ block.Height+1.\\nNOTE: not all txs here are valid.  We\'re just agreeing on the order first.\\nThis means that block.AppHash does not include these txs."}},"title":"Data contains the set of transactions included in the block"},"evidence":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}}}}},"last_commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"sdk_block":{"title":"Since: cosmos-sdk 0.47","type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","description":"proposer_address is the original block proposer address, formatted as a Bech32 string.\\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\\nfor better UX."}},"description":"Header defines the structure of a Tendermint block header."},"data":{"type":"object","properties":{"txs":{"type":"array","items":{"type":"string","format":"byte"},"description":"Txs that will be applied by state @ block.Height+1.\\nNOTE: not all txs here are valid.  We\'re just agreeing on the order first.\\nThis means that block.AppHash does not include these txs."}},"title":"Data contains the set of transactions included in the block"},"evidence":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}}}}},"last_commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}},"description":"Block is tendermint type Block, with the Header proposer address\\nfield converted to bech32 string."}},"description":"GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight\\nRPC method."},"cosmos.base.tendermint.v1beta1.GetLatestBlockResponse":{"type":"object","properties":{"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"block":{"title":"Deprecated: please use `sdk_block` instead","type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"data":{"type":"object","properties":{"txs":{"type":"array","items":{"type":"string","format":"byte"},"description":"Txs that will be applied by state @ block.Height+1.\\nNOTE: not all txs here are valid.  We\'re just agreeing on the order first.\\nThis means that block.AppHash does not include these txs."}},"title":"Data contains the set of transactions included in the block"},"evidence":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}}}}},"last_commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"sdk_block":{"title":"Since: cosmos-sdk 0.47","type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","description":"proposer_address is the original block proposer address, formatted as a Bech32 string.\\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\\nfor better UX."}},"description":"Header defines the structure of a Tendermint block header."},"data":{"type":"object","properties":{"txs":{"type":"array","items":{"type":"string","format":"byte"},"description":"Txs that will be applied by state @ block.Height+1.\\nNOTE: not all txs here are valid.  We\'re just agreeing on the order first.\\nThis means that block.AppHash does not include these txs."}},"title":"Data contains the set of transactions included in the block"},"evidence":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}}}}},"last_commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}},"description":"Block is tendermint type Block, with the Header proposer address\\nfield converted to bech32 string."}},"description":"GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC\\nmethod."},"cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse":{"type":"object","properties":{"block_height":{"type":"string","format":"int64"},"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string"},"pub_key":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}},"description":"Validator is the type for the validator-set."}},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"GetLatestValidatorSetResponse is the response type for the\\nQuery/GetValidatorSetByHeight RPC method."},"cosmos.base.tendermint.v1beta1.GetNodeInfoResponse":{"type":"object","properties":{"default_node_info":{"type":"object","properties":{"protocol_version":{"type":"object","properties":{"p2p":{"type":"string","format":"uint64"},"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}}},"default_node_id":{"type":"string"},"listen_addr":{"type":"string"},"network":{"type":"string"},"version":{"type":"string"},"channels":{"type":"string","format":"byte"},"moniker":{"type":"string"},"other":{"type":"object","properties":{"tx_index":{"type":"string"},"rpc_address":{"type":"string"}}}}},"application_version":{"type":"object","properties":{"name":{"type":"string"},"app_name":{"type":"string"},"version":{"type":"string"},"git_commit":{"type":"string"},"build_tags":{"type":"string"},"go_version":{"type":"string"},"build_deps":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string","title":"module path"},"version":{"type":"string","title":"module version"},"sum":{"type":"string","title":"checksum"}},"title":"Module is the type for VersionInfo"}},"cosmos_sdk_version":{"type":"string","title":"Since: cosmos-sdk 0.43"}},"description":"VersionInfo is the type for the GetNodeInfoResponse message."}},"description":"GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC\\nmethod."},"cosmos.base.tendermint.v1beta1.GetSyncingResponse":{"type":"object","properties":{"syncing":{"type":"boolean"}},"description":"GetSyncingResponse is the response type for the Query/GetSyncing RPC method."},"cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse":{"type":"object","properties":{"block_height":{"type":"string","format":"int64"},"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string"},"pub_key":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}},"description":"Validator is the type for the validator-set."}},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"GetValidatorSetByHeightResponse is the response type for the\\nQuery/GetValidatorSetByHeight RPC method."},"cosmos.base.tendermint.v1beta1.Header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","description":"proposer_address is the original block proposer address, formatted as a Bech32 string.\\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\\nfor better UX."}},"description":"Header defines the structure of a Tendermint block header."},"cosmos.base.tendermint.v1beta1.Module":{"type":"object","properties":{"path":{"type":"string","title":"module path"},"version":{"type":"string","title":"module version"},"sum":{"type":"string","title":"checksum"}},"title":"Module is the type for VersionInfo"},"cosmos.base.tendermint.v1beta1.ProofOp":{"type":"object","properties":{"type":{"type":"string"},"key":{"type":"string","format":"byte"},"data":{"type":"string","format":"byte"}},"description":"ProofOp defines an operation used for calculating Merkle root. The data could\\nbe arbitrary format, providing nessecary data for example neighbouring node\\nhash.\\n\\nNote: This type is a duplicate of the ProofOp proto type defined in\\nTendermint."},"cosmos.base.tendermint.v1beta1.ProofOps":{"type":"object","properties":{"ops":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"key":{"type":"string","format":"byte"},"data":{"type":"string","format":"byte"}},"description":"ProofOp defines an operation used for calculating Merkle root. The data could\\nbe arbitrary format, providing nessecary data for example neighbouring node\\nhash.\\n\\nNote: This type is a duplicate of the ProofOp proto type defined in\\nTendermint."}}},"description":"ProofOps is Merkle proof defined by the list of ProofOps.\\n\\nNote: This type is a duplicate of the ProofOps proto type defined in\\nTendermint."},"cosmos.base.tendermint.v1beta1.Validator":{"type":"object","properties":{"address":{"type":"string"},"pub_key":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}},"description":"Validator is the type for the validator-set."},"cosmos.base.tendermint.v1beta1.VersionInfo":{"type":"object","properties":{"name":{"type":"string"},"app_name":{"type":"string"},"version":{"type":"string"},"git_commit":{"type":"string"},"build_tags":{"type":"string"},"go_version":{"type":"string"},"build_deps":{"type":"array","items":{"type":"object","properties":{"path":{"type":"string","title":"module path"},"version":{"type":"string","title":"module version"},"sum":{"type":"string","title":"checksum"}},"title":"Module is the type for VersionInfo"}},"cosmos_sdk_version":{"type":"string","title":"Since: cosmos-sdk 0.43"}},"description":"VersionInfo is the type for the GetNodeInfoResponse message."},"tendermint.crypto.PublicKey":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"tendermint.p2p.DefaultNodeInfo":{"type":"object","properties":{"protocol_version":{"type":"object","properties":{"p2p":{"type":"string","format":"uint64"},"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}}},"default_node_id":{"type":"string"},"listen_addr":{"type":"string"},"network":{"type":"string"},"version":{"type":"string"},"channels":{"type":"string","format":"byte"},"moniker":{"type":"string"},"other":{"type":"object","properties":{"tx_index":{"type":"string"},"rpc_address":{"type":"string"}}}}},"tendermint.p2p.DefaultNodeInfoOther":{"type":"object","properties":{"tx_index":{"type":"string"},"rpc_address":{"type":"string"}}},"tendermint.p2p.ProtocolVersion":{"type":"object","properties":{"p2p":{"type":"string","format":"uint64"},"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}}},"tendermint.types.Block":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"data":{"type":"object","properties":{"txs":{"type":"array","items":{"type":"string","format":"byte"},"description":"Txs that will be applied by state @ block.Height+1.\\nNOTE: not all txs here are valid.  We\'re just agreeing on the order first.\\nThis means that block.AppHash does not include these txs."}},"title":"Data contains the set of transactions included in the block"},"evidence":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}}}}},"last_commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"tendermint.types.BlockID":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"tendermint.types.BlockIDFlag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"tendermint.types.Commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."},"tendermint.types.CommitSig":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."},"tendermint.types.Data":{"type":"object","properties":{"txs":{"type":"array","items":{"type":"string","format":"byte"},"description":"Txs that will be applied by state @ block.Height+1.\\nNOTE: not all txs here are valid.  We\'re just agreeing on the order first.\\nThis means that block.AppHash does not include these txs."}},"title":"Data contains the set of transactions included in the block"},"tendermint.types.DuplicateVoteEvidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"tendermint.types.Evidence":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}},"tendermint.types.EvidenceList":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}}}}},"tendermint.types.Header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"tendermint.types.LightBlock":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"tendermint.types.LightClientAttackEvidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."},"tendermint.types.PartSetHeader":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"},"tendermint.types.SignedHeader":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"tendermint.types.SignedMsgType":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"tendermint.types.Validator":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"tendermint.types.ValidatorSet":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}},"tendermint.types.Vote":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"tendermint.version.Consensus":{"type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"cosmos.base.v1beta1.DecCoin":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."},"cosmos.distribution.v1beta1.DelegationDelegatorReward":{"type":"object","properties":{"validator_address":{"type":"string"},"reward":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."}}},"description":"DelegationDelegatorReward represents the properties\\nof a delegator\'s delegation reward."},"cosmos.distribution.v1beta1.Params":{"type":"object","properties":{"community_tax":{"type":"string"},"base_proposer_reward":{"type":"string"},"bonus_proposer_reward":{"type":"string"},"withdraw_addr_enabled":{"type":"boolean"}},"description":"Params defines the set of params for the distribution module."},"cosmos.distribution.v1beta1.QueryCommunityPoolResponse":{"type":"object","properties":{"pool":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."},"description":"pool defines community pool\'s coins."}},"description":"QueryCommunityPoolResponse is the response type for the Query/CommunityPool\\nRPC method."},"cosmos.distribution.v1beta1.QueryDelegationRewardsResponse":{"type":"object","properties":{"rewards":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."},"description":"rewards defines the rewards accrued by a delegation."}},"description":"QueryDelegationRewardsResponse is the response type for the\\nQuery/DelegationRewards RPC method."},"cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse":{"type":"object","properties":{"rewards":{"type":"array","items":{"type":"object","properties":{"validator_address":{"type":"string"},"reward":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."}}},"description":"DelegationDelegatorReward represents the properties\\nof a delegator\'s delegation reward."},"description":"rewards defines all the rewards accrued by a delegator."},"total":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."},"description":"total defines the sum of all the rewards."}},"description":"QueryDelegationTotalRewardsResponse is the response type for the\\nQuery/DelegationTotalRewards RPC method."},"cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"string"},"description":"validators defines the validators a delegator is delegating for."}},"description":"QueryDelegatorValidatorsResponse is the response type for the\\nQuery/DelegatorValidators RPC method."},"cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse":{"type":"object","properties":{"withdraw_address":{"type":"string","description":"withdraw_address defines the delegator address to query for."}},"description":"QueryDelegatorWithdrawAddressResponse is the response type for the\\nQuery/DelegatorWithdrawAddress RPC method."},"cosmos.distribution.v1beta1.QueryParamsResponse":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"community_tax":{"type":"string"},"base_proposer_reward":{"type":"string"},"bonus_proposer_reward":{"type":"string"},"withdraw_addr_enabled":{"type":"boolean"}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."},"cosmos.distribution.v1beta1.QueryValidatorCommissionResponse":{"type":"object","properties":{"commission":{"description":"commission defines the commision the validator received.","type":"object","properties":{"commission":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."}}}}},"title":"QueryValidatorCommissionResponse is the response type for the\\nQuery/ValidatorCommission RPC method"},"cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse":{"type":"object","properties":{"rewards":{"type":"object","properties":{"rewards":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."}}},"description":"ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\\nfor a validator inexpensive to track, allows simple sanity checks."}},"description":"QueryValidatorOutstandingRewardsResponse is the response type for the\\nQuery/ValidatorOutstandingRewards RPC method."},"cosmos.distribution.v1beta1.QueryValidatorSlashesResponse":{"type":"object","properties":{"slashes":{"type":"array","items":{"type":"object","properties":{"validator_period":{"type":"string","format":"uint64"},"fraction":{"type":"string"}},"description":"ValidatorSlashEvent represents a validator slash event.\\nHeight is implicit within the store key.\\nThis is needed to calculate appropriate amount of staking tokens\\nfor delegations which are withdrawn after a slash has occurred."},"description":"slashes defines the slashes the validator received."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryValidatorSlashesResponse is the response type for the\\nQuery/ValidatorSlashes RPC method."},"cosmos.distribution.v1beta1.ValidatorAccumulatedCommission":{"type":"object","properties":{"commission":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."}}},"description":"ValidatorAccumulatedCommission represents accumulated commission\\nfor a validator kept as a running counter, can be withdrawn at any time."},"cosmos.distribution.v1beta1.ValidatorOutstandingRewards":{"type":"object","properties":{"rewards":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"DecCoin defines a token with a denomination and a decimal amount.\\n\\nNOTE: The amount field is an Dec which implements the custom method\\nsignatures required by gogoproto."}}},"description":"ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\\nfor a validator inexpensive to track, allows simple sanity checks."},"cosmos.distribution.v1beta1.ValidatorSlashEvent":{"type":"object","properties":{"validator_period":{"type":"string","format":"uint64"},"fraction":{"type":"string"}},"description":"ValidatorSlashEvent represents a validator slash event.\\nHeight is implicit within the store key.\\nThis is needed to calculate appropriate amount of staking tokens\\nfor delegations which are withdrawn after a slash has occurred."},"cosmos.evidence.v1beta1.QueryAllEvidenceResponse":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"evidence returns all evidences."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC\\nmethod."},"cosmos.evidence.v1beta1.QueryEvidenceResponse":{"type":"object","properties":{"evidence":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"description":"QueryEvidenceResponse is the response type for the Query/Evidence RPC method."},"cosmos.gov.v1beta1.Deposit":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"depositor":{"type":"string"},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}}},"description":"Deposit defines an amount deposited by an account address to an active\\nproposal."},"cosmos.gov.v1beta1.DepositParams":{"type":"object","properties":{"min_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"Minimum deposit for a proposal to enter voting period."},"max_deposit_period":{"type":"string","description":"Maximum period for Atom holders to deposit on a proposal. Initial value: 2\\n months."}},"description":"DepositParams defines the params for deposits on governance proposals."},"cosmos.gov.v1beta1.Proposal":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"content":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"status":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus enumerates the valid statuses of a proposal.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed."},"final_tally_result":{"description":"final_tally_result is the final tally result of the proposal. When\\nquerying a proposal via gRPC, this field is not populated until the\\nproposal\'s voting period has ended.","type":"object","properties":{"yes":{"type":"string"},"abstain":{"type":"string"},"no":{"type":"string"},"no_with_veto":{"type":"string"}}},"submit_time":{"type":"string","format":"date-time"},"deposit_end_time":{"type":"string","format":"date-time"},"total_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"voting_start_time":{"type":"string","format":"date-time"},"voting_end_time":{"type":"string","format":"date-time"}},"description":"Proposal defines the core field members of a governance proposal."},"cosmos.gov.v1beta1.ProposalStatus":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus enumerates the valid statuses of a proposal.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed."},"cosmos.gov.v1beta1.QueryDepositResponse":{"type":"object","properties":{"deposit":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"depositor":{"type":"string"},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}}},"description":"Deposit defines an amount deposited by an account address to an active\\nproposal."}},"description":"QueryDepositResponse is the response type for the Query/Deposit RPC method."},"cosmos.gov.v1beta1.QueryDepositsResponse":{"type":"object","properties":{"deposits":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"depositor":{"type":"string"},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}}},"description":"Deposit defines an amount deposited by an account address to an active\\nproposal."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryDepositsResponse is the response type for the Query/Deposits RPC method."},"cosmos.gov.v1beta1.QueryParamsResponse":{"type":"object","properties":{"voting_params":{"description":"voting_params defines the parameters related to voting.","type":"object","properties":{"voting_period":{"type":"string","description":"Length of the voting period."}}},"deposit_params":{"description":"deposit_params defines the parameters related to deposit.","type":"object","properties":{"min_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"Minimum deposit for a proposal to enter voting period."},"max_deposit_period":{"type":"string","description":"Maximum period for Atom holders to deposit on a proposal. Initial value: 2\\n months."}}},"tally_params":{"description":"tally_params defines the parameters related to tally.","type":"object","properties":{"quorum":{"type":"string","format":"byte","description":"Minimum percentage of total stake needed to vote for a result to be\\n considered valid."},"threshold":{"type":"string","format":"byte","description":"Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."},"veto_threshold":{"type":"string","format":"byte","description":"Minimum value of Veto votes to Total votes ratio for proposal to be\\n vetoed. Default value: 1/3."}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."},"cosmos.gov.v1beta1.QueryProposalResponse":{"type":"object","properties":{"proposal":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"content":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"status":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus enumerates the valid statuses of a proposal.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed."},"final_tally_result":{"description":"final_tally_result is the final tally result of the proposal. When\\nquerying a proposal via gRPC, this field is not populated until the\\nproposal\'s voting period has ended.","type":"object","properties":{"yes":{"type":"string"},"abstain":{"type":"string"},"no":{"type":"string"},"no_with_veto":{"type":"string"}}},"submit_time":{"type":"string","format":"date-time"},"deposit_end_time":{"type":"string","format":"date-time"},"total_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"voting_start_time":{"type":"string","format":"date-time"},"voting_end_time":{"type":"string","format":"date-time"}},"description":"Proposal defines the core field members of a governance proposal."}},"description":"QueryProposalResponse is the response type for the Query/Proposal RPC method."},"cosmos.gov.v1beta1.QueryProposalsResponse":{"type":"object","properties":{"proposals":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"content":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"status":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus enumerates the valid statuses of a proposal.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed."},"final_tally_result":{"description":"final_tally_result is the final tally result of the proposal. When\\nquerying a proposal via gRPC, this field is not populated until the\\nproposal\'s voting period has ended.","type":"object","properties":{"yes":{"type":"string"},"abstain":{"type":"string"},"no":{"type":"string"},"no_with_veto":{"type":"string"}}},"submit_time":{"type":"string","format":"date-time"},"deposit_end_time":{"type":"string","format":"date-time"},"total_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"voting_start_time":{"type":"string","format":"date-time"},"voting_end_time":{"type":"string","format":"date-time"}},"description":"Proposal defines the core field members of a governance proposal."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryProposalsResponse is the response type for the Query/Proposals RPC\\nmethod."},"cosmos.gov.v1beta1.QueryTallyResultResponse":{"type":"object","properties":{"tally":{"description":"tally defines the requested tally.","type":"object","properties":{"yes":{"type":"string"},"abstain":{"type":"string"},"no":{"type":"string"},"no_with_veto":{"type":"string"}}}},"description":"QueryTallyResultResponse is the response type for the Query/Tally RPC method."},"cosmos.gov.v1beta1.QueryVoteResponse":{"type":"object","properties":{"vote":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"voter":{"type":"string"},"option":{"description":"Deprecated: Prefer to use `options` instead. This field is set in queries\\nif and only if `len(options) == 1` and that option has weight 1. In all\\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.","type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED"},"options":{"type":"array","items":{"type":"object","properties":{"option":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"weight":{"type":"string"}},"description":"WeightedVoteOption defines a unit of vote for vote split.\\n\\nSince: cosmos-sdk 0.43"},"title":"Since: cosmos-sdk 0.43"}},"description":"Vote defines a vote on a governance proposal.\\nA Vote consists of a proposal ID, the voter, and the vote option."}},"description":"QueryVoteResponse is the response type for the Query/Vote RPC method."},"cosmos.gov.v1beta1.QueryVotesResponse":{"type":"object","properties":{"votes":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"voter":{"type":"string"},"option":{"description":"Deprecated: Prefer to use `options` instead. This field is set in queries\\nif and only if `len(options) == 1` and that option has weight 1. In all\\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.","type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED"},"options":{"type":"array","items":{"type":"object","properties":{"option":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"weight":{"type":"string"}},"description":"WeightedVoteOption defines a unit of vote for vote split.\\n\\nSince: cosmos-sdk 0.43"},"title":"Since: cosmos-sdk 0.43"}},"description":"Vote defines a vote on a governance proposal.\\nA Vote consists of a proposal ID, the voter, and the vote option."},"description":"votes defined the queried votes."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryVotesResponse is the response type for the Query/Votes RPC method."},"cosmos.gov.v1beta1.TallyParams":{"type":"object","properties":{"quorum":{"type":"string","format":"byte","description":"Minimum percentage of total stake needed to vote for a result to be\\n considered valid."},"threshold":{"type":"string","format":"byte","description":"Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."},"veto_threshold":{"type":"string","format":"byte","description":"Minimum value of Veto votes to Total votes ratio for proposal to be\\n vetoed. Default value: 1/3."}},"description":"TallyParams defines the params for tallying votes on governance proposals."},"cosmos.gov.v1beta1.TallyResult":{"type":"object","properties":{"yes":{"type":"string"},"abstain":{"type":"string"},"no":{"type":"string"},"no_with_veto":{"type":"string"}},"description":"TallyResult defines a standard tally for a governance proposal."},"cosmos.gov.v1beta1.Vote":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"voter":{"type":"string"},"option":{"description":"Deprecated: Prefer to use `options` instead. This field is set in queries\\nif and only if `len(options) == 1` and that option has weight 1. In all\\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.","type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED"},"options":{"type":"array","items":{"type":"object","properties":{"option":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"weight":{"type":"string"}},"description":"WeightedVoteOption defines a unit of vote for vote split.\\n\\nSince: cosmos-sdk 0.43"},"title":"Since: cosmos-sdk 0.43"}},"description":"Vote defines a vote on a governance proposal.\\nA Vote consists of a proposal ID, the voter, and the vote option."},"cosmos.gov.v1beta1.VoteOption":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"cosmos.gov.v1beta1.VotingParams":{"type":"object","properties":{"voting_period":{"type":"string","description":"Length of the voting period."}},"description":"VotingParams defines the params for voting on governance proposals."},"cosmos.gov.v1beta1.WeightedVoteOption":{"type":"object","properties":{"option":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"weight":{"type":"string"}},"description":"WeightedVoteOption defines a unit of vote for vote split.\\n\\nSince: cosmos-sdk 0.43"},"cosmos.gov.v1.Deposit":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"depositor":{"type":"string"},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}}},"description":"Deposit defines an amount deposited by an account address to an active\\nproposal."},"cosmos.gov.v1.DepositParams":{"type":"object","properties":{"min_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"Minimum deposit for a proposal to enter voting period."},"max_deposit_period":{"type":"string","description":"Maximum period for Atom holders to deposit on a proposal. Initial value: 2\\n months."}},"description":"DepositParams defines the params for deposits on governance proposals."},"cosmos.gov.v1.Proposal":{"type":"object","properties":{"id":{"type":"string","format":"uint64"},"messages":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"status":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus enumerates the valid statuses of a proposal.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed."},"final_tally_result":{"description":"final_tally_result is the final tally result of the proposal. When\\nquerying a proposal via gRPC, this field is not populated until the\\nproposal\'s voting period has ended.","type":"object","properties":{"yes_count":{"type":"string"},"abstain_count":{"type":"string"},"no_count":{"type":"string"},"no_with_veto_count":{"type":"string"}}},"submit_time":{"type":"string","format":"date-time"},"deposit_end_time":{"type":"string","format":"date-time"},"total_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"voting_start_time":{"type":"string","format":"date-time"},"voting_end_time":{"type":"string","format":"date-time"},"metadata":{"type":"string","description":"metadata is any arbitrary metadata attached to the proposal."}},"description":"Proposal defines the core field members of a governance proposal."},"cosmos.gov.v1.ProposalStatus":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus enumerates the valid statuses of a proposal.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed."},"cosmos.gov.v1.QueryDepositResponse":{"type":"object","properties":{"deposit":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"depositor":{"type":"string"},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}}},"description":"Deposit defines an amount deposited by an account address to an active\\nproposal."}},"description":"QueryDepositResponse is the response type for the Query/Deposit RPC method."},"cosmos.gov.v1.QueryDepositsResponse":{"type":"object","properties":{"deposits":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"depositor":{"type":"string"},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}}},"description":"Deposit defines an amount deposited by an account address to an active\\nproposal."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryDepositsResponse is the response type for the Query/Deposits RPC method."},"cosmos.gov.v1.QueryParamsResponse":{"type":"object","properties":{"voting_params":{"description":"voting_params defines the parameters related to voting.","type":"object","properties":{"voting_period":{"type":"string","description":"Length of the voting period."}}},"deposit_params":{"description":"deposit_params defines the parameters related to deposit.","type":"object","properties":{"min_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"Minimum deposit for a proposal to enter voting period."},"max_deposit_period":{"type":"string","description":"Maximum period for Atom holders to deposit on a proposal. Initial value: 2\\n months."}}},"tally_params":{"description":"tally_params defines the parameters related to tally.","type":"object","properties":{"quorum":{"type":"string","description":"Minimum percentage of total stake needed to vote for a result to be\\n considered valid."},"threshold":{"type":"string","description":"Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."},"veto_threshold":{"type":"string","description":"Minimum value of Veto votes to Total votes ratio for proposal to be\\n vetoed. Default value: 1/3."}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."},"cosmos.gov.v1.QueryProposalResponse":{"type":"object","properties":{"proposal":{"type":"object","properties":{"id":{"type":"string","format":"uint64"},"messages":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"status":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus enumerates the valid statuses of a proposal.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed."},"final_tally_result":{"description":"final_tally_result is the final tally result of the proposal. When\\nquerying a proposal via gRPC, this field is not populated until the\\nproposal\'s voting period has ended.","type":"object","properties":{"yes_count":{"type":"string"},"abstain_count":{"type":"string"},"no_count":{"type":"string"},"no_with_veto_count":{"type":"string"}}},"submit_time":{"type":"string","format":"date-time"},"deposit_end_time":{"type":"string","format":"date-time"},"total_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"voting_start_time":{"type":"string","format":"date-time"},"voting_end_time":{"type":"string","format":"date-time"},"metadata":{"type":"string","description":"metadata is any arbitrary metadata attached to the proposal."}},"description":"Proposal defines the core field members of a governance proposal."}},"description":"QueryProposalResponse is the response type for the Query/Proposal RPC method."},"cosmos.gov.v1.QueryProposalsResponse":{"type":"object","properties":{"proposals":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64"},"messages":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"status":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_DEPOSIT_PERIOD","PROPOSAL_STATUS_VOTING_PERIOD","PROPOSAL_STATUS_PASSED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_FAILED"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus enumerates the valid statuses of a proposal.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\\nperiod.\\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\\nperiod.\\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\\npassed.\\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\\nbeen rejected.\\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\\nfailed."},"final_tally_result":{"description":"final_tally_result is the final tally result of the proposal. When\\nquerying a proposal via gRPC, this field is not populated until the\\nproposal\'s voting period has ended.","type":"object","properties":{"yes_count":{"type":"string"},"abstain_count":{"type":"string"},"no_count":{"type":"string"},"no_with_veto_count":{"type":"string"}}},"submit_time":{"type":"string","format":"date-time"},"deposit_end_time":{"type":"string","format":"date-time"},"total_deposit":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"voting_start_time":{"type":"string","format":"date-time"},"voting_end_time":{"type":"string","format":"date-time"},"metadata":{"type":"string","description":"metadata is any arbitrary metadata attached to the proposal."}},"description":"Proposal defines the core field members of a governance proposal."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryProposalsResponse is the response type for the Query/Proposals RPC\\nmethod."},"cosmos.gov.v1.QueryTallyResultResponse":{"type":"object","properties":{"tally":{"description":"tally defines the requested tally.","type":"object","properties":{"yes_count":{"type":"string"},"abstain_count":{"type":"string"},"no_count":{"type":"string"},"no_with_veto_count":{"type":"string"}}}},"description":"QueryTallyResultResponse is the response type for the Query/Tally RPC method."},"cosmos.gov.v1.QueryVoteResponse":{"type":"object","properties":{"vote":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"voter":{"type":"string"},"options":{"type":"array","items":{"type":"object","properties":{"option":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"weight":{"type":"string"}},"description":"WeightedVoteOption defines a unit of vote for vote split."}},"metadata":{"type":"string","description":"metadata is any  arbitrary metadata to attached to the vote."}},"description":"Vote defines a vote on a governance proposal.\\nA Vote consists of a proposal ID, the voter, and the vote option."}},"description":"QueryVoteResponse is the response type for the Query/Vote RPC method."},"cosmos.gov.v1.QueryVotesResponse":{"type":"object","properties":{"votes":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"voter":{"type":"string"},"options":{"type":"array","items":{"type":"object","properties":{"option":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"weight":{"type":"string"}},"description":"WeightedVoteOption defines a unit of vote for vote split."}},"metadata":{"type":"string","description":"metadata is any  arbitrary metadata to attached to the vote."}},"description":"Vote defines a vote on a governance proposal.\\nA Vote consists of a proposal ID, the voter, and the vote option."},"description":"votes defined the queried votes."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryVotesResponse is the response type for the Query/Votes RPC method."},"cosmos.gov.v1.TallyParams":{"type":"object","properties":{"quorum":{"type":"string","description":"Minimum percentage of total stake needed to vote for a result to be\\n considered valid."},"threshold":{"type":"string","description":"Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."},"veto_threshold":{"type":"string","description":"Minimum value of Veto votes to Total votes ratio for proposal to be\\n vetoed. Default value: 1/3."}},"description":"TallyParams defines the params for tallying votes on governance proposals."},"cosmos.gov.v1.TallyResult":{"type":"object","properties":{"yes_count":{"type":"string"},"abstain_count":{"type":"string"},"no_count":{"type":"string"},"no_with_veto_count":{"type":"string"}},"description":"TallyResult defines a standard tally for a governance proposal."},"cosmos.gov.v1.Vote":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64"},"voter":{"type":"string"},"options":{"type":"array","items":{"type":"object","properties":{"option":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"weight":{"type":"string"}},"description":"WeightedVoteOption defines a unit of vote for vote split."}},"metadata":{"type":"string","description":"metadata is any  arbitrary metadata to attached to the vote."}},"description":"Vote defines a vote on a governance proposal.\\nA Vote consists of a proposal ID, the voter, and the vote option."},"cosmos.gov.v1.VoteOption":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"cosmos.gov.v1.VotingParams":{"type":"object","properties":{"voting_period":{"type":"string","description":"Length of the voting period."}},"description":"VotingParams defines the params for voting on governance proposals."},"cosmos.gov.v1.WeightedVoteOption":{"type":"object","properties":{"option":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given governance proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"weight":{"type":"string"}},"description":"WeightedVoteOption defines a unit of vote for vote split."},"cosmos.mint.v1beta1.Params":{"type":"object","properties":{"mint_denom":{"type":"string","title":"type of coin to mint"},"inflation_rate_change":{"type":"string","title":"maximum annual change in inflation rate"},"inflation_max":{"type":"string","title":"maximum inflation rate"},"inflation_min":{"type":"string","title":"minimum inflation rate"},"goal_bonded":{"type":"string","title":"goal of percent bonded atoms"},"blocks_per_year":{"type":"string","format":"uint64","title":"expected blocks per year"}},"description":"Params holds parameters for the mint module."},"cosmos.mint.v1beta1.QueryAnnualProvisionsResponse":{"type":"object","properties":{"annual_provisions":{"type":"string","format":"byte","description":"annual_provisions is the current minting annual provisions value."}},"description":"QueryAnnualProvisionsResponse is the response type for the\\nQuery/AnnualProvisions RPC method."},"cosmos.mint.v1beta1.QueryInflationResponse":{"type":"object","properties":{"inflation":{"type":"string","format":"byte","description":"inflation is the current minting inflation value."}},"description":"QueryInflationResponse is the response type for the Query/Inflation RPC\\nmethod."},"cosmos.mint.v1beta1.QueryParamsResponse":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"mint_denom":{"type":"string","title":"type of coin to mint"},"inflation_rate_change":{"type":"string","title":"maximum annual change in inflation rate"},"inflation_max":{"type":"string","title":"maximum inflation rate"},"inflation_min":{"type":"string","title":"minimum inflation rate"},"goal_bonded":{"type":"string","title":"goal of percent bonded atoms"},"blocks_per_year":{"type":"string","format":"uint64","title":"expected blocks per year"}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."},"cosmos.params.v1beta1.ParamChange":{"type":"object","properties":{"subspace":{"type":"string"},"key":{"type":"string"},"value":{"type":"string"}},"description":"ParamChange defines an individual parameter change, for use in\\nParameterChangeProposal."},"cosmos.params.v1beta1.QueryParamsResponse":{"type":"object","properties":{"param":{"description":"param defines the queried parameter.","type":"object","properties":{"subspace":{"type":"string"},"key":{"type":"string"},"value":{"type":"string"}}}},"description":"QueryParamsResponse is response type for the Query/Params RPC method."},"cosmos.params.v1beta1.QuerySubspacesResponse":{"type":"object","properties":{"subspaces":{"type":"array","items":{"type":"object","properties":{"subspace":{"type":"string"},"keys":{"type":"array","items":{"type":"string"}}},"description":"Subspace defines a parameter subspace name and all the keys that exist for\\nthe subspace.\\n\\nSince: cosmos-sdk 0.46"}}},"description":"QuerySubspacesResponse defines the response types for querying for all\\nregistered subspaces and all keys for a subspace.\\n\\nSince: cosmos-sdk 0.46"},"cosmos.params.v1beta1.Subspace":{"type":"object","properties":{"subspace":{"type":"string"},"keys":{"type":"array","items":{"type":"string"}}},"description":"Subspace defines a parameter subspace name and all the keys that exist for\\nthe subspace.\\n\\nSince: cosmos-sdk 0.46"},"cosmos.quarantine.v1beta1.AutoResponse":{"type":"string","enum":["AUTO_RESPONSE_UNSPECIFIED","AUTO_RESPONSE_ACCEPT","AUTO_RESPONSE_DECLINE"],"default":"AUTO_RESPONSE_UNSPECIFIED","description":"AutoResponse enumerates the quarantine auto-response options.\\n\\n - AUTO_RESPONSE_UNSPECIFIED: AUTO_RESPONSE_UNSPECIFIED defines that an automatic response has not been specified.\\nThis means that no automatic action should be taken, i.e. this auto-response is off,\\nand default quarantine behavior is used.\\n - AUTO_RESPONSE_ACCEPT: AUTO_RESPONSE_ACCEPT defines that sends should be automatically accepted, bypassing quarantine.\\n - AUTO_RESPONSE_DECLINE: AUTO_RESPONSE_DECLINE defines that sends should be automatically declined."},"cosmos.quarantine.v1beta1.AutoResponseEntry":{"type":"object","properties":{"to_address":{"type":"string","description":"to_address is the receiving address."},"from_address":{"type":"string","description":"from_address is the sending address."},"response":{"description":"response is the auto-response setting for these two addresses.","type":"string","enum":["AUTO_RESPONSE_UNSPECIFIED","AUTO_RESPONSE_ACCEPT","AUTO_RESPONSE_DECLINE"],"default":"AUTO_RESPONSE_UNSPECIFIED"}},"description":"AutoResponseEntry defines the auto response to one address from another."},"cosmos.quarantine.v1beta1.QuarantinedFunds":{"type":"object","properties":{"to_address":{"type":"string","description":"to_address is the intended recipient of the coins that have been quarantined."},"unaccepted_from_addresses":{"type":"array","items":{"type":"string"},"description":"unaccepted_from_addresses are the senders that have not been part of an accept yet for these coins."},"coins":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"coins is the amount currently in quarantined for the two addresses."},"declined":{"type":"boolean","description":"declined is true if these funds were previously declined."}},"description":"QuarantinedFunds defines structure that represents coins that have been quarantined."},"cosmos.quarantine.v1beta1.QueryAutoResponsesResponse":{"type":"object","properties":{"auto_responses":{"type":"array","items":{"type":"object","properties":{"to_address":{"type":"string","description":"to_address is the receiving address."},"from_address":{"type":"string","description":"from_address is the sending address."},"response":{"description":"response is the auto-response setting for these two addresses.","type":"string","enum":["AUTO_RESPONSE_UNSPECIFIED","AUTO_RESPONSE_ACCEPT","AUTO_RESPONSE_DECLINE"],"default":"AUTO_RESPONSE_UNSPECIFIED"}},"description":"AutoResponseEntry defines the auto response to one address from another."},"description":"auto_responses are the auto-response entries from the provided query."},"pagination":{"description":"pagination defines the pagination parameters of the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAutoResponsesResponse defines the RPC response of a AutoResponses query."},"cosmos.quarantine.v1beta1.QueryIsQuarantinedResponse":{"type":"object","properties":{"is_quarantined":{"type":"boolean","description":"is_quarantined is true if the to_address has opted into quarantine."}},"description":"QueryIsQuarantinedResponse defines the RPC response of an IsQuarantined query."},"cosmos.quarantine.v1beta1.QueryQuarantinedFundsResponse":{"type":"object","properties":{"quarantinedFunds":{"type":"array","items":{"type":"object","properties":{"to_address":{"type":"string","description":"to_address is the intended recipient of the coins that have been quarantined."},"unaccepted_from_addresses":{"type":"array","items":{"type":"string"},"description":"unaccepted_from_addresses are the senders that have not been part of an accept yet for these coins."},"coins":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"coins is the amount currently in quarantined for the two addresses."},"declined":{"type":"boolean","description":"declined is true if these funds were previously declined."}},"description":"QuarantinedFunds defines structure that represents coins that have been quarantined."},"description":"quarantinedFunds is info about coins sitting in quarantine."},"pagination":{"description":"pagination defines the pagination parameters of the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryQuarantinedFundsResponse defines the RPC response of a QuarantinedFunds query."},"cosmos.slashing.v1beta1.Params":{"type":"object","properties":{"signed_blocks_window":{"type":"string","format":"int64"},"min_signed_per_window":{"type":"string","format":"byte"},"downtime_jail_duration":{"type":"string"},"slash_fraction_double_sign":{"type":"string","format":"byte"},"slash_fraction_downtime":{"type":"string","format":"byte"}},"description":"Params represents the parameters used for by the slashing module."},"cosmos.slashing.v1beta1.QueryParamsResponse":{"type":"object","properties":{"params":{"type":"object","properties":{"signed_blocks_window":{"type":"string","format":"int64"},"min_signed_per_window":{"type":"string","format":"byte"},"downtime_jail_duration":{"type":"string"},"slash_fraction_double_sign":{"type":"string","format":"byte"},"slash_fraction_downtime":{"type":"string","format":"byte"}},"description":"Params represents the parameters used for by the slashing module."}},"title":"QueryParamsResponse is the response type for the Query/Params RPC method"},"cosmos.slashing.v1beta1.QuerySigningInfoResponse":{"type":"object","properties":{"val_signing_info":{"type":"object","properties":{"address":{"type":"string"},"start_height":{"type":"string","format":"int64","title":"Height at which validator was first a candidate OR was unjailed"},"index_offset":{"type":"string","format":"int64","description":"Index which is incremented each time the validator was a bonded\\nin a block and may have signed a precommit or not. This in conjunction with the\\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."},"jailed_until":{"type":"string","format":"date-time","description":"Timestamp until which the validator is jailed due to liveness downtime."},"tombstoned":{"type":"boolean","description":"Whether or not a validator has been tombstoned (killed out of validator set). It is set\\nonce the validator commits an equivocation or for any other configured misbehiavor."},"missed_blocks_counter":{"type":"string","format":"int64","description":"A counter kept to avoid unnecessary array reads.\\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."}},"description":"ValidatorSigningInfo defines a validator\'s signing info for monitoring their\\nliveness activity.","title":"val_signing_info is the signing info of requested val cons address"}},"title":"QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC\\nmethod"},"cosmos.slashing.v1beta1.QuerySigningInfosResponse":{"type":"object","properties":{"info":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string"},"start_height":{"type":"string","format":"int64","title":"Height at which validator was first a candidate OR was unjailed"},"index_offset":{"type":"string","format":"int64","description":"Index which is incremented each time the validator was a bonded\\nin a block and may have signed a precommit or not. This in conjunction with the\\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."},"jailed_until":{"type":"string","format":"date-time","description":"Timestamp until which the validator is jailed due to liveness downtime."},"tombstoned":{"type":"boolean","description":"Whether or not a validator has been tombstoned (killed out of validator set). It is set\\nonce the validator commits an equivocation or for any other configured misbehiavor."},"missed_blocks_counter":{"type":"string","format":"int64","description":"A counter kept to avoid unnecessary array reads.\\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."}},"description":"ValidatorSigningInfo defines a validator\'s signing info for monitoring their\\nliveness activity."},"title":"info is the signing info of all validators"},"pagination":{"type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}},"description":"PageResponse is to be embedded in gRPC response messages where the\\ncorresponding request message has used PageRequest.\\n\\n message SomeResponse {\\n         repeated Bar results = 1;\\n         PageResponse page = 2;\\n }"}},"title":"QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC\\nmethod"},"cosmos.slashing.v1beta1.ValidatorSigningInfo":{"type":"object","properties":{"address":{"type":"string"},"start_height":{"type":"string","format":"int64","title":"Height at which validator was first a candidate OR was unjailed"},"index_offset":{"type":"string","format":"int64","description":"Index which is incremented each time the validator was a bonded\\nin a block and may have signed a precommit or not. This in conjunction with the\\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`."},"jailed_until":{"type":"string","format":"date-time","description":"Timestamp until which the validator is jailed due to liveness downtime."},"tombstoned":{"type":"boolean","description":"Whether or not a validator has been tombstoned (killed out of validator set). It is set\\nonce the validator commits an equivocation or for any other configured misbehiavor."},"missed_blocks_counter":{"type":"string","format":"int64","description":"A counter kept to avoid unnecessary array reads.\\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`."}},"description":"ValidatorSigningInfo defines a validator\'s signing info for monitoring their\\nliveness activity."},"cosmos.staking.v1beta1.BondStatus":{"type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED","description":"BondStatus is the status of a validator.\\n\\n - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.\\n - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.\\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded."},"cosmos.staking.v1beta1.Commission":{"type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}},"description":"Commission defines commission parameters for a given validator."},"cosmos.staking.v1beta1.CommissionRates":{"type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}},"description":"CommissionRates defines the initial commission rates to be used for creating\\na validator."},"cosmos.staking.v1beta1.Delegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"shares":{"type":"string","description":"shares define the delegation shares received."}},"description":"Delegation represents the bond with tokens held by an account. It is\\nowned by one delegator, and is associated with the voting power of one\\nvalidator."},"cosmos.staking.v1beta1.DelegationResponse":{"type":"object","properties":{"delegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"shares":{"type":"string","description":"shares define the delegation shares received."}},"description":"Delegation represents the bond with tokens held by an account. It is\\nowned by one delegator, and is associated with the voting power of one\\nvalidator."},"balance":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"DelegationResponse is equivalent to Delegation except that it contains a\\nbalance in addition to shares which is more suitable for client responses."},"cosmos.staking.v1beta1.Description":{"type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}},"description":"Description defines a validator description."},"cosmos.staking.v1beta1.HistoricalInfo":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"title":"prev block info","type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}}},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"valset":{"type":"array","items":{"type":"object","properties":{"operator_address":{"type":"string","description":"operator_address defines the address of the validator\'s operator; bech encoded in JSON."},"consensus_pubkey":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"jailed":{"type":"boolean","description":"jailed defined whether the validator has been jailed from bonded status or not."},"status":{"description":"status is the validator status (bonded/unbonding/unbonded).","type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED"},"tokens":{"type":"string","description":"tokens define the delegated tokens (incl. self-delegation)."},"delegator_shares":{"type":"string","description":"delegator_shares defines total shares issued to a validator\'s delegators."},"description":{"description":"description defines the description terms for the validator.","type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}}},"unbonding_height":{"type":"string","format":"int64","description":"unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."},"unbonding_time":{"type":"string","format":"date-time","description":"unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."},"commission":{"description":"commission defines the commission parameters.","type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}}},"min_self_delegation":{"type":"string","description":"min_self_delegation is the validator\'s self declared minimum self delegation.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Validator defines a validator, together with the total amount of the\\nValidator\'s bond shares and their exchange rate to coins. Slashing results in\\na decrease in the exchange rate, allowing correct calculation of future\\nundelegations without iterating over delegators. When coins are delegated to\\nthis validator, the validator is credited with a delegation whose number of\\nbond shares is based on the amount of coins delegated divided by the current\\nexchange rate. Voting power can be calculated as total bonded shares\\nmultiplied by exchange rate."}}},"description":"HistoricalInfo contains header and validator information for a given block.\\nIt is stored as part of staking module\'s state, which persists the `n` most\\nrecent HistoricalInfo\\n(`n` is set by the staking module\'s `historical_entries` parameter)."},"cosmos.staking.v1beta1.Params":{"type":"object","properties":{"unbonding_time":{"type":"string","description":"unbonding_time is the time duration of unbonding."},"max_validators":{"type":"integer","format":"int64","description":"max_validators is the maximum number of validators."},"max_entries":{"type":"integer","format":"int64","description":"max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio)."},"historical_entries":{"type":"integer","format":"int64","description":"historical_entries is the number of historical entries to persist."},"bond_denom":{"type":"string","description":"bond_denom defines the bondable coin denomination."},"min_commission_rate":{"type":"string","title":"min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators"}},"description":"Params defines the parameters for the staking module."},"cosmos.staking.v1beta1.Pool":{"type":"object","properties":{"not_bonded_tokens":{"type":"string"},"bonded_tokens":{"type":"string"}},"description":"Pool is used for tracking bonded and not-bonded token supply of the bond\\ndenomination."},"cosmos.staking.v1beta1.QueryDelegationResponse":{"type":"object","properties":{"delegation_response":{"type":"object","properties":{"delegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"shares":{"type":"string","description":"shares define the delegation shares received."}},"description":"Delegation represents the bond with tokens held by an account. It is\\nowned by one delegator, and is associated with the voting power of one\\nvalidator."},"balance":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"DelegationResponse is equivalent to Delegation except that it contains a\\nbalance in addition to shares which is more suitable for client responses."}},"description":"QueryDelegationResponse is response type for the Query/Delegation RPC method."},"cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse":{"type":"object","properties":{"delegation_responses":{"type":"array","items":{"type":"object","properties":{"delegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"shares":{"type":"string","description":"shares define the delegation shares received."}},"description":"Delegation represents the bond with tokens held by an account. It is\\nowned by one delegator, and is associated with the voting power of one\\nvalidator."},"balance":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"DelegationResponse is equivalent to Delegation except that it contains a\\nbalance in addition to shares which is more suitable for client responses."},"description":"delegation_responses defines all the delegations\' info of a delegator."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryDelegatorDelegationsResponse is response type for the\\nQuery/DelegatorDelegations RPC method."},"cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse":{"type":"object","properties":{"unbonding_responses":{"type":"array","items":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"entries":{"type":"array","items":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height is the height which the unbonding took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time is the unix time for unbonding completion."},"initial_balance":{"type":"string","description":"initial_balance defines the tokens initially scheduled to receive at completion."},"balance":{"type":"string","description":"balance defines the tokens to receive at completion."}},"description":"UnbondingDelegationEntry defines an unbonding object with relevant metadata."},"description":"entries are the unbonding delegation entries."}},"description":"UnbondingDelegation stores all of a single delegator\'s unbonding bonds\\nfor a single validator in an time-ordered list."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryUnbondingDelegatorDelegationsResponse is response type for the\\nQuery/UnbondingDelegatorDelegations RPC method."},"cosmos.staking.v1beta1.QueryDelegatorValidatorResponse":{"type":"object","properties":{"validator":{"type":"object","properties":{"operator_address":{"type":"string","description":"operator_address defines the address of the validator\'s operator; bech encoded in JSON."},"consensus_pubkey":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"jailed":{"type":"boolean","description":"jailed defined whether the validator has been jailed from bonded status or not."},"status":{"description":"status is the validator status (bonded/unbonding/unbonded).","type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED"},"tokens":{"type":"string","description":"tokens define the delegated tokens (incl. self-delegation)."},"delegator_shares":{"type":"string","description":"delegator_shares defines total shares issued to a validator\'s delegators."},"description":{"description":"description defines the description terms for the validator.","type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}}},"unbonding_height":{"type":"string","format":"int64","description":"unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."},"unbonding_time":{"type":"string","format":"date-time","description":"unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."},"commission":{"description":"commission defines the commission parameters.","type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}}},"min_self_delegation":{"type":"string","description":"min_self_delegation is the validator\'s self declared minimum self delegation.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Validator defines a validator, together with the total amount of the\\nValidator\'s bond shares and their exchange rate to coins. Slashing results in\\na decrease in the exchange rate, allowing correct calculation of future\\nundelegations without iterating over delegators. When coins are delegated to\\nthis validator, the validator is credited with a delegation whose number of\\nbond shares is based on the amount of coins delegated divided by the current\\nexchange rate. Voting power can be calculated as total bonded shares\\nmultiplied by exchange rate."}},"description":"QueryDelegatorValidatorResponse response type for the\\nQuery/DelegatorValidator RPC method."},"cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"operator_address":{"type":"string","description":"operator_address defines the address of the validator\'s operator; bech encoded in JSON."},"consensus_pubkey":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"jailed":{"type":"boolean","description":"jailed defined whether the validator has been jailed from bonded status or not."},"status":{"description":"status is the validator status (bonded/unbonding/unbonded).","type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED"},"tokens":{"type":"string","description":"tokens define the delegated tokens (incl. self-delegation)."},"delegator_shares":{"type":"string","description":"delegator_shares defines total shares issued to a validator\'s delegators."},"description":{"description":"description defines the description terms for the validator.","type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}}},"unbonding_height":{"type":"string","format":"int64","description":"unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."},"unbonding_time":{"type":"string","format":"date-time","description":"unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."},"commission":{"description":"commission defines the commission parameters.","type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}}},"min_self_delegation":{"type":"string","description":"min_self_delegation is the validator\'s self declared minimum self delegation.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Validator defines a validator, together with the total amount of the\\nValidator\'s bond shares and their exchange rate to coins. Slashing results in\\na decrease in the exchange rate, allowing correct calculation of future\\nundelegations without iterating over delegators. When coins are delegated to\\nthis validator, the validator is credited with a delegation whose number of\\nbond shares is based on the amount of coins delegated divided by the current\\nexchange rate. Voting power can be calculated as total bonded shares\\nmultiplied by exchange rate."},"description":"validators defines the validators\' info of a delegator."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryDelegatorValidatorsResponse is response type for the\\nQuery/DelegatorValidators RPC method."},"cosmos.staking.v1beta1.QueryHistoricalInfoResponse":{"type":"object","properties":{"hist":{"description":"hist defines the historical info at the given height.","type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"title":"prev block info","type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}}},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"valset":{"type":"array","items":{"type":"object","properties":{"operator_address":{"type":"string","description":"operator_address defines the address of the validator\'s operator; bech encoded in JSON."},"consensus_pubkey":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"jailed":{"type":"boolean","description":"jailed defined whether the validator has been jailed from bonded status or not."},"status":{"description":"status is the validator status (bonded/unbonding/unbonded).","type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED"},"tokens":{"type":"string","description":"tokens define the delegated tokens (incl. self-delegation)."},"delegator_shares":{"type":"string","description":"delegator_shares defines total shares issued to a validator\'s delegators."},"description":{"description":"description defines the description terms for the validator.","type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}}},"unbonding_height":{"type":"string","format":"int64","description":"unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."},"unbonding_time":{"type":"string","format":"date-time","description":"unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."},"commission":{"description":"commission defines the commission parameters.","type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}}},"min_self_delegation":{"type":"string","description":"min_self_delegation is the validator\'s self declared minimum self delegation.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Validator defines a validator, together with the total amount of the\\nValidator\'s bond shares and their exchange rate to coins. Slashing results in\\na decrease in the exchange rate, allowing correct calculation of future\\nundelegations without iterating over delegators. When coins are delegated to\\nthis validator, the validator is credited with a delegation whose number of\\nbond shares is based on the amount of coins delegated divided by the current\\nexchange rate. Voting power can be calculated as total bonded shares\\nmultiplied by exchange rate."}}}}},"description":"QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC\\nmethod."},"cosmos.staking.v1beta1.QueryParamsResponse":{"type":"object","properties":{"params":{"description":"params holds all the parameters of this module.","type":"object","properties":{"unbonding_time":{"type":"string","description":"unbonding_time is the time duration of unbonding."},"max_validators":{"type":"integer","format":"int64","description":"max_validators is the maximum number of validators."},"max_entries":{"type":"integer","format":"int64","description":"max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio)."},"historical_entries":{"type":"integer","format":"int64","description":"historical_entries is the number of historical entries to persist."},"bond_denom":{"type":"string","description":"bond_denom defines the bondable coin denomination."},"min_commission_rate":{"type":"string","title":"min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators"}}}},"description":"QueryParamsResponse is response type for the Query/Params RPC method."},"cosmos.staking.v1beta1.QueryPoolResponse":{"type":"object","properties":{"pool":{"description":"pool defines the pool info.","type":"object","properties":{"not_bonded_tokens":{"type":"string"},"bonded_tokens":{"type":"string"}}}},"description":"QueryPoolResponse is response type for the Query/Pool RPC method."},"cosmos.staking.v1beta1.QueryRedelegationsResponse":{"type":"object","properties":{"redelegation_responses":{"type":"array","items":{"type":"object","properties":{"redelegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_src_address":{"type":"string","description":"validator_src_address is the validator redelegation source operator address."},"validator_dst_address":{"type":"string","description":"validator_dst_address is the validator redelegation destination operator address."},"entries":{"type":"array","items":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height  defines the height which the redelegation took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time defines the unix time for redelegation completion."},"initial_balance":{"type":"string","description":"initial_balance defines the initial balance when redelegation started."},"shares_dst":{"type":"string","description":"shares_dst is the amount of destination-validator shares created by redelegation."}},"description":"RedelegationEntry defines a redelegation object with relevant metadata."},"description":"entries are the redelegation entries."}},"description":"Redelegation contains the list of a particular delegator\'s redelegating bonds\\nfrom a particular source validator to a particular destination validator."},"entries":{"type":"array","items":{"type":"object","properties":{"redelegation_entry":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height  defines the height which the redelegation took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time defines the unix time for redelegation completion."},"initial_balance":{"type":"string","description":"initial_balance defines the initial balance when redelegation started."},"shares_dst":{"type":"string","description":"shares_dst is the amount of destination-validator shares created by redelegation."}},"description":"RedelegationEntry defines a redelegation object with relevant metadata."},"balance":{"type":"string"}},"description":"RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\\ncontains a balance in addition to shares which is more suitable for client\\nresponses."}}},"description":"RedelegationResponse is equivalent to a Redelegation except that its entries\\ncontain a balance in addition to shares which is more suitable for client\\nresponses."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryRedelegationsResponse is response type for the Query/Redelegations RPC\\nmethod."},"cosmos.staking.v1beta1.QueryUnbondingDelegationResponse":{"type":"object","properties":{"unbond":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"entries":{"type":"array","items":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height is the height which the unbonding took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time is the unix time for unbonding completion."},"initial_balance":{"type":"string","description":"initial_balance defines the tokens initially scheduled to receive at completion."},"balance":{"type":"string","description":"balance defines the tokens to receive at completion."}},"description":"UnbondingDelegationEntry defines an unbonding object with relevant metadata."},"description":"entries are the unbonding delegation entries."}},"description":"UnbondingDelegation stores all of a single delegator\'s unbonding bonds\\nfor a single validator in an time-ordered list."}},"description":"QueryDelegationResponse is response type for the Query/UnbondingDelegation\\nRPC method."},"cosmos.staking.v1beta1.QueryValidatorDelegationsResponse":{"type":"object","properties":{"delegation_responses":{"type":"array","items":{"type":"object","properties":{"delegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"shares":{"type":"string","description":"shares define the delegation shares received."}},"description":"Delegation represents the bond with tokens held by an account. It is\\nowned by one delegator, and is associated with the voting power of one\\nvalidator."},"balance":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"DelegationResponse is equivalent to Delegation except that it contains a\\nbalance in addition to shares which is more suitable for client responses."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"title":"QueryValidatorDelegationsResponse is response type for the\\nQuery/ValidatorDelegations RPC method"},"cosmos.staking.v1beta1.QueryValidatorResponse":{"type":"object","properties":{"validator":{"type":"object","properties":{"operator_address":{"type":"string","description":"operator_address defines the address of the validator\'s operator; bech encoded in JSON."},"consensus_pubkey":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"jailed":{"type":"boolean","description":"jailed defined whether the validator has been jailed from bonded status or not."},"status":{"description":"status is the validator status (bonded/unbonding/unbonded).","type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED"},"tokens":{"type":"string","description":"tokens define the delegated tokens (incl. self-delegation)."},"delegator_shares":{"type":"string","description":"delegator_shares defines total shares issued to a validator\'s delegators."},"description":{"description":"description defines the description terms for the validator.","type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}}},"unbonding_height":{"type":"string","format":"int64","description":"unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."},"unbonding_time":{"type":"string","format":"date-time","description":"unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."},"commission":{"description":"commission defines the commission parameters.","type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}}},"min_self_delegation":{"type":"string","description":"min_self_delegation is the validator\'s self declared minimum self delegation.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Validator defines a validator, together with the total amount of the\\nValidator\'s bond shares and their exchange rate to coins. Slashing results in\\na decrease in the exchange rate, allowing correct calculation of future\\nundelegations without iterating over delegators. When coins are delegated to\\nthis validator, the validator is credited with a delegation whose number of\\nbond shares is based on the amount of coins delegated divided by the current\\nexchange rate. Voting power can be calculated as total bonded shares\\nmultiplied by exchange rate."}},"title":"QueryValidatorResponse is response type for the Query/Validator RPC method"},"cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse":{"type":"object","properties":{"unbonding_responses":{"type":"array","items":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"entries":{"type":"array","items":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height is the height which the unbonding took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time is the unix time for unbonding completion."},"initial_balance":{"type":"string","description":"initial_balance defines the tokens initially scheduled to receive at completion."},"balance":{"type":"string","description":"balance defines the tokens to receive at completion."}},"description":"UnbondingDelegationEntry defines an unbonding object with relevant metadata."},"description":"entries are the unbonding delegation entries."}},"description":"UnbondingDelegation stores all of a single delegator\'s unbonding bonds\\nfor a single validator in an time-ordered list."}},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryValidatorUnbondingDelegationsResponse is response type for the\\nQuery/ValidatorUnbondingDelegations RPC method."},"cosmos.staking.v1beta1.QueryValidatorsResponse":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"operator_address":{"type":"string","description":"operator_address defines the address of the validator\'s operator; bech encoded in JSON."},"consensus_pubkey":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"jailed":{"type":"boolean","description":"jailed defined whether the validator has been jailed from bonded status or not."},"status":{"description":"status is the validator status (bonded/unbonding/unbonded).","type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED"},"tokens":{"type":"string","description":"tokens define the delegated tokens (incl. self-delegation)."},"delegator_shares":{"type":"string","description":"delegator_shares defines total shares issued to a validator\'s delegators."},"description":{"description":"description defines the description terms for the validator.","type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}}},"unbonding_height":{"type":"string","format":"int64","description":"unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."},"unbonding_time":{"type":"string","format":"date-time","description":"unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."},"commission":{"description":"commission defines the commission parameters.","type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}}},"min_self_delegation":{"type":"string","description":"min_self_delegation is the validator\'s self declared minimum self delegation.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Validator defines a validator, together with the total amount of the\\nValidator\'s bond shares and their exchange rate to coins. Slashing results in\\na decrease in the exchange rate, allowing correct calculation of future\\nundelegations without iterating over delegators. When coins are delegated to\\nthis validator, the validator is credited with a delegation whose number of\\nbond shares is based on the amount of coins delegated divided by the current\\nexchange rate. Voting power can be calculated as total bonded shares\\nmultiplied by exchange rate."},"description":"validators contains all the queried validators."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"title":"QueryValidatorsResponse is response type for the Query/Validators RPC method"},"cosmos.staking.v1beta1.Redelegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_src_address":{"type":"string","description":"validator_src_address is the validator redelegation source operator address."},"validator_dst_address":{"type":"string","description":"validator_dst_address is the validator redelegation destination operator address."},"entries":{"type":"array","items":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height  defines the height which the redelegation took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time defines the unix time for redelegation completion."},"initial_balance":{"type":"string","description":"initial_balance defines the initial balance when redelegation started."},"shares_dst":{"type":"string","description":"shares_dst is the amount of destination-validator shares created by redelegation."}},"description":"RedelegationEntry defines a redelegation object with relevant metadata."},"description":"entries are the redelegation entries."}},"description":"Redelegation contains the list of a particular delegator\'s redelegating bonds\\nfrom a particular source validator to a particular destination validator."},"cosmos.staking.v1beta1.RedelegationEntry":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height  defines the height which the redelegation took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time defines the unix time for redelegation completion."},"initial_balance":{"type":"string","description":"initial_balance defines the initial balance when redelegation started."},"shares_dst":{"type":"string","description":"shares_dst is the amount of destination-validator shares created by redelegation."}},"description":"RedelegationEntry defines a redelegation object with relevant metadata."},"cosmos.staking.v1beta1.RedelegationEntryResponse":{"type":"object","properties":{"redelegation_entry":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height  defines the height which the redelegation took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time defines the unix time for redelegation completion."},"initial_balance":{"type":"string","description":"initial_balance defines the initial balance when redelegation started."},"shares_dst":{"type":"string","description":"shares_dst is the amount of destination-validator shares created by redelegation."}},"description":"RedelegationEntry defines a redelegation object with relevant metadata."},"balance":{"type":"string"}},"description":"RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\\ncontains a balance in addition to shares which is more suitable for client\\nresponses."},"cosmos.staking.v1beta1.RedelegationResponse":{"type":"object","properties":{"redelegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_src_address":{"type":"string","description":"validator_src_address is the validator redelegation source operator address."},"validator_dst_address":{"type":"string","description":"validator_dst_address is the validator redelegation destination operator address."},"entries":{"type":"array","items":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height  defines the height which the redelegation took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time defines the unix time for redelegation completion."},"initial_balance":{"type":"string","description":"initial_balance defines the initial balance when redelegation started."},"shares_dst":{"type":"string","description":"shares_dst is the amount of destination-validator shares created by redelegation."}},"description":"RedelegationEntry defines a redelegation object with relevant metadata."},"description":"entries are the redelegation entries."}},"description":"Redelegation contains the list of a particular delegator\'s redelegating bonds\\nfrom a particular source validator to a particular destination validator."},"entries":{"type":"array","items":{"type":"object","properties":{"redelegation_entry":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height  defines the height which the redelegation took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time defines the unix time for redelegation completion."},"initial_balance":{"type":"string","description":"initial_balance defines the initial balance when redelegation started."},"shares_dst":{"type":"string","description":"shares_dst is the amount of destination-validator shares created by redelegation."}},"description":"RedelegationEntry defines a redelegation object with relevant metadata."},"balance":{"type":"string"}},"description":"RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\\ncontains a balance in addition to shares which is more suitable for client\\nresponses."}}},"description":"RedelegationResponse is equivalent to a Redelegation except that its entries\\ncontain a balance in addition to shares which is more suitable for client\\nresponses."},"cosmos.staking.v1beta1.UnbondingDelegation":{"type":"object","properties":{"delegator_address":{"type":"string","description":"delegator_address is the bech32-encoded address of the delegator."},"validator_address":{"type":"string","description":"validator_address is the bech32-encoded address of the validator."},"entries":{"type":"array","items":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height is the height which the unbonding took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time is the unix time for unbonding completion."},"initial_balance":{"type":"string","description":"initial_balance defines the tokens initially scheduled to receive at completion."},"balance":{"type":"string","description":"balance defines the tokens to receive at completion."}},"description":"UnbondingDelegationEntry defines an unbonding object with relevant metadata."},"description":"entries are the unbonding delegation entries."}},"description":"UnbondingDelegation stores all of a single delegator\'s unbonding bonds\\nfor a single validator in an time-ordered list."},"cosmos.staking.v1beta1.UnbondingDelegationEntry":{"type":"object","properties":{"creation_height":{"type":"string","format":"int64","description":"creation_height is the height which the unbonding took place."},"completion_time":{"type":"string","format":"date-time","description":"completion_time is the unix time for unbonding completion."},"initial_balance":{"type":"string","description":"initial_balance defines the tokens initially scheduled to receive at completion."},"balance":{"type":"string","description":"balance defines the tokens to receive at completion."}},"description":"UnbondingDelegationEntry defines an unbonding object with relevant metadata."},"cosmos.staking.v1beta1.Validator":{"type":"object","properties":{"operator_address":{"type":"string","description":"operator_address defines the address of the validator\'s operator; bech encoded in JSON."},"consensus_pubkey":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"jailed":{"type":"boolean","description":"jailed defined whether the validator has been jailed from bonded status or not."},"status":{"description":"status is the validator status (bonded/unbonding/unbonded).","type":"string","enum":["BOND_STATUS_UNSPECIFIED","BOND_STATUS_UNBONDED","BOND_STATUS_UNBONDING","BOND_STATUS_BONDED"],"default":"BOND_STATUS_UNSPECIFIED"},"tokens":{"type":"string","description":"tokens define the delegated tokens (incl. self-delegation)."},"delegator_shares":{"type":"string","description":"delegator_shares defines total shares issued to a validator\'s delegators."},"description":{"description":"description defines the description terms for the validator.","type":"object","properties":{"moniker":{"type":"string","description":"moniker defines a human-readable name for the validator."},"identity":{"type":"string","description":"identity defines an optional identity signature (ex. UPort or Keybase)."},"website":{"type":"string","description":"website defines an optional website link."},"security_contact":{"type":"string","description":"security_contact defines an optional email for security contact."},"details":{"type":"string","description":"details define other optional details."}}},"unbonding_height":{"type":"string","format":"int64","description":"unbonding_height defines, if unbonding, the height at which this validator has begun unbonding."},"unbonding_time":{"type":"string","format":"date-time","description":"unbonding_time defines, if unbonding, the min time for the validator to complete unbonding."},"commission":{"description":"commission defines the commission parameters.","type":"object","properties":{"commission_rates":{"description":"commission_rates defines the initial commission rates to be used for creating a validator.","type":"object","properties":{"rate":{"type":"string","description":"rate is the commission rate charged to delegators, as a fraction."},"max_rate":{"type":"string","description":"max_rate defines the maximum commission rate which validator can ever charge, as a fraction."},"max_change_rate":{"type":"string","description":"max_change_rate defines the maximum daily increase of the validator commission, as a fraction."}}},"update_time":{"type":"string","format":"date-time","description":"update_time is the last time the commission rate was changed."}}},"min_self_delegation":{"type":"string","description":"min_self_delegation is the validator\'s self declared minimum self delegation.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Validator defines a validator, together with the total amount of the\\nValidator\'s bond shares and their exchange rate to coins. Slashing results in\\na decrease in the exchange rate, allowing correct calculation of future\\nundelegations without iterating over delegators. When coins are delegated to\\nthis validator, the validator is credited with a delegation whose number of\\nbond shares is based on the amount of coins delegated divided by the current\\nexchange rate. Voting power can be calculated as total bonded shares\\nmultiplied by exchange rate."},"cosmos.base.abci.v1beta1.ABCIMessageLog":{"type":"object","properties":{"msg_index":{"type":"integer","format":"int64"},"log":{"type":"string"},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"value":{"type":"string"}},"description":"Attribute defines an attribute wrapper where the key and value are\\nstrings instead of raw bytes."}}},"description":"StringEvent defines en Event object wrapper where all the attributes\\ncontain key/value pairs that are strings instead of raw bytes."},"description":"Events contains a slice of Event objects that were emitted during some\\nexecution."}},"description":"ABCIMessageLog defines a structure containing an indexed tx ABCI message log."},"cosmos.base.abci.v1beta1.Attribute":{"type":"object","properties":{"key":{"type":"string"},"value":{"type":"string"}},"description":"Attribute defines an attribute wrapper where the key and value are\\nstrings instead of raw bytes."},"cosmos.base.abci.v1beta1.GasInfo":{"type":"object","properties":{"gas_wanted":{"type":"string","format":"uint64","description":"GasWanted is the maximum units of work we allow this tx to perform."},"gas_used":{"type":"string","format":"uint64","description":"GasUsed is the amount of gas actually consumed."}},"description":"GasInfo defines tx execution gas context."},"cosmos.base.abci.v1beta1.Result":{"type":"object","properties":{"data":{"type":"string","format":"byte","description":"Data is any data returned from message or handler execution. It MUST be\\nlength prefixed in order to separate data from multiple message executions.\\nDeprecated. This field is still populated, but prefer msg_response instead\\nbecause it also contains the Msg response typeURL."},"log":{"type":"string","description":"Log contains the log information from message or handler execution."},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","format":"byte"},"value":{"type":"string","format":"byte"},"index":{"type":"boolean"}},"description":"EventAttribute is a single key-value pair, associated with an event."}}},"description":"Event allows application developers to attach additional information to\\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\\nLater, transactions may be queried using these events."},"description":"Events contains a slice of Event objects that were emitted during message\\nor handler execution."},"msg_responses":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"msg_responses contains the Msg handler responses type packed in Anys.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Result is the union of ResponseFormat and ResponseCheckTx."},"cosmos.base.abci.v1beta1.StringEvent":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"value":{"type":"string"}},"description":"Attribute defines an attribute wrapper where the key and value are\\nstrings instead of raw bytes."}}},"description":"StringEvent defines en Event object wrapper where all the attributes\\ncontain key/value pairs that are strings instead of raw bytes."},"cosmos.base.abci.v1beta1.TxResponse":{"type":"object","properties":{"height":{"type":"string","format":"int64","title":"The block height"},"txhash":{"type":"string","description":"The transaction hash."},"codespace":{"type":"string","title":"Namespace for the Code"},"code":{"type":"integer","format":"int64","description":"Response code."},"data":{"type":"string","description":"Result bytes, if any."},"raw_log":{"type":"string","description":"The output of the application\'s logger (raw string). May be\\nnon-deterministic."},"logs":{"type":"array","items":{"type":"object","properties":{"msg_index":{"type":"integer","format":"int64"},"log":{"type":"string"},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"value":{"type":"string"}},"description":"Attribute defines an attribute wrapper where the key and value are\\nstrings instead of raw bytes."}}},"description":"StringEvent defines en Event object wrapper where all the attributes\\ncontain key/value pairs that are strings instead of raw bytes."},"description":"Events contains a slice of Event objects that were emitted during some\\nexecution."}},"description":"ABCIMessageLog defines a structure containing an indexed tx ABCI message log."},"description":"The output of the application\'s logger (typed). May be non-deterministic."},"info":{"type":"string","description":"Additional information. May be non-deterministic."},"gas_wanted":{"type":"string","format":"int64","description":"Amount of gas requested for transaction."},"gas_used":{"type":"string","format":"int64","description":"Amount of gas consumed by transaction."},"tx":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"timestamp":{"type":"string","description":"Time of the previous block. For heights > 1, it\'s the weighted median of\\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\\nit\'s genesis time."},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","format":"byte"},"value":{"type":"string","format":"byte"},"index":{"type":"boolean"}},"description":"EventAttribute is a single key-value pair, associated with an event."}}},"description":"Event allows application developers to attach additional information to\\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\\nLater, transactions may be queried using these events."},"description":"Events defines all the events emitted by processing a transaction. Note,\\nthese events include those emitted by processing all the messages and those\\nemitted from the ante. Whereas Logs contains the events, with\\nadditional metadata, emitted only by processing the messages.\\n\\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"}},"description":"TxResponse defines a structure containing relevant tx data and metadata. The\\ntags are stringified and the log is JSON decoded."},"cosmos.crypto.multisig.v1beta1.CompactBitArray":{"type":"object","properties":{"extra_bits_stored":{"type":"integer","format":"int64"},"elems":{"type":"string","format":"byte"}},"description":"CompactBitArray is an implementation of a space efficient bit array.\\nThis is used to ensure that the encoded data takes up a minimal amount of\\nspace after proto encoding.\\nThis is not thread safe, and is not intended for concurrent usage."},"cosmos.tx.signing.v1beta1.SignMode":{"type":"string","enum":["SIGN_MODE_UNSPECIFIED","SIGN_MODE_DIRECT","SIGN_MODE_TEXTUAL","SIGN_MODE_DIRECT_AUX","SIGN_MODE_LEGACY_AMINO_JSON","SIGN_MODE_EIP_191"],"default":"SIGN_MODE_UNSPECIFIED","description":"SignMode represents a signing mode with its own security guarantees.\\n\\nThis enum should be considered a registry of all known sign modes\\nin the Cosmos ecosystem. Apps are not expected to support all known\\nsign modes. Apps that would like to support custom  sign modes are\\nencouraged to open a small PR against this file to add a new case\\nto this SignMode enum describing their sign mode so that different\\napps have a consistent version of this enum.\\n\\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\\nrejected.\\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\\nverified with raw bytes from Tx.\\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\\nhuman-readable textual representation on top of the binary representation\\nfrom SIGN_MODE_DIRECT. It is currently not supported.\\n - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses\\nSignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not\\nrequire signers signing over other signers\' `signer_info`. It also allows\\nfor adding Tips in transactions.\\n\\nSince: cosmos-sdk 0.46\\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\\nAmino JSON and will be removed in the future.\\n - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\\nSDK. Ref: https://eips.ethereum.org/EIPS/eip-191\\n\\nCurrently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\\nbut is not implemented on the SDK by default. To enable EIP-191, you need\\nto pass a custom `TxConfig` that has an implementation of\\n`SignModeHandler` for EIP-191. The SDK may decide to fully support\\nEIP-191 in the future.\\n\\nSince: cosmos-sdk 0.45.2"},"cosmos.tx.v1beta1.AuthInfo":{"type":"object","properties":{"signer_infos":{"type":"array","items":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.SignerInfo"},"description":"signer_infos defines the signing modes for the required signers. The number\\nand order of elements must match the required signers from TxBody\'s\\nmessages. The first element is the primary signer and the one which pays\\nthe fee."},"fee":{"description":"Fee is the fee and gas limit for the transaction. The first signer is the\\nprimary signer and the one which pays the fee. The fee can be calculated\\nbased on the cost of evaluating the body and doing signature verification\\nof the signers. This can be estimated via simulation.","type":"object","properties":{"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"title":"amount is the amount of coins to be paid as a fee"},"gas_limit":{"type":"string","format":"uint64","title":"gas_limit is the maximum gas that can be used in transaction processing\\nbefore an out of gas error occurs"},"payer":{"type":"string","description":"if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\\nthe payer must be a tx signer (and thus have signed this field in AuthInfo).\\nsetting this field does *not* change the ordering of required signers for the transaction."},"granter":{"type":"string","title":"if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\\nto pay fees instead of the fee payer\'s own balance. If an appropriate fee grant does not exist or the chain does\\nnot support fee grants, this will fail"}}},"tip":{"description":"Tip is the optional tip used for transactions fees paid in another denom.\\n\\nThis field is ignored if the chain didn\'t enable tips, i.e. didn\'t add the\\n`TipDecorator` in its posthandler.\\n\\nSince: cosmos-sdk 0.46","type":"object","properties":{"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"title":"amount is the amount of the tip"},"tipper":{"type":"string","title":"tipper is the address of the account paying for the tip"}}}},"description":"AuthInfo describes the fee and signer modes that are used to sign a\\ntransaction."},"cosmos.tx.v1beta1.BroadcastMode":{"type":"string","enum":["BROADCAST_MODE_UNSPECIFIED","BROADCAST_MODE_BLOCK","BROADCAST_MODE_SYNC","BROADCAST_MODE_ASYNC"],"default":"BROADCAST_MODE_UNSPECIFIED","description":"BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.\\n\\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\\n - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for\\nthe tx to be committed in a block.\\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for\\na CheckTx execution response only.\\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns\\nimmediately."},"cosmos.tx.v1beta1.BroadcastTxRequest":{"type":"object","properties":{"tx_bytes":{"type":"string","format":"byte","description":"tx_bytes is the raw transaction."},"mode":{"type":"string","enum":["BROADCAST_MODE_UNSPECIFIED","BROADCAST_MODE_BLOCK","BROADCAST_MODE_SYNC","BROADCAST_MODE_ASYNC"],"default":"BROADCAST_MODE_UNSPECIFIED","description":"BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.\\n\\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\\n - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for\\nthe tx to be committed in a block.\\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for\\na CheckTx execution response only.\\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns\\nimmediately."}},"description":"BroadcastTxRequest is the request type for the Service.BroadcastTxRequest\\nRPC method."},"cosmos.tx.v1beta1.BroadcastTxResponse":{"type":"object","properties":{"tx_response":{"type":"object","properties":{"height":{"type":"string","format":"int64","title":"The block height"},"txhash":{"type":"string","description":"The transaction hash."},"codespace":{"type":"string","title":"Namespace for the Code"},"code":{"type":"integer","format":"int64","description":"Response code."},"data":{"type":"string","description":"Result bytes, if any."},"raw_log":{"type":"string","description":"The output of the application\'s logger (raw string). May be\\nnon-deterministic."},"logs":{"type":"array","items":{"type":"object","properties":{"msg_index":{"type":"integer","format":"int64"},"log":{"type":"string"},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"value":{"type":"string"}},"description":"Attribute defines an attribute wrapper where the key and value are\\nstrings instead of raw bytes."}}},"description":"StringEvent defines en Event object wrapper where all the attributes\\ncontain key/value pairs that are strings instead of raw bytes."},"description":"Events contains a slice of Event objects that were emitted during some\\nexecution."}},"description":"ABCIMessageLog defines a structure containing an indexed tx ABCI message log."},"description":"The output of the application\'s logger (typed). May be non-deterministic."},"info":{"type":"string","description":"Additional information. May be non-deterministic."},"gas_wanted":{"type":"string","format":"int64","description":"Amount of gas requested for transaction."},"gas_used":{"type":"string","format":"int64","description":"Amount of gas consumed by transaction."},"tx":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"timestamp":{"type":"string","description":"Time of the previous block. For heights > 1, it\'s the weighted median of\\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\\nit\'s genesis time."},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","format":"byte"},"value":{"type":"string","format":"byte"},"index":{"type":"boolean"}},"description":"EventAttribute is a single key-value pair, associated with an event."}}},"description":"Event allows application developers to attach additional information to\\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\\nLater, transactions may be queried using these events."},"description":"Events defines all the events emitted by processing a transaction. Note,\\nthese events include those emitted by processing all the messages and those\\nemitted from the ante. Whereas Logs contains the events, with\\nadditional metadata, emitted only by processing the messages.\\n\\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"}},"description":"TxResponse defines a structure containing relevant tx data and metadata. The\\ntags are stringified and the log is JSON decoded."}},"description":"BroadcastTxResponse is the response type for the\\nService.BroadcastTx method."},"cosmos.tx.v1beta1.Fee":{"type":"object","properties":{"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"title":"amount is the amount of coins to be paid as a fee"},"gas_limit":{"type":"string","format":"uint64","title":"gas_limit is the maximum gas that can be used in transaction processing\\nbefore an out of gas error occurs"},"payer":{"type":"string","description":"if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\\nthe payer must be a tx signer (and thus have signed this field in AuthInfo).\\nsetting this field does *not* change the ordering of required signers for the transaction."},"granter":{"type":"string","title":"if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\\nto pay fees instead of the fee payer\'s own balance. If an appropriate fee grant does not exist or the chain does\\nnot support fee grants, this will fail"}},"description":"Fee includes the amount of coins paid in fees and the maximum\\ngas to be used by the transaction. The ratio yields an effective \\"gasprice\\",\\nwhich must be above some miminum to be accepted into the mempool."},"cosmos.tx.v1beta1.GetBlockWithTxsResponse":{"type":"object","properties":{"txs":{"type":"array","items":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.Tx"},"description":"txs are the transactions in the block."},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"block":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"data":{"type":"object","properties":{"txs":{"type":"array","items":{"type":"string","format":"byte"},"description":"Txs that will be applied by state @ block.Height+1.\\nNOTE: not all txs here are valid.  We\'re just agreeing on the order first.\\nThis means that block.AppHash does not include these txs."}},"title":"Data contains the set of transactions included in the block"},"evidence":{"type":"object","properties":{"evidence":{"type":"array","items":{"type":"object","properties":{"duplicate_vote_evidence":{"type":"object","properties":{"vote_a":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"vote_b":{"type":"object","properties":{"type":{"type":"string","enum":["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"],"default":"SIGNED_MSG_TYPE_UNKNOWN","description":"SignedMsgType is a type of signed message in the consensus.\\n\\n - SIGNED_MSG_TYPE_PREVOTE: Votes\\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals"},"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"timestamp":{"type":"string","format":"date-time"},"validator_address":{"type":"string","format":"byte"},"validator_index":{"type":"integer","format":"int32"},"signature":{"type":"string","format":"byte"}},"description":"Vote represents a prevote, precommit, or commit vote from validators for\\nconsensus."},"total_voting_power":{"type":"string","format":"int64"},"validator_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."},"light_client_attack_evidence":{"type":"object","properties":{"conflicting_block":{"type":"object","properties":{"signed_header":{"type":"object","properties":{"header":{"type":"object","properties":{"version":{"title":"basic block info","type":"object","properties":{"block":{"type":"string","format":"uint64"},"app":{"type":"string","format":"uint64"}},"description":"Consensus captures the consensus rules for processing a block in the blockchain,\\nincluding all blockchain data structures and the rules of the application\'s\\nstate transition machine."},"chain_id":{"type":"string"},"height":{"type":"string","format":"int64"},"time":{"type":"string","format":"date-time"},"last_block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"last_commit_hash":{"type":"string","format":"byte","title":"hashes of block data"},"data_hash":{"type":"string","format":"byte"},"validators_hash":{"type":"string","format":"byte","title":"hashes from the app output from the prev block"},"next_validators_hash":{"type":"string","format":"byte"},"consensus_hash":{"type":"string","format":"byte"},"app_hash":{"type":"string","format":"byte"},"last_results_hash":{"type":"string","format":"byte"},"evidence_hash":{"type":"string","format":"byte","title":"consensus info"},"proposer_address":{"type":"string","format":"byte"}},"description":"Header defines the structure of a block header."},"commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"validator_set":{"type":"object","properties":{"validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"proposer":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}},"total_voting_power":{"type":"string","format":"int64"}}}}},"common_height":{"type":"string","format":"int64"},"byzantine_validators":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","format":"byte"},"pub_key":{"type":"object","properties":{"ed25519":{"type":"string","format":"byte"},"secp256k1":{"type":"string","format":"byte"}},"title":"PublicKey defines the keys available for use with Validators"},"voting_power":{"type":"string","format":"int64"},"proposer_priority":{"type":"string","format":"int64"}}}},"total_voting_power":{"type":"string","format":"int64"},"timestamp":{"type":"string","format":"date-time"}},"description":"LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."}}}}}},"last_commit":{"type":"object","properties":{"height":{"type":"string","format":"int64"},"round":{"type":"integer","format":"int32"},"block_id":{"type":"object","properties":{"hash":{"type":"string","format":"byte"},"part_set_header":{"type":"object","properties":{"total":{"type":"integer","format":"int64"},"hash":{"type":"string","format":"byte"}},"title":"PartsetHeader"}},"title":"BlockID"},"signatures":{"type":"array","items":{"type":"object","properties":{"block_id_flag":{"type":"string","enum":["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"],"default":"BLOCK_ID_FLAG_UNKNOWN","title":"BlockIdFlag indicates which BlcokID the signature is for"},"validator_address":{"type":"string","format":"byte"},"timestamp":{"type":"string","format":"date-time"},"signature":{"type":"string","format":"byte"}},"description":"CommitSig is a part of the Vote included in a Commit."}}},"description":"Commit contains the evidence that a block was committed by a set of validators."}}},"pagination":{"description":"pagination defines a pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"GetBlockWithTxsResponse is the response type for the Service.GetBlockWithTxs method.\\n\\nSince: cosmos-sdk 0.45.2"},"cosmos.tx.v1beta1.GetTxResponse":{"type":"object","properties":{"tx":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.Tx"},"tx_response":{"type":"object","properties":{"height":{"type":"string","format":"int64","title":"The block height"},"txhash":{"type":"string","description":"The transaction hash."},"codespace":{"type":"string","title":"Namespace for the Code"},"code":{"type":"integer","format":"int64","description":"Response code."},"data":{"type":"string","description":"Result bytes, if any."},"raw_log":{"type":"string","description":"The output of the application\'s logger (raw string). May be\\nnon-deterministic."},"logs":{"type":"array","items":{"type":"object","properties":{"msg_index":{"type":"integer","format":"int64"},"log":{"type":"string"},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"value":{"type":"string"}},"description":"Attribute defines an attribute wrapper where the key and value are\\nstrings instead of raw bytes."}}},"description":"StringEvent defines en Event object wrapper where all the attributes\\ncontain key/value pairs that are strings instead of raw bytes."},"description":"Events contains a slice of Event objects that were emitted during some\\nexecution."}},"description":"ABCIMessageLog defines a structure containing an indexed tx ABCI message log."},"description":"The output of the application\'s logger (typed). May be non-deterministic."},"info":{"type":"string","description":"Additional information. May be non-deterministic."},"gas_wanted":{"type":"string","format":"int64","description":"Amount of gas requested for transaction."},"gas_used":{"type":"string","format":"int64","description":"Amount of gas consumed by transaction."},"tx":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"timestamp":{"type":"string","description":"Time of the previous block. For heights > 1, it\'s the weighted median of\\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\\nit\'s genesis time."},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","format":"byte"},"value":{"type":"string","format":"byte"},"index":{"type":"boolean"}},"description":"EventAttribute is a single key-value pair, associated with an event."}}},"description":"Event allows application developers to attach additional information to\\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\\nLater, transactions may be queried using these events."},"description":"Events defines all the events emitted by processing a transaction. Note,\\nthese events include those emitted by processing all the messages and those\\nemitted from the ante. Whereas Logs contains the events, with\\nadditional metadata, emitted only by processing the messages.\\n\\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"}},"description":"TxResponse defines a structure containing relevant tx data and metadata. The\\ntags are stringified and the log is JSON decoded."}},"description":"GetTxResponse is the response type for the Service.GetTx method."},"cosmos.tx.v1beta1.GetTxsEventResponse":{"type":"object","properties":{"txs":{"type":"array","items":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.Tx"},"description":"txs is the list of queried transactions."},"tx_responses":{"type":"array","items":{"type":"object","properties":{"height":{"type":"string","format":"int64","title":"The block height"},"txhash":{"type":"string","description":"The transaction hash."},"codespace":{"type":"string","title":"Namespace for the Code"},"code":{"type":"integer","format":"int64","description":"Response code."},"data":{"type":"string","description":"Result bytes, if any."},"raw_log":{"type":"string","description":"The output of the application\'s logger (raw string). May be\\nnon-deterministic."},"logs":{"type":"array","items":{"type":"object","properties":{"msg_index":{"type":"integer","format":"int64"},"log":{"type":"string"},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string"},"value":{"type":"string"}},"description":"Attribute defines an attribute wrapper where the key and value are\\nstrings instead of raw bytes."}}},"description":"StringEvent defines en Event object wrapper where all the attributes\\ncontain key/value pairs that are strings instead of raw bytes."},"description":"Events contains a slice of Event objects that were emitted during some\\nexecution."}},"description":"ABCIMessageLog defines a structure containing an indexed tx ABCI message log."},"description":"The output of the application\'s logger (typed). May be non-deterministic."},"info":{"type":"string","description":"Additional information. May be non-deterministic."},"gas_wanted":{"type":"string","format":"int64","description":"Amount of gas requested for transaction."},"gas_used":{"type":"string","format":"int64","description":"Amount of gas consumed by transaction."},"tx":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"timestamp":{"type":"string","description":"Time of the previous block. For heights > 1, it\'s the weighted median of\\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\\nit\'s genesis time."},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","format":"byte"},"value":{"type":"string","format":"byte"},"index":{"type":"boolean"}},"description":"EventAttribute is a single key-value pair, associated with an event."}}},"description":"Event allows application developers to attach additional information to\\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\\nLater, transactions may be queried using these events."},"description":"Events defines all the events emitted by processing a transaction. Note,\\nthese events include those emitted by processing all the messages and those\\nemitted from the ante. Whereas Logs contains the events, with\\nadditional metadata, emitted only by processing the messages.\\n\\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45"}},"description":"TxResponse defines a structure containing relevant tx data and metadata. The\\ntags are stringified and the log is JSON decoded."},"description":"tx_responses is the list of queried TxResponses."},"pagination":{"description":"pagination defines a pagination for the response.\\nDeprecated post v0.46.x: use total instead.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}},"total":{"type":"string","format":"uint64","title":"total is total number of results available"}},"description":"GetTxsEventResponse is the response type for the Service.TxsByEvents\\nRPC method."},"cosmos.tx.v1beta1.ModeInfo":{"type":"object","properties":{"single":{"title":"single represents a single signer","type":"object","properties":{"mode":{"title":"mode is the signing mode of the single signer","type":"string","enum":["SIGN_MODE_UNSPECIFIED","SIGN_MODE_DIRECT","SIGN_MODE_TEXTUAL","SIGN_MODE_DIRECT_AUX","SIGN_MODE_LEGACY_AMINO_JSON","SIGN_MODE_EIP_191"],"default":"SIGN_MODE_UNSPECIFIED","description":"SignMode represents a signing mode with its own security guarantees.\\n\\nThis enum should be considered a registry of all known sign modes\\nin the Cosmos ecosystem. Apps are not expected to support all known\\nsign modes. Apps that would like to support custom  sign modes are\\nencouraged to open a small PR against this file to add a new case\\nto this SignMode enum describing their sign mode so that different\\napps have a consistent version of this enum.\\n\\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\\nrejected.\\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\\nverified with raw bytes from Tx.\\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\\nhuman-readable textual representation on top of the binary representation\\nfrom SIGN_MODE_DIRECT. It is currently not supported.\\n - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses\\nSignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not\\nrequire signers signing over other signers\' `signer_info`. It also allows\\nfor adding Tips in transactions.\\n\\nSince: cosmos-sdk 0.46\\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\\nAmino JSON and will be removed in the future.\\n - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\\nSDK. Ref: https://eips.ethereum.org/EIPS/eip-191\\n\\nCurrently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\\nbut is not implemented on the SDK by default. To enable EIP-191, you need\\nto pass a custom `TxConfig` that has an implementation of\\n`SignModeHandler` for EIP-191. The SDK may decide to fully support\\nEIP-191 in the future.\\n\\nSince: cosmos-sdk 0.45.2"}}},"multi":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.ModeInfo.Multi"}},"description":"ModeInfo describes the signing mode of a single or nested multisig signer."},"cosmos.tx.v1beta1.ModeInfo.Multi":{"type":"object","properties":{"bitarray":{"title":"bitarray specifies which keys within the multisig are signing","type":"object","properties":{"extra_bits_stored":{"type":"integer","format":"int64"},"elems":{"type":"string","format":"byte"}},"description":"CompactBitArray is an implementation of a space efficient bit array.\\nThis is used to ensure that the encoded data takes up a minimal amount of\\nspace after proto encoding.\\nThis is not thread safe, and is not intended for concurrent usage."},"mode_infos":{"type":"array","items":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.ModeInfo"},"title":"mode_infos is the corresponding modes of the signers of the multisig\\nwhich could include nested multisig public keys"}},"title":"Multi is the mode info for a multisig public key"},"cosmos.tx.v1beta1.ModeInfo.Single":{"type":"object","properties":{"mode":{"title":"mode is the signing mode of the single signer","type":"string","enum":["SIGN_MODE_UNSPECIFIED","SIGN_MODE_DIRECT","SIGN_MODE_TEXTUAL","SIGN_MODE_DIRECT_AUX","SIGN_MODE_LEGACY_AMINO_JSON","SIGN_MODE_EIP_191"],"default":"SIGN_MODE_UNSPECIFIED","description":"SignMode represents a signing mode with its own security guarantees.\\n\\nThis enum should be considered a registry of all known sign modes\\nin the Cosmos ecosystem. Apps are not expected to support all known\\nsign modes. Apps that would like to support custom  sign modes are\\nencouraged to open a small PR against this file to add a new case\\nto this SignMode enum describing their sign mode so that different\\napps have a consistent version of this enum.\\n\\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\\nrejected.\\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\\nverified with raw bytes from Tx.\\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\\nhuman-readable textual representation on top of the binary representation\\nfrom SIGN_MODE_DIRECT. It is currently not supported.\\n - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses\\nSignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not\\nrequire signers signing over other signers\' `signer_info`. It also allows\\nfor adding Tips in transactions.\\n\\nSince: cosmos-sdk 0.46\\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\\nAmino JSON and will be removed in the future.\\n - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\\nSDK. Ref: https://eips.ethereum.org/EIPS/eip-191\\n\\nCurrently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\\nbut is not implemented on the SDK by default. To enable EIP-191, you need\\nto pass a custom `TxConfig` that has an implementation of\\n`SignModeHandler` for EIP-191. The SDK may decide to fully support\\nEIP-191 in the future.\\n\\nSince: cosmos-sdk 0.45.2"}},"title":"Single is the mode info for a single signer. It is structured as a message\\nto allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the\\nfuture"},"cosmos.tx.v1beta1.OrderBy":{"type":"string","enum":["ORDER_BY_UNSPECIFIED","ORDER_BY_ASC","ORDER_BY_DESC"],"default":"ORDER_BY_UNSPECIFIED","description":"- ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.\\n - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order\\n - ORDER_BY_DESC: ORDER_BY_DESC defines descending order","title":"OrderBy defines the sorting order"},"cosmos.tx.v1beta1.SignerInfo":{"type":"object","properties":{"public_key":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"mode_info":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.ModeInfo"},"sequence":{"type":"string","format":"uint64","description":"sequence is the sequence of the account, which describes the\\nnumber of committed transactions signed by a given address. It is used to\\nprevent replay attacks."}},"description":"SignerInfo describes the public key and signing mode of a single top-level\\nsigner."},"cosmos.tx.v1beta1.SimulateRequest":{"type":"object","properties":{"tx":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.Tx"},"tx_bytes":{"type":"string","format":"byte","description":"tx_bytes is the raw transaction.\\n\\nSince: cosmos-sdk 0.43"}},"description":"SimulateRequest is the request type for the Service.Simulate\\nRPC method."},"cosmos.tx.v1beta1.SimulateResponse":{"type":"object","properties":{"gas_info":{"description":"gas_info is the information about gas used in the simulation.","type":"object","properties":{"gas_wanted":{"type":"string","format":"uint64","description":"GasWanted is the maximum units of work we allow this tx to perform."},"gas_used":{"type":"string","format":"uint64","description":"GasUsed is the amount of gas actually consumed."}}},"result":{"description":"result is the result of the simulation.","type":"object","properties":{"data":{"type":"string","format":"byte","description":"Data is any data returned from message or handler execution. It MUST be\\nlength prefixed in order to separate data from multiple message executions.\\nDeprecated. This field is still populated, but prefer msg_response instead\\nbecause it also contains the Msg response typeURL."},"log":{"type":"string","description":"Log contains the log information from message or handler execution."},"events":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","format":"byte"},"value":{"type":"string","format":"byte"},"index":{"type":"boolean"}},"description":"EventAttribute is a single key-value pair, associated with an event."}}},"description":"Event allows application developers to attach additional information to\\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\\nLater, transactions may be queried using these events."},"description":"Events contains a slice of Event objects that were emitted during message\\nor handler execution."},"msg_responses":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"msg_responses contains the Msg handler responses type packed in Anys.\\n\\nSince: cosmos-sdk 0.46"}}}},"description":"SimulateResponse is the response type for the\\nService.SimulateRPC method."},"cosmos.tx.v1beta1.Tip":{"type":"object","properties":{"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"title":"amount is the amount of the tip"},"tipper":{"type":"string","title":"tipper is the address of the account paying for the tip"}},"description":"Tip is the tip used for meta-transactions.\\n\\nSince: cosmos-sdk 0.46"},"cosmos.tx.v1beta1.Tx":{"type":"object","properties":{"body":{"title":"body is the processable content of the transaction","type":"object","properties":{"messages":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"messages is a list of messages to be executed. The required signers of\\nthose messages define the number and order of elements in AuthInfo\'s\\nsigner_infos and Tx\'s signatures. Each required signer address is added to\\nthe list only the first time it occurs.\\nBy convention, the first required signer (usually from the first message)\\nis referred to as the primary signer and pays the fee for the whole\\ntransaction."},"memo":{"type":"string","description":"memo is any arbitrary note/comment to be added to the transaction.\\nWARNING: in clients, any publicly exposed text should not be called memo,\\nbut should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122)."},"timeout_height":{"type":"string","format":"uint64","title":"timeout is the block height after which this transaction will not\\nbe processed by the chain"},"extension_options":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"title":"extension_options are arbitrary options that can be added by chains\\nwhen the default options are not sufficient. If any of these are present\\nand can\'t be handled, the transaction will be rejected"},"non_critical_extension_options":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"title":"extension_options are arbitrary options that can be added by chains\\nwhen the default options are not sufficient. If any of these are present\\nand can\'t be handled, they will be ignored"}},"description":"TxBody is the body of a transaction that all signers sign over."},"auth_info":{"$ref":"#/components/schemas/cosmos.tx.v1beta1.AuthInfo"},"signatures":{"type":"array","items":{"type":"string","format":"byte"},"description":"signatures is a list of signatures that matches the length and order of\\nAuthInfo\'s signer_infos to allow connecting signature meta information like\\npublic key and signing mode by position."}},"description":"Tx is the standard type used for broadcasting transactions."},"cosmos.tx.v1beta1.TxBody":{"type":"object","properties":{"messages":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"messages is a list of messages to be executed. The required signers of\\nthose messages define the number and order of elements in AuthInfo\'s\\nsigner_infos and Tx\'s signatures. Each required signer address is added to\\nthe list only the first time it occurs.\\nBy convention, the first required signer (usually from the first message)\\nis referred to as the primary signer and pays the fee for the whole\\ntransaction."},"memo":{"type":"string","description":"memo is any arbitrary note/comment to be added to the transaction.\\nWARNING: in clients, any publicly exposed text should not be called memo,\\nbut should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122)."},"timeout_height":{"type":"string","format":"uint64","title":"timeout is the block height after which this transaction will not\\nbe processed by the chain"},"extension_options":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"title":"extension_options are arbitrary options that can be added by chains\\nwhen the default options are not sufficient. If any of these are present\\nand can\'t be handled, the transaction will be rejected"},"non_critical_extension_options":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"title":"extension_options are arbitrary options that can be added by chains\\nwhen the default options are not sufficient. If any of these are present\\nand can\'t be handled, they will be ignored"}},"description":"TxBody is the body of a transaction that all signers sign over."},"tendermint.abci.Event":{"type":"object","properties":{"type":{"type":"string"},"attributes":{"type":"array","items":{"type":"object","properties":{"key":{"type":"string","format":"byte"},"value":{"type":"string","format":"byte"},"index":{"type":"boolean"}},"description":"EventAttribute is a single key-value pair, associated with an event."}}},"description":"Event allows application developers to attach additional information to\\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\\nLater, transactions may be queried using these events."},"tendermint.abci.EventAttribute":{"type":"object","properties":{"key":{"type":"string","format":"byte"},"value":{"type":"string","format":"byte"},"index":{"type":"boolean"}},"description":"EventAttribute is a single key-value pair, associated with an event."},"cosmos.upgrade.v1beta1.ModuleVersion":{"type":"object","properties":{"name":{"type":"string","title":"name of the app module"},"version":{"type":"string","format":"uint64","title":"consensus version of the app module"}},"description":"ModuleVersion specifies a module and its consensus version.\\n\\nSince: cosmos-sdk 0.43"},"cosmos.upgrade.v1beta1.Plan":{"type":"object","properties":{"name":{"type":"string","description":"Sets the name for the upgrade. This name will be used by the upgraded\\nversion of the software to apply any special \\"on-upgrade\\" commands during\\nthe first BeginBlock method after the upgrade is applied. It is also used\\nto detect whether a software version can handle a given upgrade. If no\\nupgrade handler with this name has been set in the software, it will be\\nassumed that the software is out-of-date when the upgrade Time or Height is\\nreached and the software will exit."},"time":{"type":"string","format":"date-time","description":"Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\\nhas been removed from the SDK.\\nIf this field is not empty, an error will be thrown."},"height":{"type":"string","format":"int64","description":"The height at which the upgrade must be performed.\\nOnly used if Time is not set."},"info":{"type":"string","title":"Any application specific upgrade info to be included on-chain\\nsuch as a git commit that validators could automatically upgrade to"},"upgraded_client_state":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"description":"Plan specifies information about a planned upgrade and when it should occur."},"cosmos.upgrade.v1beta1.QueryAppliedPlanResponse":{"type":"object","properties":{"height":{"type":"string","format":"int64","description":"height is the block height at which the plan was applied."}},"description":"QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC\\nmethod."},"cosmos.upgrade.v1beta1.QueryAuthorityResponse":{"type":"object","properties":{"address":{"type":"string"}},"description":"Since: cosmos-sdk 0.46","title":"QueryAuthorityResponse is the response type for Query/Authority"},"cosmos.upgrade.v1beta1.QueryCurrentPlanResponse":{"type":"object","properties":{"plan":{"description":"plan is the current upgrade plan.","type":"object","properties":{"name":{"type":"string","description":"Sets the name for the upgrade. This name will be used by the upgraded\\nversion of the software to apply any special \\"on-upgrade\\" commands during\\nthe first BeginBlock method after the upgrade is applied. It is also used\\nto detect whether a software version can handle a given upgrade. If no\\nupgrade handler with this name has been set in the software, it will be\\nassumed that the software is out-of-date when the upgrade Time or Height is\\nreached and the software will exit."},"time":{"type":"string","format":"date-time","description":"Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\\nhas been removed from the SDK.\\nIf this field is not empty, an error will be thrown."},"height":{"type":"string","format":"int64","description":"The height at which the upgrade must be performed.\\nOnly used if Time is not set."},"info":{"type":"string","title":"Any application specific upgrade info to be included on-chain\\nsuch as a git commit that validators could automatically upgrade to"},"upgraded_client_state":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}}}},"description":"QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC\\nmethod."},"cosmos.upgrade.v1beta1.QueryModuleVersionsResponse":{"type":"object","properties":{"module_versions":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name of the app module"},"version":{"type":"string","format":"uint64","title":"consensus version of the app module"}},"description":"ModuleVersion specifies a module and its consensus version.\\n\\nSince: cosmos-sdk 0.43"},"description":"module_versions is a list of module names with their consensus versions."}},"description":"QueryModuleVersionsResponse is the response type for the Query/ModuleVersions\\nRPC method.\\n\\nSince: cosmos-sdk 0.43"},"cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateResponse":{"type":"object","properties":{"upgraded_consensus_state":{"type":"string","format":"byte","title":"Since: cosmos-sdk 0.43"}},"description":"QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState\\nRPC method."},"cosmos.authz.v1beta1.Grant":{"type":"object","properties":{"authorization":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"expiration":{"type":"string","format":"date-time","title":"time when the grant will expire and will be pruned. If null, then the grant\\ndoesn\'t have a time expiration (other conditions  in `authorization`\\nmay apply to invalidate the grant)"}},"description":"Grant gives permissions to execute\\nthe provide method with expiration time."},"cosmos.authz.v1beta1.GrantAuthorization":{"type":"object","properties":{"granter":{"type":"string"},"grantee":{"type":"string"},"authorization":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"expiration":{"type":"string","format":"date-time"}},"title":"GrantAuthorization extends a grant with both the addresses of the grantee and granter.\\nIt is used in genesis.proto and query.proto"},"cosmos.authz.v1beta1.QueryGranteeGrantsResponse":{"type":"object","properties":{"grants":{"type":"array","items":{"type":"object","properties":{"granter":{"type":"string"},"grantee":{"type":"string"},"authorization":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"expiration":{"type":"string","format":"date-time"}},"title":"GrantAuthorization extends a grant with both the addresses of the grantee and granter.\\nIt is used in genesis.proto and query.proto"},"description":"grants is a list of grants granted to the grantee."},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method."},"cosmos.authz.v1beta1.QueryGranterGrantsResponse":{"type":"object","properties":{"grants":{"type":"array","items":{"type":"object","properties":{"granter":{"type":"string"},"grantee":{"type":"string"},"authorization":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"expiration":{"type":"string","format":"date-time"}},"title":"GrantAuthorization extends a grant with both the addresses of the grantee and granter.\\nIt is used in genesis.proto and query.proto"},"description":"grants is a list of grants granted by the granter."},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method."},"cosmos.authz.v1beta1.QueryGrantsResponse":{"type":"object","properties":{"grants":{"type":"array","items":{"type":"object","properties":{"authorization":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"expiration":{"type":"string","format":"date-time","title":"time when the grant will expire and will be pruned. If null, then the grant\\ndoesn\'t have a time expiration (other conditions  in `authorization`\\nmay apply to invalidate the grant)"}},"description":"Grant gives permissions to execute\\nthe provide method with expiration time."},"description":"authorizations is a list of grants granted for grantee by granter."},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGrantsResponse is the response type for the Query/Authorizations RPC method."},"cosmos.feegrant.v1beta1.Grant":{"type":"object","properties":{"granter":{"type":"string","description":"granter is the address of the user granting an allowance of their funds."},"grantee":{"type":"string","description":"grantee is the address of the user being granted an allowance of another user\'s funds."},"allowance":{"description":"allowance can be any of basic, periodic, allowed fee allowance.","type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}}}},"title":"Grant is stored in the KVStore to record a grant with full context"},"cosmos.feegrant.v1beta1.QueryAllowanceResponse":{"type":"object","properties":{"allowance":{"description":"allowance is a allowance granted for grantee by granter.","type":"object","properties":{"granter":{"type":"string","description":"granter is the address of the user granting an allowance of their funds."},"grantee":{"type":"string","description":"grantee is the address of the user being granted an allowance of another user\'s funds."},"allowance":{"description":"allowance can be any of basic, periodic, allowed fee allowance.","type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}}}},"title":"Grant is stored in the KVStore to record a grant with full context"}},"description":"QueryAllowanceResponse is the response type for the Query/Allowance RPC method."},"cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse":{"type":"object","properties":{"allowances":{"type":"array","items":{"type":"object","properties":{"granter":{"type":"string","description":"granter is the address of the user granting an allowance of their funds."},"grantee":{"type":"string","description":"grantee is the address of the user being granted an allowance of another user\'s funds."},"allowance":{"description":"allowance can be any of basic, periodic, allowed fee allowance.","type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}}}},"title":"Grant is stored in the KVStore to record a grant with full context"},"description":"allowances that have been issued by the granter."},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method.\\n\\nSince: cosmos-sdk 0.46"},"cosmos.feegrant.v1beta1.QueryAllowancesResponse":{"type":"object","properties":{"allowances":{"type":"array","items":{"type":"object","properties":{"granter":{"type":"string","description":"granter is the address of the user granting an allowance of their funds."},"grantee":{"type":"string","description":"grantee is the address of the user being granted an allowance of another user\'s funds."},"allowance":{"description":"allowance can be any of basic, periodic, allowed fee allowance.","type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}}}},"title":"Grant is stored in the KVStore to record a grant with full context"},"description":"allowances are allowance\'s granted for grantee by granter."},"pagination":{"description":"pagination defines an pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAllowancesResponse is the response type for the Query/Allowances RPC method."},"cosmos.nft.v1beta1.Class":{"type":"object","properties":{"id":{"type":"string","title":"id defines the unique identifier of the NFT classification, similar to the contract address of ERC721"},"name":{"type":"string","title":"name defines the human-readable name of the NFT classification. Optional"},"symbol":{"type":"string","title":"symbol is an abbreviated name for nft classification. Optional"},"description":{"type":"string","title":"description is a brief description of nft classification. Optional"},"uri":{"type":"string","title":"uri for the class metadata stored off chain. It can define schema for Class and NFT `Data` attributes. Optional"},"uri_hash":{"type":"string","title":"uri_hash is a hash of the document pointed by uri. Optional"},"data":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }","title":"data is the app specific metadata of the NFT class. Optional"}},"description":"Class defines the class of the nft type."},"cosmos.nft.v1beta1.NFT":{"type":"object","properties":{"class_id":{"type":"string","title":"class_id associated with the NFT, similar to the contract address of ERC721"},"id":{"type":"string","title":"id is a unique identifier of the NFT"},"uri":{"type":"string","title":"uri for the NFT metadata stored off chain"},"uri_hash":{"type":"string","title":"uri_hash is a hash of the document pointed by uri"},"data":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }","title":"data is an app specific data of the NFT. Optional"}},"description":"NFT defines the NFT."},"cosmos.nft.v1beta1.QueryBalanceResponse":{"type":"object","properties":{"amount":{"type":"string","format":"uint64"}},"title":"QueryBalanceResponse is the response type for the Query/Balance RPC method"},"cosmos.nft.v1beta1.QueryClassResponse":{"type":"object","properties":{"class":{"type":"object","properties":{"id":{"type":"string","title":"id defines the unique identifier of the NFT classification, similar to the contract address of ERC721"},"name":{"type":"string","title":"name defines the human-readable name of the NFT classification. Optional"},"symbol":{"type":"string","title":"symbol is an abbreviated name for nft classification. Optional"},"description":{"type":"string","title":"description is a brief description of nft classification. Optional"},"uri":{"type":"string","title":"uri for the class metadata stored off chain. It can define schema for Class and NFT `Data` attributes. Optional"},"uri_hash":{"type":"string","title":"uri_hash is a hash of the document pointed by uri. Optional"},"data":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }","title":"data is the app specific metadata of the NFT class. Optional"}},"description":"Class defines the class of the nft type."}},"title":"QueryClassResponse is the response type for the Query/Class RPC method"},"cosmos.nft.v1beta1.QueryClassesResponse":{"type":"object","properties":{"classes":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","title":"id defines the unique identifier of the NFT classification, similar to the contract address of ERC721"},"name":{"type":"string","title":"name defines the human-readable name of the NFT classification. Optional"},"symbol":{"type":"string","title":"symbol is an abbreviated name for nft classification. Optional"},"description":{"type":"string","title":"description is a brief description of nft classification. Optional"},"uri":{"type":"string","title":"uri for the class metadata stored off chain. It can define schema for Class and NFT `Data` attributes. Optional"},"uri_hash":{"type":"string","title":"uri_hash is a hash of the document pointed by uri. Optional"},"data":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }","title":"data is the app specific metadata of the NFT class. Optional"}},"description":"Class defines the class of the nft type."}},"pagination":{"type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}},"description":"PageResponse is to be embedded in gRPC response messages where the\\ncorresponding request message has used PageRequest.\\n\\n message SomeResponse {\\n         repeated Bar results = 1;\\n         PageResponse page = 2;\\n }"}},"title":"QueryClassesResponse is the response type for the Query/Classes RPC method"},"cosmos.nft.v1beta1.QueryNFTResponse":{"type":"object","properties":{"nft":{"type":"object","properties":{"class_id":{"type":"string","title":"class_id associated with the NFT, similar to the contract address of ERC721"},"id":{"type":"string","title":"id is a unique identifier of the NFT"},"uri":{"type":"string","title":"uri for the NFT metadata stored off chain"},"uri_hash":{"type":"string","title":"uri_hash is a hash of the document pointed by uri"},"data":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }","title":"data is an app specific data of the NFT. Optional"}},"description":"NFT defines the NFT."}},"title":"QueryNFTResponse is the response type for the Query/NFT RPC method"},"cosmos.nft.v1beta1.QueryNFTsResponse":{"type":"object","properties":{"nfts":{"type":"array","items":{"type":"object","properties":{"class_id":{"type":"string","title":"class_id associated with the NFT, similar to the contract address of ERC721"},"id":{"type":"string","title":"id is a unique identifier of the NFT"},"uri":{"type":"string","title":"uri for the NFT metadata stored off chain"},"uri_hash":{"type":"string","title":"uri_hash is a hash of the document pointed by uri"},"data":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }","title":"data is an app specific data of the NFT. Optional"}},"description":"NFT defines the NFT."}},"pagination":{"type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}},"description":"PageResponse is to be embedded in gRPC response messages where the\\ncorresponding request message has used PageRequest.\\n\\n message SomeResponse {\\n         repeated Bar results = 1;\\n         PageResponse page = 2;\\n }"}},"title":"QueryNFTsResponse is the response type for the Query/NFTs RPC methods"},"cosmos.nft.v1beta1.QueryOwnerResponse":{"type":"object","properties":{"owner":{"type":"string"}},"title":"QueryOwnerResponse is the response type for the Query/Owner RPC method"},"cosmos.nft.v1beta1.QuerySupplyResponse":{"type":"object","properties":{"amount":{"type":"string","format":"uint64"}},"title":"QuerySupplyResponse is the response type for the Query/Supply RPC method"},"cosmos.group.v1.GroupInfo":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group\'s admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group."},"version":{"type":"string","format":"uint64","title":"version is used to track changes to a group\'s membership structure that\\nwould break existing proposals. Whenever any members weight is changed,\\nor any member is added or removed this version is incremented and will\\ncause proposals based on older versions of this group to fail"},"total_weight":{"type":"string","description":"total_weight is the sum of the group members\' weights."},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group was created."}},"description":"GroupInfo represents the high-level on-chain information for a group."},"cosmos.group.v1.GroupMember":{"type":"object","properties":{"group_id":{"type":"string","format":"uint64","description":"group_id is the unique ID of the group."},"member":{"description":"member is the member data.","type":"object","properties":{"address":{"type":"string","description":"address is the member\'s account address."},"weight":{"type":"string","description":"weight is the member\'s voting weight that should be greater than 0."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata attached to the member."},"added_at":{"type":"string","format":"date-time","description":"added_at is a timestamp specifying when a member was added."}}}},"description":"GroupMember represents the relationship between a group and a member."},"cosmos.group.v1.GroupPolicyInfo":{"type":"object","properties":{"address":{"type":"string","description":"address is the account address of group policy."},"group_id":{"type":"string","format":"uint64","description":"group_id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group policy."},"version":{"type":"string","format":"uint64","description":"version is used to track changes to a group\'s GroupPolicyInfo structure that\\nwould create a different result on a running proposal."},"decision_policy":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group policy was created."}},"description":"GroupPolicyInfo represents the high-level on-chain information for a group policy."},"cosmos.group.v1.Member":{"type":"object","properties":{"address":{"type":"string","description":"address is the member\'s account address."},"weight":{"type":"string","description":"weight is the member\'s voting weight that should be greater than 0."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata attached to the member."},"added_at":{"type":"string","format":"date-time","description":"added_at is a timestamp specifying when a member was added."}},"description":"Member represents a group member with an account address,\\nnon-zero weight, metadata and added_at timestamp."},"cosmos.group.v1.Proposal":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique id of the proposal."},"group_policy_address":{"type":"string","description":"group_policy_address is the account address of group policy."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the proposal."},"proposers":{"type":"array","items":{"type":"string"},"description":"proposers are the account addresses of the proposers."},"submit_time":{"type":"string","format":"date-time","description":"submit_time is a timestamp specifying when a proposal was submitted."},"group_version":{"type":"string","format":"uint64","description":"group_version tracks the version of the group at proposal submission.\\nThis field is here for informational purposes only."},"group_policy_version":{"type":"string","format":"uint64","description":"group_policy_version tracks the version of the group policy at proposal submission.\\nWhen a decision policy is changed, existing proposals from previous policy\\nversions will become invalid with the `ABORTED` status.\\nThis field is here for informational purposes only."},"status":{"description":"status represents the high level position in the life cycle of the proposal. Initial value is Submitted.","type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_SUBMITTED","PROPOSAL_STATUS_ACCEPTED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_ABORTED","PROPOSAL_STATUS_WITHDRAWN"],"default":"PROPOSAL_STATUS_UNSPECIFIED"},"final_tally_result":{"description":"final_tally_result contains the sums of all weighted votes for this\\nproposal for each vote option. It is empty at submission, and only\\npopulated after tallying, at voting period end or at proposal execution,\\nwhichever happens first.","type":"object","properties":{"yes_count":{"type":"string","description":"yes_count is the weighted sum of yes votes."},"abstain_count":{"type":"string","description":"abstain_count is the weighted sum of abstainers."},"no_count":{"type":"string","description":"no_count is the weighted sum of no votes."},"no_with_veto_count":{"type":"string","description":"no_with_veto_count is the weighted sum of veto."}}},"voting_period_end":{"type":"string","format":"date-time","description":"voting_period_end is the timestamp before which voting must be done.\\nUnless a successfull MsgExec is called before (to execute a proposal whose\\ntally is successful before the voting period ends), tallying will be done\\nat this point, and the `final_tally_result`and `status` fields will be\\naccordingly updated."},"executor_result":{"description":"executor_result is the final result of the proposal execution. Initial value is NotRun.","type":"string","enum":["PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED","PROPOSAL_EXECUTOR_RESULT_NOT_RUN","PROPOSAL_EXECUTOR_RESULT_SUCCESS","PROPOSAL_EXECUTOR_RESULT_FAILURE"],"default":"PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED"},"messages":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"messages is a list of `sdk.Msg`s that will be executed if the proposal passes."}},"description":"Proposal defines a group proposal. Any member of a group can submit a proposal\\nfor a group policy to decide upon.\\nA proposal consists of a set of `sdk.Msg`s that will be executed if the proposal\\npasses as well as some optional metadata associated with the proposal."},"cosmos.group.v1.ProposalExecutorResult":{"type":"string","enum":["PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED","PROPOSAL_EXECUTOR_RESULT_NOT_RUN","PROPOSAL_EXECUTOR_RESULT_SUCCESS","PROPOSAL_EXECUTOR_RESULT_FAILURE"],"default":"PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED","description":"ProposalExecutorResult defines types of proposal executor results.\\n\\n - PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED: An empty value is not allowed.\\n - PROPOSAL_EXECUTOR_RESULT_NOT_RUN: We have not yet run the executor.\\n - PROPOSAL_EXECUTOR_RESULT_SUCCESS: The executor was successful and proposed action updated state.\\n - PROPOSAL_EXECUTOR_RESULT_FAILURE: The executor returned an error and proposed action didn\'t update state."},"cosmos.group.v1.ProposalStatus":{"type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_SUBMITTED","PROPOSAL_STATUS_ACCEPTED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_ABORTED","PROPOSAL_STATUS_WITHDRAWN"],"default":"PROPOSAL_STATUS_UNSPECIFIED","description":"ProposalStatus defines proposal statuses.\\n\\n - PROPOSAL_STATUS_UNSPECIFIED: An empty value is invalid and not allowed.\\n - PROPOSAL_STATUS_SUBMITTED: Initial status of a proposal when submitted.\\n - PROPOSAL_STATUS_ACCEPTED: Final status of a proposal when the final tally is done and the outcome\\npasses the group policy\'s decision policy.\\n - PROPOSAL_STATUS_REJECTED: Final status of a proposal when the final tally is done and the outcome\\nis rejected by the group policy\'s decision policy.\\n - PROPOSAL_STATUS_ABORTED: Final status of a proposal when the group policy is modified before the\\nfinal tally.\\n - PROPOSAL_STATUS_WITHDRAWN: A proposal can be withdrawn before the voting start time by the owner.\\nWhen this happens the final status is Withdrawn."},"cosmos.group.v1.QueryGroupInfoResponse":{"type":"object","properties":{"info":{"description":"info is the GroupInfo for the group.","type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group\'s admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group."},"version":{"type":"string","format":"uint64","title":"version is used to track changes to a group\'s membership structure that\\nwould break existing proposals. Whenever any members weight is changed,\\nor any member is added or removed this version is incremented and will\\ncause proposals based on older versions of this group to fail"},"total_weight":{"type":"string","description":"total_weight is the sum of the group members\' weights."},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group was created."}}}},"description":"QueryGroupInfoResponse is the Query/GroupInfo response type."},"cosmos.group.v1.QueryGroupMembersResponse":{"type":"object","properties":{"members":{"type":"array","items":{"type":"object","properties":{"group_id":{"type":"string","format":"uint64","description":"group_id is the unique ID of the group."},"member":{"description":"member is the member data.","type":"object","properties":{"address":{"type":"string","description":"address is the member\'s account address."},"weight":{"type":"string","description":"weight is the member\'s voting weight that should be greater than 0."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata attached to the member."},"added_at":{"type":"string","format":"date-time","description":"added_at is a timestamp specifying when a member was added."}}}},"description":"GroupMember represents the relationship between a group and a member."},"description":"members are the members of the group with given group_id."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGroupMembersResponse is the Query/GroupMembersResponse response type."},"cosmos.group.v1.QueryGroupPoliciesByAdminResponse":{"type":"object","properties":{"group_policies":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address is the account address of group policy."},"group_id":{"type":"string","format":"uint64","description":"group_id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group policy."},"version":{"type":"string","format":"uint64","description":"version is used to track changes to a group\'s GroupPolicyInfo structure that\\nwould create a different result on a running proposal."},"decision_policy":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group policy was created."}},"description":"GroupPolicyInfo represents the high-level on-chain information for a group policy."},"description":"group_policies are the group policies info with provided admin."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGroupPoliciesByAdminResponse is the Query/GroupPoliciesByAdmin response type."},"cosmos.group.v1.QueryGroupPoliciesByGroupResponse":{"type":"object","properties":{"group_policies":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address is the account address of group policy."},"group_id":{"type":"string","format":"uint64","description":"group_id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group policy."},"version":{"type":"string","format":"uint64","description":"version is used to track changes to a group\'s GroupPolicyInfo structure that\\nwould create a different result on a running proposal."},"decision_policy":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group policy was created."}},"description":"GroupPolicyInfo represents the high-level on-chain information for a group policy."},"description":"group_policies are the group policies info associated with the provided group."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGroupPoliciesByGroupResponse is the Query/GroupPoliciesByGroup response type."},"cosmos.group.v1.QueryGroupPolicyInfoResponse":{"type":"object","properties":{"info":{"type":"object","properties":{"address":{"type":"string","description":"address is the account address of group policy."},"group_id":{"type":"string","format":"uint64","description":"group_id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group policy."},"version":{"type":"string","format":"uint64","description":"version is used to track changes to a group\'s GroupPolicyInfo structure that\\nwould create a different result on a running proposal."},"decision_policy":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group policy was created."}},"description":"GroupPolicyInfo represents the high-level on-chain information for a group policy."}},"description":"QueryGroupPolicyInfoResponse is the Query/GroupPolicyInfo response type."},"cosmos.group.v1.QueryGroupsByAdminResponse":{"type":"object","properties":{"groups":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group\'s admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group."},"version":{"type":"string","format":"uint64","title":"version is used to track changes to a group\'s membership structure that\\nwould break existing proposals. Whenever any members weight is changed,\\nor any member is added or removed this version is incremented and will\\ncause proposals based on older versions of this group to fail"},"total_weight":{"type":"string","description":"total_weight is the sum of the group members\' weights."},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group was created."}},"description":"GroupInfo represents the high-level on-chain information for a group."},"description":"groups are the groups info with the provided admin."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGroupsByAdminResponse is the Query/GroupsByAdminResponse response type."},"cosmos.group.v1.QueryGroupsByMemberResponse":{"type":"object","properties":{"groups":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group\'s admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group."},"version":{"type":"string","format":"uint64","title":"version is used to track changes to a group\'s membership structure that\\nwould break existing proposals. Whenever any members weight is changed,\\nor any member is added or removed this version is incremented and will\\ncause proposals based on older versions of this group to fail"},"total_weight":{"type":"string","description":"total_weight is the sum of the group members\' weights."},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group was created."}},"description":"GroupInfo represents the high-level on-chain information for a group."},"description":"groups are the groups info with the provided group member."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGroupsByMemberResponse is the Query/GroupsByMember response type."},"cosmos.group.v1.QueryGroupsResponse":{"type":"object","properties":{"groups":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique ID of the group."},"admin":{"type":"string","description":"admin is the account address of the group\'s admin."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the group."},"version":{"type":"string","format":"uint64","title":"version is used to track changes to a group\'s membership structure that\\nwould break existing proposals. Whenever any members weight is changed,\\nor any member is added or removed this version is incremented and will\\ncause proposals based on older versions of this group to fail"},"total_weight":{"type":"string","description":"total_weight is the sum of the group members\' weights."},"created_at":{"type":"string","format":"date-time","description":"created_at is a timestamp specifying when a group was created."}},"description":"GroupInfo represents the high-level on-chain information for a group."},"description":"`groups` is all the groups present in state."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGroupsResponse is the Query/Groups response type.\\n\\nSince: cosmos-sdk 0.47.1"},"cosmos.group.v1.QueryProposalResponse":{"type":"object","properties":{"proposal":{"description":"proposal is the proposal info.","type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique id of the proposal."},"group_policy_address":{"type":"string","description":"group_policy_address is the account address of group policy."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the proposal."},"proposers":{"type":"array","items":{"type":"string"},"description":"proposers are the account addresses of the proposers."},"submit_time":{"type":"string","format":"date-time","description":"submit_time is a timestamp specifying when a proposal was submitted."},"group_version":{"type":"string","format":"uint64","description":"group_version tracks the version of the group at proposal submission.\\nThis field is here for informational purposes only."},"group_policy_version":{"type":"string","format":"uint64","description":"group_policy_version tracks the version of the group policy at proposal submission.\\nWhen a decision policy is changed, existing proposals from previous policy\\nversions will become invalid with the `ABORTED` status.\\nThis field is here for informational purposes only."},"status":{"description":"status represents the high level position in the life cycle of the proposal. Initial value is Submitted.","type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_SUBMITTED","PROPOSAL_STATUS_ACCEPTED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_ABORTED","PROPOSAL_STATUS_WITHDRAWN"],"default":"PROPOSAL_STATUS_UNSPECIFIED"},"final_tally_result":{"description":"final_tally_result contains the sums of all weighted votes for this\\nproposal for each vote option. It is empty at submission, and only\\npopulated after tallying, at voting period end or at proposal execution,\\nwhichever happens first.","type":"object","properties":{"yes_count":{"type":"string","description":"yes_count is the weighted sum of yes votes."},"abstain_count":{"type":"string","description":"abstain_count is the weighted sum of abstainers."},"no_count":{"type":"string","description":"no_count is the weighted sum of no votes."},"no_with_veto_count":{"type":"string","description":"no_with_veto_count is the weighted sum of veto."}}},"voting_period_end":{"type":"string","format":"date-time","description":"voting_period_end is the timestamp before which voting must be done.\\nUnless a successfull MsgExec is called before (to execute a proposal whose\\ntally is successful before the voting period ends), tallying will be done\\nat this point, and the `final_tally_result`and `status` fields will be\\naccordingly updated."},"executor_result":{"description":"executor_result is the final result of the proposal execution. Initial value is NotRun.","type":"string","enum":["PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED","PROPOSAL_EXECUTOR_RESULT_NOT_RUN","PROPOSAL_EXECUTOR_RESULT_SUCCESS","PROPOSAL_EXECUTOR_RESULT_FAILURE"],"default":"PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED"},"messages":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"messages is a list of `sdk.Msg`s that will be executed if the proposal passes."}}}},"description":"QueryProposalResponse is the Query/Proposal response type."},"cosmos.group.v1.QueryProposalsByGroupPolicyResponse":{"type":"object","properties":{"proposals":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"id is the unique id of the proposal."},"group_policy_address":{"type":"string","description":"group_policy_address is the account address of group policy."},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the proposal."},"proposers":{"type":"array","items":{"type":"string"},"description":"proposers are the account addresses of the proposers."},"submit_time":{"type":"string","format":"date-time","description":"submit_time is a timestamp specifying when a proposal was submitted."},"group_version":{"type":"string","format":"uint64","description":"group_version tracks the version of the group at proposal submission.\\nThis field is here for informational purposes only."},"group_policy_version":{"type":"string","format":"uint64","description":"group_policy_version tracks the version of the group policy at proposal submission.\\nWhen a decision policy is changed, existing proposals from previous policy\\nversions will become invalid with the `ABORTED` status.\\nThis field is here for informational purposes only."},"status":{"description":"status represents the high level position in the life cycle of the proposal. Initial value is Submitted.","type":"string","enum":["PROPOSAL_STATUS_UNSPECIFIED","PROPOSAL_STATUS_SUBMITTED","PROPOSAL_STATUS_ACCEPTED","PROPOSAL_STATUS_REJECTED","PROPOSAL_STATUS_ABORTED","PROPOSAL_STATUS_WITHDRAWN"],"default":"PROPOSAL_STATUS_UNSPECIFIED"},"final_tally_result":{"description":"final_tally_result contains the sums of all weighted votes for this\\nproposal for each vote option. It is empty at submission, and only\\npopulated after tallying, at voting period end or at proposal execution,\\nwhichever happens first.","type":"object","properties":{"yes_count":{"type":"string","description":"yes_count is the weighted sum of yes votes."},"abstain_count":{"type":"string","description":"abstain_count is the weighted sum of abstainers."},"no_count":{"type":"string","description":"no_count is the weighted sum of no votes."},"no_with_veto_count":{"type":"string","description":"no_with_veto_count is the weighted sum of veto."}}},"voting_period_end":{"type":"string","format":"date-time","description":"voting_period_end is the timestamp before which voting must be done.\\nUnless a successfull MsgExec is called before (to execute a proposal whose\\ntally is successful before the voting period ends), tallying will be done\\nat this point, and the `final_tally_result`and `status` fields will be\\naccordingly updated."},"executor_result":{"description":"executor_result is the final result of the proposal execution. Initial value is NotRun.","type":"string","enum":["PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED","PROPOSAL_EXECUTOR_RESULT_NOT_RUN","PROPOSAL_EXECUTOR_RESULT_SUCCESS","PROPOSAL_EXECUTOR_RESULT_FAILURE"],"default":"PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED"},"messages":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"messages is a list of `sdk.Msg`s that will be executed if the proposal passes."}},"description":"Proposal defines a group proposal. Any member of a group can submit a proposal\\nfor a group policy to decide upon.\\nA proposal consists of a set of `sdk.Msg`s that will be executed if the proposal\\npasses as well as some optional metadata associated with the proposal."},"description":"proposals are the proposals with given group policy."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryProposalsByGroupPolicyResponse is the Query/ProposalByGroupPolicy response type."},"cosmos.group.v1.QueryTallyResultResponse":{"type":"object","properties":{"tally":{"description":"tally defines the requested tally.","type":"object","properties":{"yes_count":{"type":"string","description":"yes_count is the weighted sum of yes votes."},"abstain_count":{"type":"string","description":"abstain_count is the weighted sum of abstainers."},"no_count":{"type":"string","description":"no_count is the weighted sum of no votes."},"no_with_veto_count":{"type":"string","description":"no_with_veto_count is the weighted sum of veto."}}}},"description":"QueryTallyResultResponse is the Query/TallyResult response type."},"cosmos.group.v1.QueryVoteByProposalVoterResponse":{"type":"object","properties":{"vote":{"description":"vote is the vote with given proposal_id and voter.","type":"object","properties":{"proposal_id":{"type":"string","format":"uint64","description":"proposal is the unique ID of the proposal."},"voter":{"type":"string","description":"voter is the account address of the voter."},"option":{"description":"option is the voter\'s choice on the proposal.","type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED"},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the vote."},"submit_time":{"type":"string","format":"date-time","description":"submit_time is the timestamp when the vote was submitted."}}}},"description":"QueryVoteByProposalVoterResponse is the Query/VoteByProposalVoter response type."},"cosmos.group.v1.QueryVotesByProposalResponse":{"type":"object","properties":{"votes":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64","description":"proposal is the unique ID of the proposal."},"voter":{"type":"string","description":"voter is the account address of the voter."},"option":{"description":"option is the voter\'s choice on the proposal.","type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED"},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the vote."},"submit_time":{"type":"string","format":"date-time","description":"submit_time is the timestamp when the vote was submitted."}},"description":"Vote represents a vote for a proposal."},"description":"votes are the list of votes for given proposal_id."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryVotesByProposalResponse is the Query/VotesByProposal response type."},"cosmos.group.v1.QueryVotesByVoterResponse":{"type":"object","properties":{"votes":{"type":"array","items":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64","description":"proposal is the unique ID of the proposal."},"voter":{"type":"string","description":"voter is the account address of the voter."},"option":{"description":"option is the voter\'s choice on the proposal.","type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED"},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the vote."},"submit_time":{"type":"string","format":"date-time","description":"submit_time is the timestamp when the vote was submitted."}},"description":"Vote represents a vote for a proposal."},"description":"votes are the list of votes by given voter."},"pagination":{"description":"pagination defines the pagination in the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryVotesByVoterResponse is the Query/VotesByVoter response type."},"cosmos.group.v1.TallyResult":{"type":"object","properties":{"yes_count":{"type":"string","description":"yes_count is the weighted sum of yes votes."},"abstain_count":{"type":"string","description":"abstain_count is the weighted sum of abstainers."},"no_count":{"type":"string","description":"no_count is the weighted sum of no votes."},"no_with_veto_count":{"type":"string","description":"no_with_veto_count is the weighted sum of veto."}},"description":"TallyResult represents the sum of weighted votes for each vote option."},"cosmos.group.v1.Vote":{"type":"object","properties":{"proposal_id":{"type":"string","format":"uint64","description":"proposal is the unique ID of the proposal."},"voter":{"type":"string","description":"voter is the account address of the voter."},"option":{"description":"option is the voter\'s choice on the proposal.","type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED"},"metadata":{"type":"string","description":"metadata is any arbitrary metadata to attached to the vote."},"submit_time":{"type":"string","format":"date-time","description":"submit_time is the timestamp when the vote was submitted."}},"description":"Vote represents a vote for a proposal."},"cosmos.group.v1.VoteOption":{"type":"string","enum":["VOTE_OPTION_UNSPECIFIED","VOTE_OPTION_YES","VOTE_OPTION_ABSTAIN","VOTE_OPTION_NO","VOTE_OPTION_NO_WITH_VETO"],"default":"VOTE_OPTION_UNSPECIFIED","description":"VoteOption enumerates the valid vote options for a given proposal.\\n\\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines an unspecified vote option which will\\nreturn an error.\\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option."},"provenance.attribute.v1.Attribute":{"type":"object","properties":{"name":{"type":"string","description":"The attribute name."},"value":{"type":"string","format":"byte","description":"The attribute value."},"attribute_type":{"description":"The attribute value type.","type":"string","enum":["ATTRIBUTE_TYPE_UNSPECIFIED","ATTRIBUTE_TYPE_UUID","ATTRIBUTE_TYPE_JSON","ATTRIBUTE_TYPE_STRING","ATTRIBUTE_TYPE_URI","ATTRIBUTE_TYPE_INT","ATTRIBUTE_TYPE_FLOAT","ATTRIBUTE_TYPE_PROTO","ATTRIBUTE_TYPE_BYTES"],"default":"ATTRIBUTE_TYPE_UNSPECIFIED","title":"AttributeType defines the type of the data stored in the attribute value"},"address":{"type":"string","title":"The address the attribute is bound to"},"expiration_date":{"type":"string","format":"date-time","description":"Time that an attribute will expire."}},"title":"Attribute holds a typed key/value structure for data associated with an account"},"provenance.attribute.v1.AttributeType":{"type":"string","enum":["ATTRIBUTE_TYPE_UNSPECIFIED","ATTRIBUTE_TYPE_UUID","ATTRIBUTE_TYPE_JSON","ATTRIBUTE_TYPE_STRING","ATTRIBUTE_TYPE_URI","ATTRIBUTE_TYPE_INT","ATTRIBUTE_TYPE_FLOAT","ATTRIBUTE_TYPE_PROTO","ATTRIBUTE_TYPE_BYTES"],"default":"ATTRIBUTE_TYPE_UNSPECIFIED","description":"- ATTRIBUTE_TYPE_UNSPECIFIED: ATTRIBUTE_TYPE_UNSPECIFIED defines an unknown/invalid type\\n - ATTRIBUTE_TYPE_UUID: ATTRIBUTE_TYPE_UUID defines an attribute value that contains a string value representation of a V4 uuid\\n - ATTRIBUTE_TYPE_JSON: ATTRIBUTE_TYPE_JSON defines an attribute value that contains a byte string containing json data\\n - ATTRIBUTE_TYPE_STRING: ATTRIBUTE_TYPE_STRING defines an attribute value that contains a generic string value\\n - ATTRIBUTE_TYPE_URI: ATTRIBUTE_TYPE_URI defines an attribute value that contains a URI\\n - ATTRIBUTE_TYPE_INT: ATTRIBUTE_TYPE_INT defines an attribute value that contains an integer (cast as int64)\\n - ATTRIBUTE_TYPE_FLOAT: ATTRIBUTE_TYPE_FLOAT defines an attribute value that contains a float\\n - ATTRIBUTE_TYPE_PROTO: ATTRIBUTE_TYPE_PROTO defines an attribute value that contains a serialized proto value in bytes\\n - ATTRIBUTE_TYPE_BYTES: ATTRIBUTE_TYPE_BYTES defines an attribute value that contains an untyped array of bytes","title":"AttributeType defines the type of the data stored in the attribute value"},"provenance.attribute.v1.Params":{"type":"object","properties":{"max_value_length":{"type":"integer","format":"int64","title":"maximum length of data to allow in an attribute value"}},"description":"Params defines the set of params for the attribute module."},"provenance.attribute.v1.QueryAccountDataResponse":{"type":"object","properties":{"value":{"type":"string","description":"value is the accountdata attribute value for the requested account."}},"description":"QueryAccountDataResponse is the response type for the Query/AccountData method."},"provenance.attribute.v1.QueryAttributeAccountsResponse":{"type":"object","properties":{"accounts":{"type":"array","items":{"type":"string"},"title":"list of account addresses that have attributes of request name"},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAttributeAccountsResponse is the response type for the Query/AttributeAccounts method."},"provenance.attribute.v1.QueryAttributeResponse":{"type":"object","properties":{"account":{"type":"string","description":"a string containing the address of the account the attributes are assigned to."},"attributes":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"The attribute name."},"value":{"type":"string","format":"byte","description":"The attribute value."},"attribute_type":{"description":"The attribute value type.","type":"string","enum":["ATTRIBUTE_TYPE_UNSPECIFIED","ATTRIBUTE_TYPE_UUID","ATTRIBUTE_TYPE_JSON","ATTRIBUTE_TYPE_STRING","ATTRIBUTE_TYPE_URI","ATTRIBUTE_TYPE_INT","ATTRIBUTE_TYPE_FLOAT","ATTRIBUTE_TYPE_PROTO","ATTRIBUTE_TYPE_BYTES"],"default":"ATTRIBUTE_TYPE_UNSPECIFIED","title":"AttributeType defines the type of the data stored in the attribute value"},"address":{"type":"string","title":"The address the attribute is bound to"},"expiration_date":{"type":"string","format":"date-time","description":"Time that an attribute will expire."}},"title":"Attribute holds a typed key/value structure for data associated with an account"},"title":"a list of attribute values"},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAttributeResponse is the response type for the Query/Attribute method."},"provenance.attribute.v1.QueryAttributesResponse":{"type":"object","properties":{"account":{"type":"string","title":"a string containing the address of the account the attributes are assigned to="},"attributes":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"The attribute name."},"value":{"type":"string","format":"byte","description":"The attribute value."},"attribute_type":{"description":"The attribute value type.","type":"string","enum":["ATTRIBUTE_TYPE_UNSPECIFIED","ATTRIBUTE_TYPE_UUID","ATTRIBUTE_TYPE_JSON","ATTRIBUTE_TYPE_STRING","ATTRIBUTE_TYPE_URI","ATTRIBUTE_TYPE_INT","ATTRIBUTE_TYPE_FLOAT","ATTRIBUTE_TYPE_PROTO","ATTRIBUTE_TYPE_BYTES"],"default":"ATTRIBUTE_TYPE_UNSPECIFIED","title":"AttributeType defines the type of the data stored in the attribute value"},"address":{"type":"string","title":"The address the attribute is bound to"},"expiration_date":{"type":"string","format":"date-time","description":"Time that an attribute will expire."}},"title":"Attribute holds a typed key/value structure for data associated with an account"},"title":"a list of attribute values"},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAttributesResponse is the response type for the Query/Attributes method."},"provenance.attribute.v1.QueryParamsResponse":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"max_value_length":{"type":"integer","format":"int64","title":"maximum length of data to allow in an attribute value"}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."},"provenance.attribute.v1.QueryScanResponse":{"type":"object","properties":{"account":{"type":"string","title":"a string containing the address of the account the attributes are assigned to="},"attributes":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"The attribute name."},"value":{"type":"string","format":"byte","description":"The attribute value."},"attribute_type":{"description":"The attribute value type.","type":"string","enum":["ATTRIBUTE_TYPE_UNSPECIFIED","ATTRIBUTE_TYPE_UUID","ATTRIBUTE_TYPE_JSON","ATTRIBUTE_TYPE_STRING","ATTRIBUTE_TYPE_URI","ATTRIBUTE_TYPE_INT","ATTRIBUTE_TYPE_FLOAT","ATTRIBUTE_TYPE_PROTO","ATTRIBUTE_TYPE_BYTES"],"default":"ATTRIBUTE_TYPE_UNSPECIFIED","title":"AttributeType defines the type of the data stored in the attribute value"},"address":{"type":"string","title":"The address the attribute is bound to"},"expiration_date":{"type":"string","format":"date-time","description":"Time that an attribute will expire."}},"title":"Attribute holds a typed key/value structure for data associated with an account"},"title":"a list of attribute values"},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryScanResponse is the response type for the Query/Scan method."},"provenance.attribute.v1.MsgAddAttributeResponse":{"type":"object","description":"MsgAddAttributeResponse defines the Msg/AddAttribute response type."},"provenance.attribute.v1.MsgDeleteAttributeResponse":{"type":"object","description":"MsgDeleteAttributeResponse defines the Msg/DeleteAttribute response type."},"provenance.attribute.v1.MsgDeleteDistinctAttributeResponse":{"type":"object","description":"MsgDeleteDistinctAttributeResponse defines the Msg/DeleteDistinctAttribute response type."},"provenance.attribute.v1.MsgSetAccountDataResponse":{"type":"object","description":"MsgSetAccountDataResponse defines the Msg/SetAccountData response type."},"provenance.attribute.v1.MsgUpdateAttributeExpirationResponse":{"type":"object","description":"MsgUpdateAttributeExpirationResponse defines the Msg/Vote response type."},"provenance.attribute.v1.MsgUpdateAttributeResponse":{"type":"object","description":"MsgUpdateAttributeResponse defines the Msg/UpdateAttribute response type."},"provenance.exchange.v1.AccessGrant":{"type":"object","properties":{"address":{"type":"string","description":"address is the address that these permissions apply to."},"permissions":{"type":"array","items":{"type":"string","enum":["PERMISSION_UNSPECIFIED","PERMISSION_SETTLE","PERMISSION_SET_IDS","PERMISSION_CANCEL","PERMISSION_WITHDRAW","PERMISSION_UPDATE","PERMISSION_PERMISSIONS","PERMISSION_ATTRIBUTES"],"default":"PERMISSION_UNSPECIFIED","description":"Permission defines the different types of permission that can be given to an account for a market.\\n\\n - PERMISSION_UNSPECIFIED: PERMISSION_UNSPECIFIED is the zero-value Permission; it is an error to use it.\\n - PERMISSION_SETTLE: PERMISSION_SETTLE is the ability to use the Settle Tx endpoint on behalf of a market.\\n - PERMISSION_SET_IDS: PERMISSION_SET_IDS is the ability to use the SetOrderExternalID Tx endpoint on behalf of a market.\\n - PERMISSION_CANCEL: PERMISSION_CANCEL is the ability to use the Cancel Tx endpoint on behalf of a market.\\n - PERMISSION_WITHDRAW: PERMISSION_WITHDRAW is the ability to use the MarketWithdraw Tx endpoint.\\n - PERMISSION_UPDATE: PERMISSION_UPDATE is the ability to use the MarketUpdate* Tx endpoints.\\n - PERMISSION_PERMISSIONS: PERMISSION_PERMISSIONS is the ability to use the MarketManagePermissions Tx endpoint.\\n - PERMISSION_ATTRIBUTES: PERMISSION_ATTRIBUTES is the ability to use the MarketManageReqAttrs Tx endpoint."},"description":"allowed is the list of permissions available for the address."}},"description":"AddrPermissions associates an address with a list of permissions available for that address."},"provenance.exchange.v1.AccountAmount":{"type":"object","properties":{"account":{"type":"string","description":"account is the bech32 address string of the account associated with the amount."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds associated with the address."}},"description":"AccountAmount associates an account with a coins amount."},"provenance.exchange.v1.AskOrder":{"type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}},"description":"AskOrder represents someone\'s desire to sell something at a minimum price."},"provenance.exchange.v1.BidOrder":{"type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}},"description":"BidOrder represents someone\'s desire to buy something at a specific price."},"provenance.exchange.v1.Commitment":{"type":"object","properties":{"account":{"type":"string","description":"account is the bech32 address string with the committed funds."},"market_id":{"type":"integer","format":"int64","description":"market_id is the numeric identifier of the market the funds are committed to."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds that have been committed by the account to the market."}},"description":"Commitment contains information on committed funds."},"provenance.exchange.v1.DenomSplit":{"type":"object","properties":{"denom":{"type":"string","description":"denom is the coin denomination this split applies to."},"split":{"type":"integer","format":"int64","description":"split is the proportion of fees the exchange receives for this denom in basis points.\\nE.g. 100 = 1%. Min = 0, Max = 10000."}},"description":"DenomSplit associates a coin denomination with an amount the exchange receives for that denom."},"provenance.exchange.v1.FeeRatio":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"provenance.exchange.v1.Market":{"type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id is the numerical identifier for this market."},"market_details":{"description":"market_details is some information about this market.","type":"object","properties":{"name":{"type":"string","description":"name is a moniker that people can use to refer to this market."},"description":{"type":"string","description":"description extra information about this market. The field is meant to be human-readable."},"website_url":{"type":"string","description":"website_url is a url people can use to get to this market, or at least get more information about this market."},"icon_uri":{"type":"string","description":"icon_uri is a uri for an icon to associate with this market."}}},"fee_create_ask_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_create_ask_flat is the flat fee charged for creating an ask order.\\nEach coin entry is a separate option. When an ask is created, one of these must be paid.\\nIf empty, no fee is required to create an ask order."},"fee_create_bid_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_create_bid_flat is the flat fee charged for creating a bid order.\\nEach coin entry is a separate option. When a bid is created, one of these must be paid.\\nIf empty, no fee is required to create a bid order."},"fee_seller_settlement_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_seller_settlement_flat is the flat fee charged to the seller during settlement.\\nEach coin entry is a separate option.\\nWhen an ask is settled, the seller will pay the amount in the denom that matches the price they received."},"fee_seller_settlement_ratios":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"description":"fee_seller_settlement_ratios is the fee to charge a seller during settlement based on the price they are receiving.\\nThe price and fee denoms must be equal for each entry, and only one entry for any given denom is allowed."},"fee_buyer_settlement_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_buyer_settlement_flat is the flat fee charged to the buyer during settlement.\\nEach coin entry is a separate option.\\nWhen a bid is created, the settlement fees provided must contain one of these."},"fee_buyer_settlement_ratios":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"description":"fee_buyer_settlement_ratios is the fee to charge a buyer during settlement based on the price they are spending.\\nThe price and fee denoms do not have to equal. Multiple entries for any given price or fee denom are allowed, but\\neach price denom to fee denom pair can only have one entry."},"accepting_orders":{"type":"boolean","format":"boolean","description":"accepting_orders is whether this market is allowing orders to be created for it."},"allow_user_settlement":{"type":"boolean","format":"boolean","description":"allow_user_settlement is whether this market allows users to initiate their own settlements.\\nFor example, the FillBids and FillAsks endpoints are available if and only if this is true.\\nThe MarketSettle endpoint is only available to market actors regardless of the value of this field."},"access_grants":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address is the address that these permissions apply to."},"permissions":{"type":"array","items":{"type":"string","enum":["PERMISSION_UNSPECIFIED","PERMISSION_SETTLE","PERMISSION_SET_IDS","PERMISSION_CANCEL","PERMISSION_WITHDRAW","PERMISSION_UPDATE","PERMISSION_PERMISSIONS","PERMISSION_ATTRIBUTES"],"default":"PERMISSION_UNSPECIFIED","description":"Permission defines the different types of permission that can be given to an account for a market.\\n\\n - PERMISSION_UNSPECIFIED: PERMISSION_UNSPECIFIED is the zero-value Permission; it is an error to use it.\\n - PERMISSION_SETTLE: PERMISSION_SETTLE is the ability to use the Settle Tx endpoint on behalf of a market.\\n - PERMISSION_SET_IDS: PERMISSION_SET_IDS is the ability to use the SetOrderExternalID Tx endpoint on behalf of a market.\\n - PERMISSION_CANCEL: PERMISSION_CANCEL is the ability to use the Cancel Tx endpoint on behalf of a market.\\n - PERMISSION_WITHDRAW: PERMISSION_WITHDRAW is the ability to use the MarketWithdraw Tx endpoint.\\n - PERMISSION_UPDATE: PERMISSION_UPDATE is the ability to use the MarketUpdate* Tx endpoints.\\n - PERMISSION_PERMISSIONS: PERMISSION_PERMISSIONS is the ability to use the MarketManagePermissions Tx endpoint.\\n - PERMISSION_ATTRIBUTES: PERMISSION_ATTRIBUTES is the ability to use the MarketManageReqAttrs Tx endpoint."},"description":"allowed is the list of permissions available for the address."}},"description":"AddrPermissions associates an address with a list of permissions available for that address."},"description":"access_grants is the list of addresses and permissions granted for this market."},"req_attr_create_ask":{"type":"array","items":{"type":"string"},"description":"req_attr_create_ask is a list of attributes required on an account for it to be allowed to create an ask order.\\nAn account must have all of these attributes in order to create an ask order in this market.\\nIf the list is empty, any account can create ask orders in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"b.x.a\\", or \\"c.b.a.x\\"."},"req_attr_create_bid":{"type":"array","items":{"type":"string"},"description":"req_attr_create_ask is a list of attributes required on an account for it to be allowed to create a bid order.\\nAn account must have all of these attributes in order to create a bid order in this market.\\nIf the list is empty, any account can create bid orders in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"c.b.x.a\\", or \\"c.b.a.x\\"."},"accepting_commitments":{"type":"boolean","format":"boolean","description":"accepting_commitments is whether the market is allowing users to commit funds to it."},"fee_create_commitment_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_create_commitment_flat is the flat fee charged for creating a commitment.\\nEach coin entry is a separate option. When a commitment is created, one of these must be paid.\\nIf empty, no fee is required to create a commitment."},"commitment_settlement_bips":{"type":"integer","format":"int64","description":"commitment_settlement_bips is the fraction of a commitment settlement that will be paid to the exchange.\\nIt is represented in basis points (1/100th of 1%, e.g. 0.0001) and is limited to 0 to 10,000 inclusive.\\nDuring a commitment settlement, the inputs are summed and NAVs are used to convert that total to the\\nintermediary denom, then to the fee denom. That is then multiplied by this value to get the fee amount\\nthat will be transferred out of the market\'s account into the exchange for that settlement.\\n\\nSumming the inputs effectively doubles the value of the settlement from what what is usually thought of\\nas the value of a trade. That should be taken into account when setting this value.\\nE.g. if two accounts are trading 10apples for 100grapes, the inputs total will be 10apples,100grapes\\n(which might then be converted to USD then nhash before applying this ratio); Usually, though, the value\\nof that trade would be viewed as either just 10apples or just 100grapes."},"intermediary_denom":{"type":"string","description":"intermediary_denom is the denom that funds get converted to (before being converted to the chain\'s fee denom)\\nwhen calculating the fees that are paid to the exchange. NAVs are used for this conversion and actions will fail\\nif a NAV is needed but not available."},"req_attr_create_commitment":{"type":"array","items":{"type":"string"},"description":"req_attr_create_commitment is a list of attributes required on an account for it to be allowed to create a\\ncommitment. An account must have all of these attributes in order to create a commitment in this market.\\nIf the list is empty, any account can create commitments in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"c.b.x.a\\", or \\"c.b.a.x\\"."}},"description":"Market contains all information about a market."},"provenance.exchange.v1.MarketAmount":{"type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id is the numeric identifier the amount has been committed to."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds associated with the address."}},"description":"MarketAmount associates a market with a coins amount."},"provenance.exchange.v1.MarketBrief":{"type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id is the numerical identifier for this market."},"market_address":{"type":"string","description":"market_address is the bech32 address string of this market\'s account."},"market_details":{"description":"market_details is some information about this market.","type":"object","properties":{"name":{"type":"string","description":"name is a moniker that people can use to refer to this market."},"description":{"type":"string","description":"description extra information about this market. The field is meant to be human-readable."},"website_url":{"type":"string","description":"website_url is a url people can use to get to this market, or at least get more information about this market."},"icon_uri":{"type":"string","description":"icon_uri is a uri for an icon to associate with this market."}}}},"description":"MarketBrief is a message containing brief, superficial information about a market."},"provenance.exchange.v1.MarketDetails":{"type":"object","properties":{"name":{"type":"string","description":"name is a moniker that people can use to refer to this market."},"description":{"type":"string","description":"description extra information about this market. The field is meant to be human-readable."},"website_url":{"type":"string","description":"website_url is a url people can use to get to this market, or at least get more information about this market."},"icon_uri":{"type":"string","description":"icon_uri is a uri for an icon to associate with this market."}},"description":"MarketDetails contains information about a market."},"provenance.exchange.v1.MsgGovCreateMarketRequest":{"type":"object","properties":{"authority":{"type":"string","description":"authority should be the governance module account address."},"market":{"description":"market is the initial market configuration.\\nIf the market_id is 0, the next available market_id will be used (once voting ends).\\nIf it is not zero, it must not yet be in use when the voting period ends.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id is the numerical identifier for this market."},"market_details":{"description":"market_details is some information about this market.","type":"object","properties":{"name":{"type":"string","description":"name is a moniker that people can use to refer to this market."},"description":{"type":"string","description":"description extra information about this market. The field is meant to be human-readable."},"website_url":{"type":"string","description":"website_url is a url people can use to get to this market, or at least get more information about this market."},"icon_uri":{"type":"string","description":"icon_uri is a uri for an icon to associate with this market."}}},"fee_create_ask_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_create_ask_flat is the flat fee charged for creating an ask order.\\nEach coin entry is a separate option. When an ask is created, one of these must be paid.\\nIf empty, no fee is required to create an ask order."},"fee_create_bid_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_create_bid_flat is the flat fee charged for creating a bid order.\\nEach coin entry is a separate option. When a bid is created, one of these must be paid.\\nIf empty, no fee is required to create a bid order."},"fee_seller_settlement_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_seller_settlement_flat is the flat fee charged to the seller during settlement.\\nEach coin entry is a separate option.\\nWhen an ask is settled, the seller will pay the amount in the denom that matches the price they received."},"fee_seller_settlement_ratios":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"description":"fee_seller_settlement_ratios is the fee to charge a seller during settlement based on the price they are receiving.\\nThe price and fee denoms must be equal for each entry, and only one entry for any given denom is allowed."},"fee_buyer_settlement_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_buyer_settlement_flat is the flat fee charged to the buyer during settlement.\\nEach coin entry is a separate option.\\nWhen a bid is created, the settlement fees provided must contain one of these."},"fee_buyer_settlement_ratios":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"description":"fee_buyer_settlement_ratios is the fee to charge a buyer during settlement based on the price they are spending.\\nThe price and fee denoms do not have to equal. Multiple entries for any given price or fee denom are allowed, but\\neach price denom to fee denom pair can only have one entry."},"accepting_orders":{"type":"boolean","format":"boolean","description":"accepting_orders is whether this market is allowing orders to be created for it."},"allow_user_settlement":{"type":"boolean","format":"boolean","description":"allow_user_settlement is whether this market allows users to initiate their own settlements.\\nFor example, the FillBids and FillAsks endpoints are available if and only if this is true.\\nThe MarketSettle endpoint is only available to market actors regardless of the value of this field."},"access_grants":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address is the address that these permissions apply to."},"permissions":{"type":"array","items":{"type":"string","enum":["PERMISSION_UNSPECIFIED","PERMISSION_SETTLE","PERMISSION_SET_IDS","PERMISSION_CANCEL","PERMISSION_WITHDRAW","PERMISSION_UPDATE","PERMISSION_PERMISSIONS","PERMISSION_ATTRIBUTES"],"default":"PERMISSION_UNSPECIFIED","description":"Permission defines the different types of permission that can be given to an account for a market.\\n\\n - PERMISSION_UNSPECIFIED: PERMISSION_UNSPECIFIED is the zero-value Permission; it is an error to use it.\\n - PERMISSION_SETTLE: PERMISSION_SETTLE is the ability to use the Settle Tx endpoint on behalf of a market.\\n - PERMISSION_SET_IDS: PERMISSION_SET_IDS is the ability to use the SetOrderExternalID Tx endpoint on behalf of a market.\\n - PERMISSION_CANCEL: PERMISSION_CANCEL is the ability to use the Cancel Tx endpoint on behalf of a market.\\n - PERMISSION_WITHDRAW: PERMISSION_WITHDRAW is the ability to use the MarketWithdraw Tx endpoint.\\n - PERMISSION_UPDATE: PERMISSION_UPDATE is the ability to use the MarketUpdate* Tx endpoints.\\n - PERMISSION_PERMISSIONS: PERMISSION_PERMISSIONS is the ability to use the MarketManagePermissions Tx endpoint.\\n - PERMISSION_ATTRIBUTES: PERMISSION_ATTRIBUTES is the ability to use the MarketManageReqAttrs Tx endpoint."},"description":"allowed is the list of permissions available for the address."}},"description":"AddrPermissions associates an address with a list of permissions available for that address."},"description":"access_grants is the list of addresses and permissions granted for this market."},"req_attr_create_ask":{"type":"array","items":{"type":"string"},"description":"req_attr_create_ask is a list of attributes required on an account for it to be allowed to create an ask order.\\nAn account must have all of these attributes in order to create an ask order in this market.\\nIf the list is empty, any account can create ask orders in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"b.x.a\\", or \\"c.b.a.x\\"."},"req_attr_create_bid":{"type":"array","items":{"type":"string"},"description":"req_attr_create_ask is a list of attributes required on an account for it to be allowed to create a bid order.\\nAn account must have all of these attributes in order to create a bid order in this market.\\nIf the list is empty, any account can create bid orders in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"c.b.x.a\\", or \\"c.b.a.x\\"."},"accepting_commitments":{"type":"boolean","format":"boolean","description":"accepting_commitments is whether the market is allowing users to commit funds to it."},"fee_create_commitment_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_create_commitment_flat is the flat fee charged for creating a commitment.\\nEach coin entry is a separate option. When a commitment is created, one of these must be paid.\\nIf empty, no fee is required to create a commitment."},"commitment_settlement_bips":{"type":"integer","format":"int64","description":"commitment_settlement_bips is the fraction of a commitment settlement that will be paid to the exchange.\\nIt is represented in basis points (1/100th of 1%, e.g. 0.0001) and is limited to 0 to 10,000 inclusive.\\nDuring a commitment settlement, the inputs are summed and NAVs are used to convert that total to the\\nintermediary denom, then to the fee denom. That is then multiplied by this value to get the fee amount\\nthat will be transferred out of the market\'s account into the exchange for that settlement.\\n\\nSumming the inputs effectively doubles the value of the settlement from what what is usually thought of\\nas the value of a trade. That should be taken into account when setting this value.\\nE.g. if two accounts are trading 10apples for 100grapes, the inputs total will be 10apples,100grapes\\n(which might then be converted to USD then nhash before applying this ratio); Usually, though, the value\\nof that trade would be viewed as either just 10apples or just 100grapes."},"intermediary_denom":{"type":"string","description":"intermediary_denom is the denom that funds get converted to (before being converted to the chain\'s fee denom)\\nwhen calculating the fees that are paid to the exchange. NAVs are used for this conversion and actions will fail\\nif a NAV is needed but not available."},"req_attr_create_commitment":{"type":"array","items":{"type":"string"},"description":"req_attr_create_commitment is a list of attributes required on an account for it to be allowed to create a\\ncommitment. An account must have all of these attributes in order to create a commitment in this market.\\nIf the list is empty, any account can create commitments in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"c.b.x.a\\", or \\"c.b.a.x\\"."}}}},"description":"MsgGovCreateMarketRequest is a request message for the GovCreateMarket endpoint."},"provenance.exchange.v1.MsgGovManageFeesRequest":{"type":"object","properties":{"authority":{"type":"string","description":"authority should be the governance module account address."},"market_id":{"type":"integer","format":"int64","description":"market_id is the market id that will get these fee updates."},"add_fee_create_ask_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"add_fee_create_ask_flat are the create-ask flat fee options to add."},"remove_fee_create_ask_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"remove_fee_create_ask_flat are the create-ask flat fee options to remove."},"add_fee_create_bid_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"add_fee_create_bid_flat are the create-bid flat fee options to add."},"remove_fee_create_bid_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"remove_fee_create_bid_flat are the create-bid flat fee options to remove."},"add_fee_seller_settlement_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"add_fee_seller_settlement_flat are the seller settlement flat fee options to add."},"remove_fee_seller_settlement_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"remove_fee_seller_settlement_flat are the seller settlement flat fee options to remove."},"add_fee_seller_settlement_ratios":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"description":"add_fee_seller_settlement_ratios are the seller settlement fee ratios to add."},"remove_fee_seller_settlement_ratios":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"description":"remove_fee_seller_settlement_ratios are the seller settlement fee ratios to remove."},"add_fee_buyer_settlement_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"add_fee_buyer_settlement_flat are the buyer settlement flat fee options to add."},"remove_fee_buyer_settlement_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"remove_fee_buyer_settlement_flat are the buyer settlement flat fee options to remove."},"add_fee_buyer_settlement_ratios":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"description":"add_fee_buyer_settlement_ratios are the buyer settlement fee ratios to add."},"remove_fee_buyer_settlement_ratios":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"description":"remove_fee_buyer_settlement_ratios are the buyer settlement fee ratios to remove."},"add_fee_create_commitment_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"add_fee_create_commitment_flat are the create-commitment flat fee options to add."},"remove_fee_create_commitment_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"remove_fee_create_commitment_flat are the create-commitment flat fee options to remove."},"set_fee_commitment_settlement_bips":{"type":"integer","format":"int64","description":"set_fee_commitment_settlement_bips is the new fee_commitment_settlement_bips for the market.\\nIt is ignored if it is zero. To set it to zero set unset_fee_commitment_settlement_bips to true."},"unset_fee_commitment_settlement_bips":{"type":"boolean","format":"boolean","description":"unset_fee_commitment_settlement_bips, if true, sets the fee_commitment_settlement_bips to zero.\\nIf false, it is ignored."}},"description":"MsgGovManageFeesRequest is a request message for the GovManageFees endpoint."},"provenance.exchange.v1.MsgMarketCommitmentSettleRequest":{"type":"object","properties":{"admin":{"type":"string","description":"admin is the account with \\"settle\\" permission requesting this settlement."},"market_id":{"type":"integer","format":"int64","description":"market_id is the numerical identifier of the market requesting this settlement."},"inputs":{"type":"array","items":{"type":"object","properties":{"account":{"type":"string","description":"account is the bech32 address string of the account associated with the amount."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds associated with the address."}},"description":"AccountAmount associates an account with a coins amount."},"description":"inputs defines where the funds are coming from. All of these funds must be already committed to the market."},"outputs":{"type":"array","items":{"type":"object","properties":{"account":{"type":"string","description":"account is the bech32 address string of the account associated with the amount."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds associated with the address."}},"description":"AccountAmount associates an account with a coins amount."},"description":"outputs defines how the funds are to be distributed. These funds will be re-committed in the destination accounts."},"fees":{"type":"array","items":{"type":"object","properties":{"account":{"type":"string","description":"account is the bech32 address string of the account associated with the amount."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds associated with the address."}},"description":"AccountAmount associates an account with a coins amount."},"description":"fees is the funds that the market is collecting as part of this settlement.\\nAll of these funds must be already committed to the market."},"navs":{"type":"array","items":{"type":"object","properties":{"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"NetAssetPrice is an association of assets and price used to record the value of things.\\nIt is related to the NetAssetValue message from the x/marker module, and is therefore often referred to as \\"a NAV\\"."},"description":"navs are any NAV info that should be updated at the beginning of this settlement."},"event_tag":{"type":"string","description":"event_tag is a string that is included in the funds-committed/released events. Max length is 100 characters."}},"description":"MsgMarketCommitmentSettleRequest is a request message for the MarketCommitmentSettle endpoint."},"provenance.exchange.v1.NetAssetPrice":{"type":"object","properties":{"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"NetAssetPrice is an association of assets and price used to record the value of things.\\nIt is related to the NetAssetValue message from the x/marker module, and is therefore often referred to as \\"a NAV\\"."},"provenance.exchange.v1.Order":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}},"description":"Order associates an order id with one of the order types."},"provenance.exchange.v1.Params":{"type":"object","properties":{"default_split":{"type":"integer","format":"int64","description":"default_split is the default proportion of fees the exchange receives in basis points.\\nIt is used if there isn\'t an applicable denom-specific split defined.\\nE.g. 100 = 1%. Min = 0, Max = 10000."},"denom_splits":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string","description":"denom is the coin denomination this split applies to."},"split":{"type":"integer","format":"int64","description":"split is the proportion of fees the exchange receives for this denom in basis points.\\nE.g. 100 = 1%. Min = 0, Max = 10000."}},"description":"DenomSplit associates a coin denomination with an amount the exchange receives for that denom."},"description":"denom_splits are the denom-specific amounts the exchange receives."}},"description":"Params is a representation of the exchange module parameters."},"provenance.exchange.v1.Permission":{"type":"string","enum":["PERMISSION_UNSPECIFIED","PERMISSION_SETTLE","PERMISSION_SET_IDS","PERMISSION_CANCEL","PERMISSION_WITHDRAW","PERMISSION_UPDATE","PERMISSION_PERMISSIONS","PERMISSION_ATTRIBUTES"],"default":"PERMISSION_UNSPECIFIED","description":"Permission defines the different types of permission that can be given to an account for a market.\\n\\n - PERMISSION_UNSPECIFIED: PERMISSION_UNSPECIFIED is the zero-value Permission; it is an error to use it.\\n - PERMISSION_SETTLE: PERMISSION_SETTLE is the ability to use the Settle Tx endpoint on behalf of a market.\\n - PERMISSION_SET_IDS: PERMISSION_SET_IDS is the ability to use the SetOrderExternalID Tx endpoint on behalf of a market.\\n - PERMISSION_CANCEL: PERMISSION_CANCEL is the ability to use the Cancel Tx endpoint on behalf of a market.\\n - PERMISSION_WITHDRAW: PERMISSION_WITHDRAW is the ability to use the MarketWithdraw Tx endpoint.\\n - PERMISSION_UPDATE: PERMISSION_UPDATE is the ability to use the MarketUpdate* Tx endpoints.\\n - PERMISSION_PERMISSIONS: PERMISSION_PERMISSIONS is the ability to use the MarketManagePermissions Tx endpoint.\\n - PERMISSION_ATTRIBUTES: PERMISSION_ATTRIBUTES is the ability to use the MarketManageReqAttrs Tx endpoint."},"provenance.exchange.v1.QueryCommitmentSettlementFeeCalcResponse":{"type":"object","properties":{"exchange_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"exchange_fees is the total that the exchange would currently pay for the provided settlement."},"input_total":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"input_total is the sum of all the inputs in the provided settlement."},"converted_total":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"converted_total is the input_total converted to a single intermediary denom or left as the fee denom."},"conversion_navs":{"type":"array","items":{"type":"object","properties":{"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"NetAssetPrice is an association of assets and price used to record the value of things.\\nIt is related to the NetAssetValue message from the x/marker module, and is therefore often referred to as \\"a NAV\\"."},"description":"conversion_navs are the NAVs used to convert the input_total to the converted_total."},"to_fee_nav":{"type":"object","properties":{"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"NetAssetPrice is an association of assets and price used to record the value of things.\\nIt is related to the NetAssetValue message from the x/marker module, and is therefore often referred to as \\"a NAV\\"."}},"description":"QueryCommitmentSettlementFeeCalcResponse is a response message for the CommitmentSettlementFeeCalc query."},"provenance.exchange.v1.QueryGetAccountCommitmentsResponse":{"type":"object","properties":{"commitments":{"type":"array","items":{"type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id is the numeric identifier the amount has been committed to."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds associated with the address."}},"description":"MarketAmount associates a market with a coins amount."},"description":"commitments is the amounts committed from the account to the any market."}},"description":"QueryGetAccountCommitmentsResponse is a response message for the GetAccountCommitments query."},"provenance.exchange.v1.QueryGetAllCommitmentsResponse":{"type":"object","properties":{"commitments":{"type":"array","items":{"type":"object","properties":{"account":{"type":"string","description":"account is the bech32 address string with the committed funds."},"market_id":{"type":"integer","format":"int64","description":"market_id is the numeric identifier of the market the funds are committed to."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds that have been committed by the account to the market."}},"description":"Commitment contains information on committed funds."},"description":"commitments is the requested commitment information."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetAllCommitmentsResponse is a response message for the GetAllCommitments query."},"provenance.exchange.v1.QueryGetAllMarketsResponse":{"type":"object","properties":{"markets":{"type":"array","items":{"type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id is the numerical identifier for this market."},"market_address":{"type":"string","description":"market_address is the bech32 address string of this market\'s account."},"market_details":{"description":"market_details is some information about this market.","type":"object","properties":{"name":{"type":"string","description":"name is a moniker that people can use to refer to this market."},"description":{"type":"string","description":"description extra information about this market. The field is meant to be human-readable."},"website_url":{"type":"string","description":"website_url is a url people can use to get to this market, or at least get more information about this market."},"icon_uri":{"type":"string","description":"icon_uri is a uri for an icon to associate with this market."}}}},"description":"MarketBrief is a message containing brief, superficial information about a market."},"description":"markets are a page of the briefs for all markets."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetAllMarketsResponse is a response message for the GetAllMarkets query."},"provenance.exchange.v1.QueryGetAllOrdersResponse":{"type":"object","properties":{"orders":{"type":"array","items":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}},"description":"Order associates an order id with one of the order types."},"description":"orders are a page of the all orders."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetAllOrdersResponse is a response message for the GetAllOrders query."},"provenance.exchange.v1.QueryGetAssetOrdersResponse":{"type":"object","properties":{"orders":{"type":"array","items":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}},"description":"Order associates an order id with one of the order types."},"description":"orders are a page of the orders for the provided asset."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetAssetOrdersResponse is a response message for the GetAssetOrders query."},"provenance.exchange.v1.QueryGetCommitmentResponse":{"type":"object","properties":{"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the total funds committed to the market by the account."}},"description":"QueryGetCommitmentResponse is a response message for the GetCommitment query."},"provenance.exchange.v1.QueryGetMarketCommitmentsResponse":{"type":"object","properties":{"commitments":{"type":"array","items":{"type":"object","properties":{"account":{"type":"string","description":"account is the bech32 address string of the account associated with the amount."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the funds associated with the address."}},"description":"AccountAmount associates an account with a coins amount."},"description":"commitments is the amounts committed to the market from any account."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetMarketCommitmentsResponse is a response message for the GetMarketCommitments query."},"provenance.exchange.v1.QueryGetMarketOrdersResponse":{"type":"object","properties":{"orders":{"type":"array","items":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}},"description":"Order associates an order id with one of the order types."},"description":"orders are a page of the orders in the provided market."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetMarketOrdersResponse is a response message for the GetMarketOrders query."},"provenance.exchange.v1.QueryGetMarketResponse":{"type":"object","properties":{"address":{"type":"string","description":"address is the bech32 address string of this market\'s account."},"market":{"description":"market is all information and details of the market.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id is the numerical identifier for this market."},"market_details":{"description":"market_details is some information about this market.","type":"object","properties":{"name":{"type":"string","description":"name is a moniker that people can use to refer to this market."},"description":{"type":"string","description":"description extra information about this market. The field is meant to be human-readable."},"website_url":{"type":"string","description":"website_url is a url people can use to get to this market, or at least get more information about this market."},"icon_uri":{"type":"string","description":"icon_uri is a uri for an icon to associate with this market."}}},"fee_create_ask_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_create_ask_flat is the flat fee charged for creating an ask order.\\nEach coin entry is a separate option. When an ask is created, one of these must be paid.\\nIf empty, no fee is required to create an ask order."},"fee_create_bid_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_create_bid_flat is the flat fee charged for creating a bid order.\\nEach coin entry is a separate option. When a bid is created, one of these must be paid.\\nIf empty, no fee is required to create a bid order."},"fee_seller_settlement_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_seller_settlement_flat is the flat fee charged to the seller during settlement.\\nEach coin entry is a separate option.\\nWhen an ask is settled, the seller will pay the amount in the denom that matches the price they received."},"fee_seller_settlement_ratios":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"description":"fee_seller_settlement_ratios is the fee to charge a seller during settlement based on the price they are receiving.\\nThe price and fee denoms must be equal for each entry, and only one entry for any given denom is allowed."},"fee_buyer_settlement_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_buyer_settlement_flat is the flat fee charged to the buyer during settlement.\\nEach coin entry is a separate option.\\nWhen a bid is created, the settlement fees provided must contain one of these."},"fee_buyer_settlement_ratios":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"FeeRatio defines a ratio of price amount to fee amount.\\nFor an order to be valid, its price must be evenly divisible by a FeeRatio\'s price."},"description":"fee_buyer_settlement_ratios is the fee to charge a buyer during settlement based on the price they are spending.\\nThe price and fee denoms do not have to equal. Multiple entries for any given price or fee denom are allowed, but\\neach price denom to fee denom pair can only have one entry."},"accepting_orders":{"type":"boolean","format":"boolean","description":"accepting_orders is whether this market is allowing orders to be created for it."},"allow_user_settlement":{"type":"boolean","format":"boolean","description":"allow_user_settlement is whether this market allows users to initiate their own settlements.\\nFor example, the FillBids and FillAsks endpoints are available if and only if this is true.\\nThe MarketSettle endpoint is only available to market actors regardless of the value of this field."},"access_grants":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address is the address that these permissions apply to."},"permissions":{"type":"array","items":{"type":"string","enum":["PERMISSION_UNSPECIFIED","PERMISSION_SETTLE","PERMISSION_SET_IDS","PERMISSION_CANCEL","PERMISSION_WITHDRAW","PERMISSION_UPDATE","PERMISSION_PERMISSIONS","PERMISSION_ATTRIBUTES"],"default":"PERMISSION_UNSPECIFIED","description":"Permission defines the different types of permission that can be given to an account for a market.\\n\\n - PERMISSION_UNSPECIFIED: PERMISSION_UNSPECIFIED is the zero-value Permission; it is an error to use it.\\n - PERMISSION_SETTLE: PERMISSION_SETTLE is the ability to use the Settle Tx endpoint on behalf of a market.\\n - PERMISSION_SET_IDS: PERMISSION_SET_IDS is the ability to use the SetOrderExternalID Tx endpoint on behalf of a market.\\n - PERMISSION_CANCEL: PERMISSION_CANCEL is the ability to use the Cancel Tx endpoint on behalf of a market.\\n - PERMISSION_WITHDRAW: PERMISSION_WITHDRAW is the ability to use the MarketWithdraw Tx endpoint.\\n - PERMISSION_UPDATE: PERMISSION_UPDATE is the ability to use the MarketUpdate* Tx endpoints.\\n - PERMISSION_PERMISSIONS: PERMISSION_PERMISSIONS is the ability to use the MarketManagePermissions Tx endpoint.\\n - PERMISSION_ATTRIBUTES: PERMISSION_ATTRIBUTES is the ability to use the MarketManageReqAttrs Tx endpoint."},"description":"allowed is the list of permissions available for the address."}},"description":"AddrPermissions associates an address with a list of permissions available for that address."},"description":"access_grants is the list of addresses and permissions granted for this market."},"req_attr_create_ask":{"type":"array","items":{"type":"string"},"description":"req_attr_create_ask is a list of attributes required on an account for it to be allowed to create an ask order.\\nAn account must have all of these attributes in order to create an ask order in this market.\\nIf the list is empty, any account can create ask orders in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"b.x.a\\", or \\"c.b.a.x\\"."},"req_attr_create_bid":{"type":"array","items":{"type":"string"},"description":"req_attr_create_ask is a list of attributes required on an account for it to be allowed to create a bid order.\\nAn account must have all of these attributes in order to create a bid order in this market.\\nIf the list is empty, any account can create bid orders in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"c.b.x.a\\", or \\"c.b.a.x\\"."},"accepting_commitments":{"type":"boolean","format":"boolean","description":"accepting_commitments is whether the market is allowing users to commit funds to it."},"fee_create_commitment_flat":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"fee_create_commitment_flat is the flat fee charged for creating a commitment.\\nEach coin entry is a separate option. When a commitment is created, one of these must be paid.\\nIf empty, no fee is required to create a commitment."},"commitment_settlement_bips":{"type":"integer","format":"int64","description":"commitment_settlement_bips is the fraction of a commitment settlement that will be paid to the exchange.\\nIt is represented in basis points (1/100th of 1%, e.g. 0.0001) and is limited to 0 to 10,000 inclusive.\\nDuring a commitment settlement, the inputs are summed and NAVs are used to convert that total to the\\nintermediary denom, then to the fee denom. That is then multiplied by this value to get the fee amount\\nthat will be transferred out of the market\'s account into the exchange for that settlement.\\n\\nSumming the inputs effectively doubles the value of the settlement from what what is usually thought of\\nas the value of a trade. That should be taken into account when setting this value.\\nE.g. if two accounts are trading 10apples for 100grapes, the inputs total will be 10apples,100grapes\\n(which might then be converted to USD then nhash before applying this ratio); Usually, though, the value\\nof that trade would be viewed as either just 10apples or just 100grapes."},"intermediary_denom":{"type":"string","description":"intermediary_denom is the denom that funds get converted to (before being converted to the chain\'s fee denom)\\nwhen calculating the fees that are paid to the exchange. NAVs are used for this conversion and actions will fail\\nif a NAV is needed but not available."},"req_attr_create_commitment":{"type":"array","items":{"type":"string"},"description":"req_attr_create_commitment is a list of attributes required on an account for it to be allowed to create a\\ncommitment. An account must have all of these attributes in order to create a commitment in this market.\\nIf the list is empty, any account can create commitments in this market.\\n\\nAn entry that starts with \\"*.\\" will match any attributes that end with the rest of it.\\nE.g. \\"*.b.a\\" will match all of \\"c.b.a\\", \\"x.b.a\\", and \\"e.d.c.b.a\\"; but not \\"b.a\\", \\"xb.a\\", \\"c.b.x.a\\", or \\"c.b.a.x\\"."}}}},"description":"QueryGetMarketResponse is a response message for the GetMarket query."},"provenance.exchange.v1.QueryGetOrderByExternalIDResponse":{"type":"object","properties":{"order":{"description":"order is the requested order.","type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}}}},"description":"QueryGetOrderByExternalIDResponse is a response message for the GetOrderByExternalID query."},"provenance.exchange.v1.QueryGetOrderResponse":{"type":"object","properties":{"order":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}},"description":"Order associates an order id with one of the order types."}},"description":"QueryGetOrderResponse is a response message for the GetOrder query."},"provenance.exchange.v1.QueryGetOwnerOrdersResponse":{"type":"object","properties":{"orders":{"type":"array","items":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the numerical identifier for this order."},"ask_order":{"description":"ask_order is the information about this order if it represents an ask order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"seller":{"type":"string","description":"seller is the address of the account that owns this order and has the assets to sell."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"seller_settlement_flat_fee":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}},"bid_order":{"description":"bid_order is the information about this order if it represents a bid order.","type":"object","properties":{"market_id":{"type":"integer","format":"int64","description":"market_id identifies the market that this order belongs to."},"buyer":{"type":"string","description":"buyer is the address of the account that owns this order and has the price to spend."},"assets":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"buyer_settlement_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)\\nwhen the order is settled. A hold is placed on this until the order is filled or cancelled."},"allow_partial":{"type":"boolean","format":"boolean","description":"allow_partial should be true if partial fulfillment of this order should be allowed, and should be false if the\\norder must be either filled in full or not filled at all."},"external_id":{"type":"string","description":"external_id is an optional string used to externally identify this order. Max length is 100 characters.\\nIf an order in this market with this external id already exists, this order will be rejected."}}}},"description":"Order associates an order id with one of the order types."},"description":"orders are a page of the orders for the provided address."},"pagination":{"description":"pagination is the resulting pagination parameters.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryGetOwnerOrdersResponse is a response message for the GetOwnerOrders query."},"provenance.exchange.v1.QueryOrderFeeCalcResponse":{"type":"object","properties":{"creation_fee_options":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"creation_fee_options are the order creation flat fee options available for creating the provided order.\\nIf it\'s empty, no order creation fee is required.\\nWhen creating the order, you should include exactly one of these."},"settlement_flat_fee_options":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"settlement_flat_fee_options are the settlement flat fee options available for the provided order.\\nIf it\'s empty, no settlement flat fee is required.\\nWhen creating an order, you should include exactly one of these in the settlement fees field."},"settlement_ratio_fee_options":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"settlement_ratio_fee_options are the settlement ratio fee options available for the provided order.\\nIf it\'s empty, no settlement ratio fee is required.\\n\\nIf the provided order was a bid order, you should include exactly one of these in the settlement fees field.\\nIf the flat and ratio options you\'ve chose have the same denom, a single entry should be included with their sum.\\n\\nIf the provided order was an ask order, these are purely informational and represent how much will be removed\\nfrom your price if it settles at that price. If it settles for more, the actual amount will probably be larger."}},"description":"QueryOrderFeeCalcResponse is a response message for the OrderFeeCalc query."},"provenance.exchange.v1.QueryParamsResponse":{"type":"object","properties":{"params":{"description":"params are the exchange module parameter values.","type":"object","properties":{"default_split":{"type":"integer","format":"int64","description":"default_split is the default proportion of fees the exchange receives in basis points.\\nIt is used if there isn\'t an applicable denom-specific split defined.\\nE.g. 100 = 1%. Min = 0, Max = 10000."},"denom_splits":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string","description":"denom is the coin denomination this split applies to."},"split":{"type":"integer","format":"int64","description":"split is the proportion of fees the exchange receives for this denom in basis points.\\nE.g. 100 = 1%. Min = 0, Max = 10000."}},"description":"DenomSplit associates a coin denomination with an amount the exchange receives for that denom."},"description":"denom_splits are the denom-specific amounts the exchange receives."}}}},"description":"QueryParamsResponse is a response message for the Params query."},"provenance.exchange.v1.QueryValidateCreateMarketResponse":{"type":"object","properties":{"error":{"type":"string","description":"error is any problems or inconsistencies in the provided gov prop msg.\\nThis goes above and beyond the validation done when actually processing the governance proposal.\\nIf an error is returned, and gov_prop_will_pass is true, it means the error is more of an\\ninconsistency that might cause certain aspects of the market to behave unexpectedly."},"gov_prop_will_pass":{"type":"boolean","format":"boolean","description":"gov_prop_will_pass will be true if the the provided msg will be successfully processed at the end of it\'s voting\\nperiod (assuming it passes)."}},"description":"QueryValidateCreateMarketResponse is a response message for the ValidateCreateMarket query."},"provenance.exchange.v1.QueryValidateManageFeesResponse":{"type":"object","properties":{"error":{"type":"string","description":"error is any problems or inconsistencies in the provided gov prop msg.\\nThis goes above and beyond the validation done when actually processing the governance proposal.\\nIf an error is returned, and gov_prop_will_pass is true, it means the error is more of an\\ninconsistency that might cause certain aspects of the market to behave unexpectedly."},"gov_prop_will_pass":{"type":"boolean","format":"boolean","description":"gov_prop_will_pass will be true if the the provided msg will be successfully processed at the end of it\'s voting\\nperiod (assuming it passes)."}},"description":"QueryValidateManageFeesResponse is a response message for the ValidateManageFees query."},"provenance.exchange.v1.QueryValidateMarketResponse":{"type":"object","properties":{"error":{"type":"string","description":"error is any problems or inconsistencies in the provided market."}},"description":"QueryValidateMarketResponse is a response message for the ValidateMarket query."},"provenance.exchange.v1.MsgCancelOrderResponse":{"type":"object","description":"MsgCancelOrderResponse is a response message for the CancelOrder endpoint."},"provenance.exchange.v1.MsgCommitFundsResponse":{"type":"object","description":"MsgCommitFundsResponse is a response message for the CommitFunds endpoint."},"provenance.exchange.v1.MsgCreateAskResponse":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the id of the order created."}},"description":"MsgCreateAskResponse is a response message for the CreateAsk endpoint."},"provenance.exchange.v1.MsgCreateBidResponse":{"type":"object","properties":{"order_id":{"type":"string","format":"uint64","description":"order_id is the id of the order created."}},"description":"MsgCreateBidResponse is a response message for the CreateBid endpoint."},"provenance.exchange.v1.MsgFillAsksResponse":{"type":"object","description":"MsgFillAsksResponse is a response message for the FillAsks endpoint."},"provenance.exchange.v1.MsgFillBidsResponse":{"type":"object","description":"MsgFillBidsResponse is a response message for the FillBids endpoint."},"provenance.exchange.v1.MsgGovCloseMarketResponse":{"type":"object","description":"MsgGovCloseMarketResponse is a response message for the GovCloseMarket endpoint."},"provenance.exchange.v1.MsgGovCreateMarketResponse":{"type":"object","description":"MsgGovCreateMarketResponse is a response message for the GovCreateMarket endpoint."},"provenance.exchange.v1.MsgGovManageFeesResponse":{"type":"object","description":"MsgGovManageFeesResponse is a response message for the GovManageFees endpoint."},"provenance.exchange.v1.MsgGovUpdateParamsResponse":{"type":"object","description":"MsgGovUpdateParamsResponse is a response message for the GovUpdateParams endpoint."},"provenance.exchange.v1.MsgMarketCommitmentSettleResponse":{"type":"object","description":"MsgMarketCommitmentSettleResponse is a response message for the MarketCommitmentSettle endpoint."},"provenance.exchange.v1.MsgMarketManagePermissionsResponse":{"type":"object","description":"MsgMarketManagePermissionsResponse is a response message for the MarketManagePermissions endpoint."},"provenance.exchange.v1.MsgMarketManageReqAttrsResponse":{"type":"object","description":"MsgMarketManageReqAttrsResponse is a response message for the MarketManageReqAttrs endpoint."},"provenance.exchange.v1.MsgMarketReleaseCommitmentsResponse":{"type":"object","description":"MsgMarketReleaseCommitmentsResponse is a response message for the MarketReleaseCommitments endpoint."},"provenance.exchange.v1.MsgMarketSetOrderExternalIDResponse":{"type":"object","description":"MsgMarketSetOrderExternalIDResponse is a response message for the MarketSetOrderExternalID endpoint."},"provenance.exchange.v1.MsgMarketSettleResponse":{"type":"object","description":"MsgMarketSettleResponse is a response message for the MarketSettle endpoint."},"provenance.exchange.v1.MsgMarketUpdateAcceptingCommitmentsResponse":{"type":"object","description":"MsgMarketUpdateAcceptingCommitmentsResponse is a response message for the MarketUpdateAcceptingCommitments endpoint."},"provenance.exchange.v1.MsgMarketUpdateAcceptingOrdersResponse":{"type":"object","description":"MsgMarketUpdateAcceptingOrdersResponse is a response message for the MarketUpdateAcceptingOrders endpoint."},"provenance.exchange.v1.MsgMarketUpdateDetailsResponse":{"type":"object","description":"MsgMarketUpdateDetailsResponse is a response message for the MarketUpdateDetails endpoint."},"provenance.exchange.v1.MsgMarketUpdateEnabledResponse":{"type":"object","description":"MsgMarketUpdateEnabledResponse is a response message for the MarketUpdateEnabled endpoint.\\nDeprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders."},"provenance.exchange.v1.MsgMarketUpdateIntermediaryDenomResponse":{"type":"object","description":"MsgMarketUpdateIntermediaryDenomResponse is a response message for the MarketUpdateIntermediaryDenom endpoint."},"provenance.exchange.v1.MsgMarketUpdateUserSettleResponse":{"type":"object","description":"MsgMarketUpdateUserSettleResponse is a response message for the MarketUpdateUserSettle endpoint."},"provenance.exchange.v1.MsgMarketWithdrawResponse":{"type":"object","description":"MsgMarketWithdrawResponse is a response message for the MarketWithdraw endpoint."},"provenance.hold.v1.AccountHold":{"type":"object","properties":{"address":{"type":"string","description":"address is the account address that holds the funds on hold."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the balances that are on hold for the address."}},"description":"AccountHold associates an address with an amount on hold for that address."},"provenance.hold.v1.GetAllHoldsResponse":{"type":"object","properties":{"holds":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address is the account address that holds the funds on hold."},"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the balances that are on hold for the address."}},"description":"AccountHold associates an address with an amount on hold for that address."},"description":"holds is a list of addresses with funds on hold and the amounts being held."},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"GetAllHoldsResponse is the response type for the Query/GetAllHolds query."},"provenance.hold.v1.GetHoldsResponse":{"type":"object","properties":{"amount":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"amount is the total on hold for the requested address."}},"description":"GetHoldsResponse is the response type for the Query/GetHolds query."},"provenance.ibchooks.v1.MsgEmitIBCAckResponse":{"type":"object","properties":{"contract_result":{"type":"string"},"ibc_ack":{"type":"string"}},"title":"MsgEmitIBCAckResponse is the IBC Acknowledgement response"},"provenance.ibcratelimit.v1.Params":{"type":"object","properties":{"contract_address":{"type":"string","description":"contract_address is the address of the rate limiter contract."}},"description":"Params defines the parameters for the ibcratelimit module."},"provenance.ibcratelimit.v1.ParamsResponse":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"contract_address":{"type":"string","description":"contract_address is the address of the rate limiter contract."}}}},"description":"ParamsResponse is the response type for the Query/Params RPC method."},"provenance.ibcratelimit.v1.MsgGovUpdateParamsResponse":{"type":"object","description":"MsgGovUpdateParamsResponse is a response message for the GovUpdateParams endpoint."},"provenance.marker.v1.Access":{"type":"string","enum":["ACCESS_UNSPECIFIED","ACCESS_MINT","ACCESS_BURN","ACCESS_DEPOSIT","ACCESS_WITHDRAW","ACCESS_DELETE","ACCESS_ADMIN","ACCESS_TRANSFER","ACCESS_FORCE_TRANSFER"],"default":"ACCESS_UNSPECIFIED","description":"Access defines the different types of permissions that a marker supports granting to an address.\\n\\n - ACCESS_UNSPECIFIED: ACCESS_UNSPECIFIED defines a no-op vote option.\\n - ACCESS_MINT: ACCESS_MINT is the ability to increase the supply of a marker.\\n - ACCESS_BURN: ACCESS_BURN is the ability to decrease the supply of the marker using coin held by the marker.\\n - ACCESS_DEPOSIT: ACCESS_DEPOSIT is the ability to transfer funds from another account to this marker account\\nor to set a reference to this marker in the metadata/scopes module.\\n - ACCESS_WITHDRAW: ACCESS_WITHDRAW is the ability to transfer funds from this marker account to another account\\nor to remove a reference to this marker in the metadata/scopes module.\\n - ACCESS_DELETE: ACCESS_DELETE is the ability to move a proposed, finalized or active marker into the cancelled state.\\nThis access also allows cancelled markers to be marked for deletion.\\n - ACCESS_ADMIN: ACCESS_ADMIN is the ability to add access grants for accounts to the list of marker permissions.\\nThis access also gives the ability to update the marker\'s denom metadata.\\n - ACCESS_TRANSFER: ACCESS_TRANSFER is the ability to manage transfer settings and broker transfers of the marker.\\nAccounts with this access can:\\n - Update the marker\'s required attributes.\\n - Update the send-deny list.\\n - Use the transfer or bank send endpoints to move marker funds out of their own account.\\nThis access right is only supported on RESTRICTED markers.\\n - ACCESS_FORCE_TRANSFER: ACCESS_FORCE_TRANSFER is the ability to transfer restricted coins from a 3rd-party account without their signature.\\nThis access right is only supported on RESTRICTED markers and only has meaning when allow_forced_transfer is true."},"provenance.marker.v1.AccessGrant":{"type":"object","properties":{"address":{"type":"string"},"permissions":{"type":"array","items":{"type":"string","enum":["ACCESS_UNSPECIFIED","ACCESS_MINT","ACCESS_BURN","ACCESS_DEPOSIT","ACCESS_WITHDRAW","ACCESS_DELETE","ACCESS_ADMIN","ACCESS_TRANSFER","ACCESS_FORCE_TRANSFER"],"default":"ACCESS_UNSPECIFIED","description":"Access defines the different types of permissions that a marker supports granting to an address.\\n\\n - ACCESS_UNSPECIFIED: ACCESS_UNSPECIFIED defines a no-op vote option.\\n - ACCESS_MINT: ACCESS_MINT is the ability to increase the supply of a marker.\\n - ACCESS_BURN: ACCESS_BURN is the ability to decrease the supply of the marker using coin held by the marker.\\n - ACCESS_DEPOSIT: ACCESS_DEPOSIT is the ability to transfer funds from another account to this marker account\\nor to set a reference to this marker in the metadata/scopes module.\\n - ACCESS_WITHDRAW: ACCESS_WITHDRAW is the ability to transfer funds from this marker account to another account\\nor to remove a reference to this marker in the metadata/scopes module.\\n - ACCESS_DELETE: ACCESS_DELETE is the ability to move a proposed, finalized or active marker into the cancelled state.\\nThis access also allows cancelled markers to be marked for deletion.\\n - ACCESS_ADMIN: ACCESS_ADMIN is the ability to add access grants for accounts to the list of marker permissions.\\nThis access also gives the ability to update the marker\'s denom metadata.\\n - ACCESS_TRANSFER: ACCESS_TRANSFER is the ability to manage transfer settings and broker transfers of the marker.\\nAccounts with this access can:\\n - Update the marker\'s required attributes.\\n - Update the send-deny list.\\n - Use the transfer or bank send endpoints to move marker funds out of their own account.\\nThis access right is only supported on RESTRICTED markers.\\n - ACCESS_FORCE_TRANSFER: ACCESS_FORCE_TRANSFER is the ability to transfer restricted coins from a 3rd-party account without their signature.\\nThis access right is only supported on RESTRICTED markers and only has meaning when allow_forced_transfer is true."}}},"description":"AccessGrant associates a collection of permissions with an address for delegated marker account control."},"provenance.marker.v1.Balance":{"type":"object","properties":{"address":{"type":"string","description":"address is the address of the balance holder."},"coins":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"coins defines the different coins this balance holds."}},"title":"Balance defines an account address and balance pair used in queries for accounts holding a marker"},"provenance.marker.v1.MarkerStatus":{"type":"string","enum":["MARKER_STATUS_UNSPECIFIED","MARKER_STATUS_PROPOSED","MARKER_STATUS_FINALIZED","MARKER_STATUS_ACTIVE","MARKER_STATUS_CANCELLED","MARKER_STATUS_DESTROYED"],"default":"MARKER_STATUS_UNSPECIFIED","description":"MarkerStatus defines the various states a marker account can be in.\\n\\n - MARKER_STATUS_UNSPECIFIED: MARKER_STATUS_UNSPECIFIED - Unknown/Invalid Marker Status\\n - MARKER_STATUS_PROPOSED: MARKER_STATUS_PROPOSED - Initial configuration period, updates allowed, token supply not created.\\n - MARKER_STATUS_FINALIZED: MARKER_STATUS_FINALIZED - Configuration finalized, ready for supply creation\\n - MARKER_STATUS_ACTIVE: MARKER_STATUS_ACTIVE - Supply is created, rules are in force.\\n - MARKER_STATUS_CANCELLED: MARKER_STATUS_CANCELLED - Marker has been cancelled, pending destroy\\n - MARKER_STATUS_DESTROYED: MARKER_STATUS_DESTROYED - Marker supply has all been recalled, marker is considered destroyed and no further\\nactions allowed."},"provenance.marker.v1.NetAssetValue":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto.","title":"price is the complete value of the asset\'s volume"},"volume":{"type":"string","format":"uint64","title":"volume is the number of tokens of the marker that were purchased for the price"},"updated_block_height":{"type":"string","format":"uint64","title":"updated_block_height is the block height of last update"}},"title":"NetAssetValue defines a marker\'s net asset value"},"provenance.marker.v1.Params":{"type":"object","properties":{"max_total_supply":{"type":"string","format":"uint64","title":"Deprecated: Prefer to use `max_supply` instead. Maximum amount of supply to allow a marker to be created with"},"enable_governance":{"type":"boolean","format":"boolean","description":"indicates if governance based controls of markers is allowed."},"unrestricted_denom_regex":{"type":"string","title":"a regular expression used to validate marker denom values from normal create requests (governance\\nrequests are only subject to platform coin validation denom expression)"},"max_supply":{"type":"string","title":"maximum amount of supply to allow a marker to be created with"}},"description":"Params defines the set of params for the account module."},"provenance.marker.v1.QueryAccessResponse":{"type":"object","properties":{"accounts":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string"},"permissions":{"type":"array","items":{"type":"string","enum":["ACCESS_UNSPECIFIED","ACCESS_MINT","ACCESS_BURN","ACCESS_DEPOSIT","ACCESS_WITHDRAW","ACCESS_DELETE","ACCESS_ADMIN","ACCESS_TRANSFER","ACCESS_FORCE_TRANSFER"],"default":"ACCESS_UNSPECIFIED","description":"Access defines the different types of permissions that a marker supports granting to an address.\\n\\n - ACCESS_UNSPECIFIED: ACCESS_UNSPECIFIED defines a no-op vote option.\\n - ACCESS_MINT: ACCESS_MINT is the ability to increase the supply of a marker.\\n - ACCESS_BURN: ACCESS_BURN is the ability to decrease the supply of the marker using coin held by the marker.\\n - ACCESS_DEPOSIT: ACCESS_DEPOSIT is the ability to transfer funds from another account to this marker account\\nor to set a reference to this marker in the metadata/scopes module.\\n - ACCESS_WITHDRAW: ACCESS_WITHDRAW is the ability to transfer funds from this marker account to another account\\nor to remove a reference to this marker in the metadata/scopes module.\\n - ACCESS_DELETE: ACCESS_DELETE is the ability to move a proposed, finalized or active marker into the cancelled state.\\nThis access also allows cancelled markers to be marked for deletion.\\n - ACCESS_ADMIN: ACCESS_ADMIN is the ability to add access grants for accounts to the list of marker permissions.\\nThis access also gives the ability to update the marker\'s denom metadata.\\n - ACCESS_TRANSFER: ACCESS_TRANSFER is the ability to manage transfer settings and broker transfers of the marker.\\nAccounts with this access can:\\n - Update the marker\'s required attributes.\\n - Update the send-deny list.\\n - Use the transfer or bank send endpoints to move marker funds out of their own account.\\nThis access right is only supported on RESTRICTED markers.\\n - ACCESS_FORCE_TRANSFER: ACCESS_FORCE_TRANSFER is the ability to transfer restricted coins from a 3rd-party account without their signature.\\nThis access right is only supported on RESTRICTED markers and only has meaning when allow_forced_transfer is true."}}},"description":"AccessGrant associates a collection of permissions with an address for delegated marker account control."}}},"description":"QueryAccessResponse is the response type for the Query/MarkerAccess method."},"provenance.marker.v1.QueryAccountDataResponse":{"type":"object","properties":{"value":{"type":"string","description":"The accountdata for the requested denom."}},"title":"QueryAccountDataResponse is the response type for the Query/AccountData"},"provenance.marker.v1.QueryAllMarkersResponse":{"type":"object","properties":{"markers":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryAllMarkersResponse is the response type for the Query/AllMarkers method."},"provenance.marker.v1.QueryDenomMetadataResponse":{"type":"object","properties":{"metadata":{"type":"object","properties":{"description":{"type":"string"},"denom_units":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string","description":"denom represents the string name of the given denom unit (e.g uatom)."},"exponent":{"type":"integer","format":"int64","description":"exponent represents power of 10 exponent that one must\\nraise the base_denom to in order to equal the given DenomUnit\'s denom\\n1 denom = 10^exponent base_denom\\n(e.g. with a base_denom of uatom, one can create a DenomUnit of \'atom\' with\\nexponent = 6, thus: 1 atom = 10^6 uatom)."},"aliases":{"type":"array","items":{"type":"string"},"title":"aliases is a list of string aliases for the given denom"}},"description":"DenomUnit represents a struct that describes a given\\ndenomination unit of the basic token."},"title":"denom_units represents the list of DenomUnit\'s for a given coin"},"base":{"type":"string","description":"base represents the base denom (should be the DenomUnit with exponent = 0)."},"display":{"type":"string","description":"display indicates the suggested denom that should be\\ndisplayed in clients."},"name":{"type":"string","description":"Since: cosmos-sdk 0.43","title":"name defines the name of the token (eg: Cosmos Atom)"},"symbol":{"type":"string","description":"symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\\nbe the same as the display.\\n\\nSince: cosmos-sdk 0.43"},"uri":{"type":"string","description":"URI to a document (on or off-chain) that contains additional information. Optional.\\n\\nSince: cosmos-sdk 0.46"},"uri_hash":{"type":"string","description":"URIHash is a sha256 hash of a document pointed by URI. It\'s used to verify that\\nthe document didn\'t change. Optional.\\n\\nSince: cosmos-sdk 0.46"}},"description":"Metadata represents a struct that describes\\na basic token."}},"title":"QueryDenomMetadataResponse is the response type for the Query/DenomMetadata"},"provenance.marker.v1.QueryEscrowResponse":{"type":"object","properties":{"escrow":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}}},"description":"QueryEscrowResponse is the response type for the Query/MarkerEscrow method."},"provenance.marker.v1.QueryHoldingResponse":{"type":"object","properties":{"balances":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","description":"address is the address of the balance holder."},"coins":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"coins defines the different coins this balance holds."}},"title":"Balance defines an account address and balance pair used in queries for accounts holding a marker"}},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryHoldingResponse is the response type for the Query/MarkerHolders method."},"provenance.marker.v1.QueryMarkerResponse":{"type":"object","properties":{"marker":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"}},"description":"QueryMarkerResponse is the response type for the Query/Marker method."},"provenance.marker.v1.QueryNetAssetValuesResponse":{"type":"object","properties":{"net_asset_values":{"type":"array","items":{"type":"object","properties":{"price":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto.","title":"price is the complete value of the asset\'s volume"},"volume":{"type":"string","format":"uint64","title":"volume is the number of tokens of the marker that were purchased for the price"},"updated_block_height":{"type":"string","format":"uint64","title":"updated_block_height is the block height of last update"}},"title":"NetAssetValue defines a marker\'s net asset value"},"title":"net asset values for marker denom"}},"description":"QueryNetAssetValuesRequest is the response type for the Query/NetAssetValues method."},"provenance.marker.v1.QueryParamsResponse":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"max_total_supply":{"type":"string","format":"uint64","title":"Deprecated: Prefer to use `max_supply` instead. Maximum amount of supply to allow a marker to be created with"},"enable_governance":{"type":"boolean","format":"boolean","description":"indicates if governance based controls of markers is allowed."},"unrestricted_denom_regex":{"type":"string","title":"a regular expression used to validate marker denom values from normal create requests (governance\\nrequests are only subject to platform coin validation denom expression)"},"max_supply":{"type":"string","title":"maximum amount of supply to allow a marker to be created with"}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."},"provenance.marker.v1.QuerySupplyResponse":{"type":"object","properties":{"amount":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"QuerySupplyResponse is the response type for the Query/MarkerSupply method."},"ibc.applications.transfer.v1.MsgTransfer":{"type":"object","properties":{"source_port":{"type":"string","title":"the port on which the packet will be sent"},"source_channel":{"type":"string","title":"the channel by which the packet will be sent"},"token":{"title":"the tokens to be transferred","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"sender":{"type":"string","title":"the sender address"},"receiver":{"type":"string","title":"the recipient address on the destination chain"},"timeout_height":{"description":"Timeout height relative to the current block height.\\nThe timeout is disabled when set to 0.","type":"object","properties":{"revision_number":{"type":"string","format":"uint64","title":"the revision that the client is currently on"},"revision_height":{"type":"string","format":"uint64","title":"the height within the given revision"}},"title":"Height is a monotonically increasing data type\\nthat can be compared against another Height for the purposes of updating and\\nfreezing clients"},"timeout_timestamp":{"type":"string","format":"uint64","description":"Timeout timestamp in absolute nanoseconds since unix epoch.\\nThe timeout is disabled when set to 0."},"memo":{"type":"string","title":"optional memo"}},"title":"MsgTransfer defines a msg to transfer fungible tokens (i.e Coins) between\\nICS20 enabled chains. See ICS Spec here:\\nhttps://github.com/cosmos/ibc/tree/master/spec/app/ics-020-fungible-token-transfer#data-structures"},"ibc.core.client.v1.Height":{"type":"object","properties":{"revision_number":{"type":"string","format":"uint64","title":"the revision that the client is currently on"},"revision_height":{"type":"string","format":"uint64","title":"the height within the given revision"}},"description":"Normally the RevisionHeight is incremented at each height while keeping\\nRevisionNumber the same. However some consensus algorithms may choose to\\nreset the height in certain conditions e.g. hard forks, state-machine\\nbreaking changes In these cases, the RevisionNumber is incremented so that\\nheight continues to be monitonically increasing even as the RevisionHeight\\ngets reset","title":"Height is a monotonically increasing data type\\nthat can be compared against another Height for the purposes of updating and\\nfreezing clients"},"provenance.marker.v1.MarkerType":{"type":"string","enum":["MARKER_TYPE_UNSPECIFIED","MARKER_TYPE_COIN","MARKER_TYPE_RESTRICTED"],"default":"MARKER_TYPE_UNSPECIFIED","description":"- MARKER_TYPE_UNSPECIFIED: MARKER_TYPE_UNSPECIFIED is an invalid/unknown marker type.\\n - MARKER_TYPE_COIN: MARKER_TYPE_COIN is a marker that represents a standard fungible coin (default).\\n - MARKER_TYPE_RESTRICTED: MARKER_TYPE_RESTRICTED is a marker that represents a denom with send_enabled = false.","title":"MarkerType defines the types of marker"},"provenance.marker.v1.MsgActivateResponse":{"type":"object","title":"MsgActivateResponse defines the Msg/Activate response type"},"provenance.marker.v1.MsgAddAccessResponse":{"type":"object","title":"MsgAddAccessResponse defines the Msg/AddAccess response type"},"provenance.marker.v1.MsgAddFinalizeActivateMarkerResponse":{"type":"object","title":"MsgAddFinalizeActivateMarkerResponse defines the Msg/AddFinalizeActivateMarker response type"},"provenance.marker.v1.MsgAddMarkerResponse":{"type":"object","title":"MsgAddMarkerResponse defines the Msg/AddMarker response type"},"provenance.marker.v1.MsgAddNetAssetValuesResponse":{"type":"object","title":"MsgAddNetAssetValuesResponse defines the Msg/AddNetAssetValue response type"},"provenance.marker.v1.MsgBurnResponse":{"type":"object","title":"MsgBurnResponse defines the Msg/Burn response type"},"provenance.marker.v1.MsgCancelResponse":{"type":"object","title":"MsgCancelResponse defines the Msg/Cancel response type"},"provenance.marker.v1.MsgDeleteAccessResponse":{"type":"object","title":"MsgDeleteAccessResponse defines the Msg/DeleteAccess response type"},"provenance.marker.v1.MsgDeleteResponse":{"type":"object","title":"MsgDeleteResponse defines the Msg/Delete response type"},"provenance.marker.v1.MsgFinalizeResponse":{"type":"object","title":"MsgFinalizeResponse defines the Msg/Finalize response type"},"provenance.marker.v1.MsgGrantAllowanceResponse":{"type":"object","description":"MsgGrantAllowanceResponse defines the Msg/GrantAllowanceResponse response type."},"provenance.marker.v1.MsgIbcTransferResponse":{"type":"object","title":"MsgIbcTransferResponse defines the Msg/IbcTransfer response type"},"provenance.marker.v1.MsgMintResponse":{"type":"object","title":"MsgMintResponse defines the Msg/Mint response type"},"provenance.marker.v1.MsgSetAccountDataResponse":{"type":"object","title":"MsgSetAccountDataResponse defines the Msg/SetAccountData response type"},"provenance.marker.v1.MsgSetDenomMetadataResponse":{"type":"object","title":"MsgSetDenomMetadataResponse defines the Msg/SetDenomMetadata response type"},"provenance.marker.v1.MsgSupplyIncreaseProposalResponse":{"type":"object","title":"MsgSupplyIncreaseProposalResponse defines the Msg/SupplyIncreaseProposal response type"},"provenance.marker.v1.MsgTransferResponse":{"type":"object","title":"MsgTransferResponse defines the Msg/Transfer response type"},"provenance.marker.v1.MsgUpdateForcedTransferResponse":{"type":"object","title":"MsgUpdateForcedTransferResponse defines the Msg/UpdateForcedTransfer response type"},"provenance.marker.v1.MsgUpdateRequiredAttributesResponse":{"type":"object","title":"MsgUpdateRequiredAttributesResponse defines the Msg/UpdateRequiredAttributes response type"},"provenance.marker.v1.MsgUpdateSendDenyListResponse":{"type":"object","title":"MsgUpdateSendDenyListResponse defines the Msg/UpdateSendDenyList response type"},"provenance.marker.v1.MsgWithdrawResponse":{"type":"object","title":"MsgWithdrawResponse defines the Msg/Withdraw response type"},"provenance.metadata.v1.AccountDataResponse":{"type":"object","properties":{"value":{"type":"string","description":"The accountdata for the requested metadata address."}},"description":"AccountDataResponse is the response type for the Query/AccountData RPC method."},"provenance.metadata.v1.AuditFields":{"type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"},"provenance.metadata.v1.ContractSpecIdInfo":{"type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}},"description":"ContractSpecIdInfo contains various info regarding a contract specification id."},"provenance.metadata.v1.ContractSpecification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"title":"Description information for this contract specification","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}},"description":"Description holds general information that is handy to associate with a structure."},"owner_addresses":{"type":"array","items":{"type":"string"},"title":"Address of the account that owns this specificaiton"},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"a list of party roles that must be fullfilled when signing a transaction for this contract specification"},"resource_id":{"type":"string","format":"byte","title":"the address of a record on chain that represents this contract"},"hash":{"type":"string","title":"the hash of contract binary (off-chain instance)"},"class_name":{"type":"string","title":"name of the class/type of this contract executable"}},"title":"ContractSpecification defines the required parties, resources, conditions, and consideration outputs for a contract"},"provenance.metadata.v1.ContractSpecificationRequest":{"type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44."},"include_record_specs":{"type":"boolean","format":"boolean","description":"include_record_specs is a flag for whether to include the the record specifications of this contract specification\\nin the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}},"description":"ContractSpecificationRequest is the request type for the Query/ContractSpecification RPC method."},"provenance.metadata.v1.ContractSpecificationResponse":{"type":"object","properties":{"contract_specification":{"description":"contract_specification is the wrapped contract specification.","type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"title":"Description information for this contract specification","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}},"description":"Description holds general information that is handy to associate with a structure."},"owner_addresses":{"type":"array","items":{"type":"string"},"title":"Address of the account that owns this specificaiton"},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"a list of party roles that must be fullfilled when signing a transaction for this contract specification"},"resource_id":{"type":"string","format":"byte","title":"the address of a record on chain that represents this contract"},"hash":{"type":"string","title":"the hash of contract binary (off-chain instance)"},"class_name":{"type":"string","title":"name of the class/type of this contract executable"}},"title":"ContractSpecification defines the required parties, resources, conditions, and consideration outputs for a contract","description":"specification is the on-chain contract specification message."},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}},"record_specifications":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs","description":"specification is the on-chain record specification message."},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordSpecificationWrapper contains a single record specification and some extra identifiers for it."},"description":"record_specifications is any number or wrapped record specifications associated with this contract_specification\\n(if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44."},"include_record_specs":{"type":"boolean","format":"boolean","description":"include_record_specs is a flag for whether to include the the record specifications of this contract specification\\nin the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"ContractSpecificationResponse is the response type for the Query/ContractSpecification RPC method."},"provenance.metadata.v1.ContractSpecificationWrapper":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"title":"Description information for this contract specification","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}},"description":"Description holds general information that is handy to associate with a structure."},"owner_addresses":{"type":"array","items":{"type":"string"},"title":"Address of the account that owns this specificaiton"},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"a list of party roles that must be fullfilled when signing a transaction for this contract specification"},"resource_id":{"type":"string","format":"byte","title":"the address of a record on chain that represents this contract"},"hash":{"type":"string","title":"the hash of contract binary (off-chain instance)"},"class_name":{"type":"string","title":"name of the class/type of this contract executable"}},"title":"ContractSpecification defines the required parties, resources, conditions, and consideration outputs for a contract","description":"specification is the on-chain contract specification message."},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"ContractSpecificationWrapper contains a single contract specification and some extra identifiers for it."},"provenance.metadata.v1.ContractSpecificationsAllRequest":{"type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}},"description":"ContractSpecificationsAllRequest is the request type for the Query/ContractSpecificationsAll RPC method."},"provenance.metadata.v1.ContractSpecificationsAllResponse":{"type":"object","properties":{"contract_specifications":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"title":"Description information for this contract specification","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}},"description":"Description holds general information that is handy to associate with a structure."},"owner_addresses":{"type":"array","items":{"type":"string"},"title":"Address of the account that owns this specificaiton"},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"a list of party roles that must be fullfilled when signing a transaction for this contract specification"},"resource_id":{"type":"string","format":"byte","title":"the address of a record on chain that represents this contract"},"hash":{"type":"string","title":"the hash of contract binary (off-chain instance)"},"class_name":{"type":"string","title":"name of the class/type of this contract executable"}},"title":"ContractSpecification defines the required parties, resources, conditions, and consideration outputs for a contract","description":"specification is the on-chain contract specification message."},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"ContractSpecificationWrapper contains a single contract specification and some extra identifiers for it."},"description":"contract_specifications are the wrapped contract specifications."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"ContractSpecificationsAllResponse is the response type for the Query/ContractSpecificationsAll RPC method."},"provenance.metadata.v1.DefinitionType":{"type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name","title":"DefinitionType indicates the required definition type for this value"},"provenance.metadata.v1.Description":{"type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}},"description":"Description holds general information that is handy to associate with a structure."},"provenance.metadata.v1.GetByAddrResponse":{"type":"object","properties":{"scopes":{"type":"array","items":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"description":"scopes contains any scopes that were requested and found."},"sessions":{"type":"array","items":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"description":"sessions contains any sessions that were requested and found."},"records":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract"},"description":"records contains any records that were requested and found."},"scope_specs":{"type":"array","items":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"description":"General information about this scope specification.","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}}},"owner_addresses":{"type":"array","items":{"type":"string"},"description":"Addresses of the owners of this scope specification."},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"A list of parties that must be present on a scope (and their associated roles)"},"contract_spec_ids":{"type":"array","items":{"type":"string","format":"byte"},"description":"A list of contract specification ids allowed for a scope based on this specification."}},"title":"ScopeSpecification defines the required parties, resources, conditions, and consideration outputs for a contract"},"description":"scope_specs contains any scope specifications that were requested and found."},"contract_specs":{"type":"array","items":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"title":"Description information for this contract specification","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}},"description":"Description holds general information that is handy to associate with a structure."},"owner_addresses":{"type":"array","items":{"type":"string"},"title":"Address of the account that owns this specificaiton"},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"a list of party roles that must be fullfilled when signing a transaction for this contract specification"},"resource_id":{"type":"string","format":"byte","title":"the address of a record on chain that represents this contract"},"hash":{"type":"string","title":"the hash of contract binary (off-chain instance)"},"class_name":{"type":"string","title":"name of the class/type of this contract executable"}},"title":"ContractSpecification defines the required parties, resources, conditions, and consideration outputs for a contract"},"description":"contract_specs contains any contract specifications that were requested and found."},"record_specs":{"type":"array","items":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs"},"description":"record_specs contains any record specifications that were requested and found."},"not_found":{"type":"array","items":{"type":"string"},"description":"not_found contains any addrs requested but not found."}},"description":"GetByAddrResponse is the response type for the Query/GetByAddr RPC method."},"provenance.metadata.v1.InputSpecification":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"provenance.metadata.v1.NetAssetValue":{"type":"object","properties":{"price":{"title":"price is the complete value of the asset\'s volume","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"updated_block_height":{"type":"string","format":"uint64","title":"updated_block_height is the block height of last update"}},"title":"NetAssetValue defines a scope\'s net asset value"},"provenance.metadata.v1.OSAllLocatorsRequest":{"type":"object","properties":{"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}},"description":"OSAllLocatorsRequest is the request type for the Query/OSAllLocators RPC method."},"provenance.metadata.v1.OSAllLocatorsResponse":{"type":"object","properties":{"locators":{"type":"array","items":{"type":"object","properties":{"owner":{"type":"string","title":"account address the endpoint is owned by"},"locator_uri":{"type":"string","title":"locator endpoint uri"},"encryption_key":{"type":"string","title":"owners encryption key address"}},"description":"Defines an Locator object stored on chain, which represents a owner( blockchain address) associated with a endpoint\\nuri for it\'s associated object store."}},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"OSAllLocatorsResponse is the response type for the Query/OSAllLocators RPC method."},"provenance.metadata.v1.OSLocatorParams":{"type":"object","properties":{"max_uri_length":{"type":"integer","format":"int64"}},"description":"Params defines the parameters for the metadata-locator module methods."},"provenance.metadata.v1.OSLocatorParamsRequest":{"type":"object","properties":{"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}},"description":"OSLocatorParamsRequest is the request type for the Query/OSLocatorParams RPC method."},"provenance.metadata.v1.OSLocatorParamsResponse":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"max_uri_length":{"type":"integer","format":"int64"}}},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"OSLocatorParamsResponse is the response type for the Query/OSLocatorParams RPC method."},"provenance.metadata.v1.OSLocatorRequest":{"type":"object","properties":{"owner":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}},"description":"OSLocatorRequest is the request type for the Query/OSLocator RPC method."},"provenance.metadata.v1.OSLocatorResponse":{"type":"object","properties":{"locator":{"type":"object","properties":{"owner":{"type":"string","title":"account address the endpoint is owned by"},"locator_uri":{"type":"string","title":"locator endpoint uri"},"encryption_key":{"type":"string","title":"owners encryption key address"}},"description":"Defines an Locator object stored on chain, which represents a owner( blockchain address) associated with a endpoint\\nuri for it\'s associated object store."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"owner":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"OSLocatorResponse is the response type for the Query/OSLocator RPC method."},"provenance.metadata.v1.OSLocatorsByScopeRequest":{"type":"object","properties":{"scope_id":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}},"description":"OSLocatorsByScopeRequest is the request type for the Query/OSLocatorsByScope RPC method."},"provenance.metadata.v1.OSLocatorsByScopeResponse":{"type":"object","properties":{"locators":{"type":"array","items":{"type":"object","properties":{"owner":{"type":"string","title":"account address the endpoint is owned by"},"locator_uri":{"type":"string","title":"locator endpoint uri"},"encryption_key":{"type":"string","title":"owners encryption key address"}},"description":"Defines an Locator object stored on chain, which represents a owner( blockchain address) associated with a endpoint\\nuri for it\'s associated object store."}},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"scope_id":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"OSLocatorsByScopeResponse is the response type for the Query/OSLocatorsByScope RPC method."},"provenance.metadata.v1.OSLocatorsByURIRequest":{"type":"object","properties":{"uri":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}},"description":"OSLocatorsByURIRequest is the request type for the Query/OSLocatorsByURI RPC method."},"provenance.metadata.v1.OSLocatorsByURIResponse":{"type":"object","properties":{"locators":{"type":"array","items":{"type":"object","properties":{"owner":{"type":"string","title":"account address the endpoint is owned by"},"locator_uri":{"type":"string","title":"locator endpoint uri"},"encryption_key":{"type":"string","title":"owners encryption key address"}},"description":"Defines an Locator object stored on chain, which represents a owner( blockchain address) associated with a endpoint\\nuri for it\'s associated object store."}},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"uri":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"OSLocatorsByURIResponse is the response type for the Query/OSLocatorsByURI RPC method."},"provenance.metadata.v1.ObjectStoreLocator":{"type":"object","properties":{"owner":{"type":"string","title":"account address the endpoint is owned by"},"locator_uri":{"type":"string","title":"locator endpoint uri"},"encryption_key":{"type":"string","title":"owners encryption key address"}},"description":"Defines an Locator object stored on chain, which represents a owner( blockchain address) associated with a endpoint\\nuri for it\'s associated object store."},"provenance.metadata.v1.OwnershipRequest":{"type":"object","properties":{"address":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}},"description":"OwnershipRequest is the request type for the Query/Ownership RPC method."},"provenance.metadata.v1.OwnershipResponse":{"type":"object","properties":{"scope_uuids":{"type":"array","items":{"type":"string"},"description":"A list of scope ids (uuid) associated with the given address."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"address":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"OwnershipResponse is the response type for the Query/Ownership RPC method."},"provenance.metadata.v1.Params":{"type":"object","description":"Params defines the set of params for the metadata module."},"provenance.metadata.v1.Party":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"provenance.metadata.v1.PartyType":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"provenance.metadata.v1.Process":{"type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}},"title":"Process contains information used to uniquely identify what was used to generate this record"},"provenance.metadata.v1.QueryParamsRequest":{"type":"object","properties":{"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}},"description":"QueryParamsRequest is the request type for the Query/Params RPC method."},"provenance.metadata.v1.QueryParamsResponse":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object"},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."},"provenance.metadata.v1.QueryScopeNetAssetValuesResponse":{"type":"object","properties":{"net_asset_values":{"type":"array","items":{"type":"object","properties":{"price":{"title":"price is the complete value of the asset\'s volume","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"updated_block_height":{"type":"string","format":"uint64","title":"updated_block_height is the block height of last update"}},"title":"NetAssetValue defines a scope\'s net asset value"},"title":"net asset values for scope"}},"description":"QueryNetAssetValuesRequest is the response type for the Query/NetAssetValues method."},"provenance.metadata.v1.Record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract"},"provenance.metadata.v1.RecordIdInfo":{"type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}},"description":"RecordIdInfo contains various info regarding a record id."},"provenance.metadata.v1.RecordInput":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"provenance.metadata.v1.RecordInputStatus":{"type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain","title":"A set of types for inputs on a record (of fact)"},"provenance.metadata.v1.RecordOutput":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"provenance.metadata.v1.RecordSpecIdInfo":{"type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"RecordSpecIdInfo contains various info regarding a record specification id."},"provenance.metadata.v1.RecordSpecification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs"},"provenance.metadata.v1.RecordSpecificationRequest":{"type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44."},"name":{"type":"string","description":"name is the name of the record to look up.\\nIt is required if the specification_id is a uuid or contract specification address.\\nIt is ignored if the specification_id is a record specification address."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}},"description":"RecordSpecificationRequest is the request type for the Query/RecordSpecification RPC method."},"provenance.metadata.v1.RecordSpecificationResponse":{"type":"object","properties":{"record_specification":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs","description":"specification is the on-chain record specification message."},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordSpecificationWrapper contains a single record specification and some extra identifiers for it."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44."},"name":{"type":"string","description":"name is the name of the record to look up.\\nIt is required if the specification_id is a uuid or contract specification address.\\nIt is ignored if the specification_id is a record specification address."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordSpecificationResponse is the response type for the Query/RecordSpecification RPC method."},"provenance.metadata.v1.RecordSpecificationWrapper":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs","description":"specification is the on-chain record specification message."},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordSpecificationWrapper contains a single record specification and some extra identifiers for it."},"provenance.metadata.v1.RecordSpecificationsAllRequest":{"type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}},"description":"RecordSpecificationsAllRequest is the request type for the Query/RecordSpecificationsAll RPC method."},"provenance.metadata.v1.RecordSpecificationsAllResponse":{"type":"object","properties":{"record_specifications":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs","description":"specification is the on-chain record specification message."},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordSpecificationWrapper contains a single record specification and some extra identifiers for it."},"description":"record_specifications are the wrapped record specifications."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"RecordSpecificationsAllResponse is the response type for the Query/RecordSpecificationsAll RPC method."},"provenance.metadata.v1.RecordSpecificationsForContractSpecificationRequest":{"type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}},"description":"RecordSpecificationsForContractSpecificationRequest is the request type for the\\nQuery/RecordSpecificationsForContractSpecification RPC method."},"provenance.metadata.v1.RecordSpecificationsForContractSpecificationResponse":{"type":"object","properties":{"record_specifications":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs","description":"specification is the on-chain record specification message."},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordSpecificationWrapper contains a single record specification and some extra identifiers for it."},"description":"record_specifications is any number of wrapped record specifications associated with this contract_specification."},"contract_specification_uuid":{"type":"string","description":"contract_specification_uuid is the uuid of this contract specification."},"contract_specification_addr":{"type":"string","description":"contract_specification_addr is the contract specification address as a bech32 encoded string."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. def6bc0a-c9dd-4874-948f-5206e6060a84 or a bech32 contract specification\\naddress, e.g. contractspec1q000d0q2e8w5say53afqdesxp2zqzkr4fn.\\nIt can also be a record specification address, e.g.\\nrecspec1qh00d0q2e8w5say53afqdesxp2zw42dq2jdvmdazuwzcaddhh8gmuqhez44."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordSpecificationsForContractSpecificationResponse is the response type for the\\nQuery/RecordSpecificationsForContractSpecification RPC method."},"provenance.metadata.v1.RecordWrapper":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"provenance.metadata.v1.RecordsAllRequest":{"type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}},"description":"RecordsAllRequest is the request type for the Query/RecordsAll RPC method."},"provenance.metadata.v1.RecordsAllResponse":{"type":"object","properties":{"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records are the wrapped records."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"RecordsAllResponse is the response type for the Query/RecordsAll RPC method."},"provenance.metadata.v1.RecordsRequest":{"type":"object","properties":{"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"name":{"type":"string","title":"name is the name of the record to look for"},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the the scope containing these records in the response."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions containing these records in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}},"description":"RecordsRequest is the request type for the Query/Records RPC method."},"provenance.metadata.v1.RecordsResponse":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these records (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped sessions that hold these records (if requested)."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped record results."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"name":{"type":"string","title":"name is the name of the record to look for"},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the the scope containing these records in the response."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions containing these records in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"RecordsResponse is the response type for the Query/Records RPC method."},"provenance.metadata.v1.ResultStatus":{"type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed.","title":"ResultStatus indicates the various states of execution of a record"},"provenance.metadata.v1.Scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"provenance.metadata.v1.ScopeIdInfo":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}},"description":"ScopeIdInfo contains various info regarding a scope id."},"provenance.metadata.v1.ScopeRequest":{"type":"object","properties":{"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_addr":{"type":"string","description":"session_addr is a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr."},"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions of the scope in the response."},"include_records":{"type":"boolean","format":"boolean","description":"include_records is a flag for whether to include the records of the scope in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}},"description":"ScopeRequest is the request type for the Query/Scope RPC method."},"provenance.metadata.v1.ScopeResponse":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope result.","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped sessions in this scope (if requested)."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped records in this scope (if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_addr":{"type":"string","description":"session_addr is a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr."},"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"include_sessions":{"type":"boolean","format":"boolean","description":"include_sessions is a flag for whether to include the sessions of the scope in the response."},"include_records":{"type":"boolean","format":"boolean","description":"include_records is a flag for whether to include the records of the scope in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"ScopeResponse is the response type for the Query/Scope RPC method."},"provenance.metadata.v1.ScopeSpecIdInfo":{"type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}},"description":"ScopeSpecIdInfo contains various info regarding a scope specification id."},"provenance.metadata.v1.ScopeSpecification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"description":"General information about this scope specification.","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}}},"owner_addresses":{"type":"array","items":{"type":"string"},"description":"Addresses of the owners of this scope specification."},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"A list of parties that must be present on a scope (and their associated roles)"},"contract_spec_ids":{"type":"array","items":{"type":"string","format":"byte"},"description":"A list of contract specification ids allowed for a scope based on this specification."}},"title":"ScopeSpecification defines the required parties, resources, conditions, and consideration outputs for a contract"},"provenance.metadata.v1.ScopeSpecificationRequest":{"type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. dc83ea70-eacd-40fe-9adf-1cf6148bf8a2 or a bech32 scope specification\\naddress, e.g. scopespec1qnwg86nsatx5pl56muw0v9ytlz3qu3jx6m."},"include_contract_specs":{"type":"boolean","format":"boolean","description":"include_contract_specs is a flag for whether to include the contract specifications of the scope specification in\\nthe response."},"include_record_specs":{"type":"boolean","format":"boolean","description":"include_record_specs is a flag for whether to include the record specifications of the scope specification in the\\nresponse."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}},"description":"ScopeSpecificationRequest is the request type for the Query/ScopeSpecification RPC method."},"provenance.metadata.v1.ScopeSpecificationResponse":{"type":"object","properties":{"scope_specification":{"description":"scope_specification is the wrapped scope specification.","type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"description":"General information about this scope specification.","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}}},"owner_addresses":{"type":"array","items":{"type":"string"},"description":"Addresses of the owners of this scope specification."},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"A list of parties that must be present on a scope (and their associated roles)"},"contract_spec_ids":{"type":"array","items":{"type":"string","format":"byte"},"description":"A list of contract specification ids allowed for a scope based on this specification."}},"title":"ScopeSpecification defines the required parties, resources, conditions, and consideration outputs for a contract","description":"specification is the on-chain scope specification message."},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"contract_specs":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"title":"Description information for this contract specification","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}},"description":"Description holds general information that is handy to associate with a structure."},"owner_addresses":{"type":"array","items":{"type":"string"},"title":"Address of the account that owns this specificaiton"},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"a list of party roles that must be fullfilled when signing a transaction for this contract specification"},"resource_id":{"type":"string","format":"byte","title":"the address of a record on chain that represents this contract"},"hash":{"type":"string","title":"the hash of contract binary (off-chain instance)"},"class_name":{"type":"string","title":"name of the class/type of this contract executable"}},"title":"ContractSpecification defines the required parties, resources, conditions, and consideration outputs for a contract","description":"specification is the on-chain contract specification message."},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"ContractSpecificationWrapper contains a single contract specification and some extra identifiers for it."},"description":"contract_specs is any number of wrapped contract specifications in this scope specification (if requested)."},"record_specs":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"name":{"type":"string","title":"Name of Record that will be created when this specification is used"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","title":"name for this input"},"type_name":{"type":"string","title":"a type_name (typically a proto name or class_name)"},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"}},"title":"InputSpecification defines a name, type_name, and source reference (either on or off chain) to define an input\\nparameter"},"title":"A set of inputs that must be satisified to apply this RecordSpecification and create a Record"},"type_name":{"type":"string","title":"A type name for data associated with this record (typically a class or proto name)"},"result_type":{"title":"Type of result for this record specification (must be RECORD or RECORD_LIST)","type":"string","enum":["DEFINITION_TYPE_UNSPECIFIED","DEFINITION_TYPE_PROPOSED","DEFINITION_TYPE_RECORD","DEFINITION_TYPE_RECORD_LIST"],"default":"DEFINITION_TYPE_UNSPECIFIED","description":"- DEFINITION_TYPE_UNSPECIFIED: DEFINITION_TYPE_UNSPECIFIED indicates an unknown/invalid value\\n - DEFINITION_TYPE_PROPOSED: DEFINITION_TYPE_PROPOSED indicates a proposed value is used here (a record that is not on-chain)\\n - DEFINITION_TYPE_RECORD: DEFINITION_TYPE_RECORD indicates the value must be a reference to a record on chain\\n - DEFINITION_TYPE_RECORD_LIST: DEFINITION_TYPE_RECORD_LIST indicates the value maybe a reference to a collection of values on chain having\\nthe same name"},"responsible_parties":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"Type of party responsible for this record"}},"title":"RecordSpecification defines the specification for a Record including allowed/required inputs/outputs","description":"specification is the on-chain record specification message."},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordSpecificationWrapper contains a single record specification and some extra identifiers for it."},"description":"record_specs is any number of wrapped record specifications in this scope specification (if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"specification_id":{"type":"string","description":"specification_id can either be a uuid, e.g. dc83ea70-eacd-40fe-9adf-1cf6148bf8a2 or a bech32 scope specification\\naddress, e.g. scopespec1qnwg86nsatx5pl56muw0v9ytlz3qu3jx6m."},"include_contract_specs":{"type":"boolean","format":"boolean","description":"include_contract_specs is a flag for whether to include the contract specifications of the scope specification in\\nthe response."},"include_record_specs":{"type":"boolean","format":"boolean","description":"include_record_specs is a flag for whether to include the record specifications of the scope specification in the\\nresponse."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"ScopeSpecificationResponse is the response type for the Query/ScopeSpecification RPC method."},"provenance.metadata.v1.ScopeSpecificationWrapper":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"description":"General information about this scope specification.","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}}},"owner_addresses":{"type":"array","items":{"type":"string"},"description":"Addresses of the owners of this scope specification."},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"A list of parties that must be present on a scope (and their associated roles)"},"contract_spec_ids":{"type":"array","items":{"type":"string","format":"byte"},"description":"A list of contract specification ids allowed for a scope based on this specification."}},"title":"ScopeSpecification defines the required parties, resources, conditions, and consideration outputs for a contract","description":"specification is the on-chain scope specification message."},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}},"description":"ScopeSpecificationWrapper contains a single scope specification and some extra identifiers for it."},"provenance.metadata.v1.ScopeSpecificationsAllRequest":{"type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}},"description":"ScopeSpecificationsAllRequest is the request type for the Query/ScopeSpecificationsAll RPC method."},"provenance.metadata.v1.ScopeSpecificationsAllResponse":{"type":"object","properties":{"scope_specifications":{"type":"array","items":{"type":"object","properties":{"specification":{"type":"object","properties":{"specification_id":{"type":"string","format":"byte","title":"unique identifier for this specification on chain"},"description":{"description":"General information about this scope specification.","type":"object","properties":{"name":{"type":"string","description":"A Name for this thing."},"description":{"type":"string","description":"A description of this thing."},"website_url":{"type":"string","description":"URL to find even more info."},"icon_url":{"type":"string","description":"URL of an icon."}}},"owner_addresses":{"type":"array","items":{"type":"string"},"description":"Addresses of the owners of this scope specification."},"parties_involved":{"type":"array","items":{"type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain","title":"PartyType are the different roles parties on a contract may use"},"title":"A list of parties that must be present on a scope (and their associated roles)"},"contract_spec_ids":{"type":"array","items":{"type":"string","format":"byte"},"description":"A list of contract specification ids allowed for a scope based on this specification."}},"title":"ScopeSpecification defines the required parties, resources, conditions, and consideration outputs for a contract","description":"specification is the on-chain scope specification message."},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}},"description":"ScopeSpecificationWrapper contains a single scope specification and some extra identifiers for it."},"description":"scope_specifications are the wrapped scope specifications."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"ScopeSpecificationsAllResponse is the response type for the Query/ScopeSpecificationsAll RPC method."},"provenance.metadata.v1.ScopeWrapper":{"type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}},"description":"SessionWrapper contains a single scope and its uuid."},"provenance.metadata.v1.ScopesAllRequest":{"type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}},"description":"ScopesAllRequest is the request type for the Query/ScopesAll RPC method."},"provenance.metadata.v1.ScopesAllResponse":{"type":"object","properties":{"scopes":{"type":"array","items":{"type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}},"description":"SessionWrapper contains a single scope and its uuid."},"description":"scopes are the wrapped scopes."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"ScopesAllResponse is the response type for the Query/ScopesAll RPC method."},"provenance.metadata.v1.Session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"provenance.metadata.v1.SessionIdInfo":{"type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}},"description":"SessionIdInfo contains various info regarding a session id."},"provenance.metadata.v1.SessionWrapper":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"provenance.metadata.v1.SessionsAllRequest":{"type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}},"description":"SessionsAllRequest is the request type for the Query/SessionsAll RPC method."},"provenance.metadata.v1.SessionsAllResponse":{"type":"object","properties":{"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions are the wrapped sessions."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"SessionsAllResponse is the response type for the Query/SessionsAll RPC method."},"provenance.metadata.v1.SessionsRequest":{"type":"object","properties":{"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"record_name":{"type":"string","description":"record_name is the name of the record to find the session for in the provided scope."},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the scope containing these sessions in the response."},"include_records":{"type":"boolean","format":"boolean","description":"include_records is a flag for whether to include the records of these sessions in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}},"description":"SessionsRequest is the request type for the Query/Sessions RPC method."},"provenance.metadata.v1.SessionsResponse":{"type":"object","properties":{"scope":{"description":"scope is the wrapped scope that holds these sessions (if requested).","type":"object","properties":{"scope":{"type":"object","properties":{"scope_id":{"type":"string","format":"byte","title":"Unique ID for this scope.  Implements sdk.Address interface for use where addresses are required in Cosmos"},"specification_id":{"type":"string","format":"byte","title":"the scope specification that contains the specifications for data elements allowed within this scope"},"owners":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"description":"These parties represent top level owners of the records within.  These parties must sign any requests that modify\\nthe data within the scope.  These addresses are in union with parties listed on the sessions."},"data_access":{"type":"array","items":{"type":"string"},"description":"Addresses in this list are authorized to receive off-chain data associated with this scope."},"value_owner_address":{"type":"string","description":"An address that controls the value associated with this scope.  Standard blockchain accounts and marker accounts\\nare supported for this value.  This attribute may only be changed by the entity indicated once it is set."},"require_party_rollup":{"type":"boolean","format":"boolean","description":"Whether all parties in this scope and its sessions must be present in this scope\'s owners field.\\nThis also enables use of optional=true scope owners and session parties."}},"description":"Scope defines a root reference for a collection of records owned by one or more parties."},"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}},"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}}},"sessions":{"type":"array","items":{"type":"object","properties":{"session":{"type":"object","properties":{"session_id":{"type":"string","format":"byte"},"specification_id":{"type":"string","format":"byte","description":"unique id of the contract specification that was used to create this session."},"parties":{"type":"array","items":{"type":"object","properties":{"address":{"type":"string","title":"address of the account (on chain)"},"role":{"title":"a role for this account within the context of the processes used","type":"string","enum":["PARTY_TYPE_UNSPECIFIED","PARTY_TYPE_ORIGINATOR","PARTY_TYPE_SERVICER","PARTY_TYPE_INVESTOR","PARTY_TYPE_CUSTODIAN","PARTY_TYPE_OWNER","PARTY_TYPE_AFFILIATE","PARTY_TYPE_OMNIBUS","PARTY_TYPE_PROVENANCE","PARTY_TYPE_CONTROLLER","PARTY_TYPE_VALIDATOR"],"default":"PARTY_TYPE_UNSPECIFIED","description":"- PARTY_TYPE_UNSPECIFIED: PARTY_TYPE_UNSPECIFIED is an error condition\\n - PARTY_TYPE_ORIGINATOR: PARTY_TYPE_ORIGINATOR is an asset originator\\n - PARTY_TYPE_SERVICER: PARTY_TYPE_SERVICER provides debt servicing functions\\n - PARTY_TYPE_INVESTOR: PARTY_TYPE_INVESTOR is a generic investor\\n - PARTY_TYPE_CUSTODIAN: PARTY_TYPE_CUSTODIAN is an entity that provides custodian services for assets\\n - PARTY_TYPE_OWNER: PARTY_TYPE_OWNER indicates this party is an owner of the item\\n - PARTY_TYPE_AFFILIATE: PARTY_TYPE_AFFILIATE is a party with an affiliate agreement\\n - PARTY_TYPE_OMNIBUS: PARTY_TYPE_OMNIBUS is a special type of party that controls an omnibus bank account\\n - PARTY_TYPE_PROVENANCE: PARTY_TYPE_PROVENANCE is used to indicate this party represents the blockchain or a smart contract action\\n - PARTY_TYPE_CONTROLLER: PARTY_TYPE_CONTROLLER is an entity which controls a specific asset on chain (ie enote)\\n - PARTY_TYPE_VALIDATOR: PARTY_TYPE_VALIDATOR is an entity which validates given assets on chain"},"optional":{"type":"boolean","format":"boolean","title":"whether this party\'s signature is optional"}},"title":"A Party is an address with/in a given role associated with a contract"},"title":"parties is the set of identities that signed this contract"},"name":{"type":"string","title":"name to associate with this session execution context, typically classname"},"context":{"type":"string","format":"byte","description":"context is a field for storing client specific data associated with a session."},"audit":{"description":"Created by, updated by, timestamps, version number, and related info.","type":"object","properties":{"created_date":{"type":"string","format":"date-time","title":"the date/time when this entry was created"},"created_by":{"type":"string","title":"the address of the account that created this record"},"updated_date":{"type":"string","format":"date-time","title":"the date/time when this entry was last updated"},"updated_by":{"type":"string","title":"the address of the account that modified this record"},"version":{"type":"integer","format":"int64","title":"an optional version number that is incremented with each update"},"message":{"type":"string","title":"an optional message associated with the creation/update event"}},"title":"AuditFields capture information about the last account to make modifications and when they were made"}},"description":"Session defines an execution context against a specific specification instance.\\nThe context will have a specification and set of parties involved.\\n\\nNOTE: When there are no more Records within a Scope that reference a Session, the Session is removed."},"session_id_info":{"description":"session_id_info contains information about the id/address of the session.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"SessionWrapper contains a single session and some extra identifiers for it."},"description":"sessions is any number of wrapped session results."},"records":{"type":"array","items":{"type":"object","properties":{"record":{"type":"object","properties":{"name":{"type":"string","title":"name/identifier for this record.  Value must be unique within the scope.  Also known as a Fact name"},"session_id":{"type":"string","format":"byte","title":"id of the session context that was used to create this record (use with filtered kvprefix iterator)"},"process":{"title":"process contain information used to uniquely identify an execution on or off chain that generated this record","type":"object","properties":{"address":{"type":"string","title":"the address of a smart contract used for this process"},"hash":{"type":"string","title":"the hash of an off-chain process used"},"name":{"type":"string","title":"a name associated with the process (type_name, classname or smart contract common name)"},"method":{"type":"string","title":"method is a name or reference to a specific operation (method) within a class/contract that was invoked"}}},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string","description":"Name value included to link back to the definition spec."},"record_id":{"type":"string","format":"byte","title":"the address of a record on chain (For Established Records)"},"hash":{"type":"string","title":"the hash of an off-chain piece of information (For Proposed Records)"},"type_name":{"type":"string","title":"from proposed fact structure to unmarshal"},"status":{"title":"Indicates if this input was a recorded fact on chain or just a given hashed input","type":"string","enum":["RECORD_INPUT_STATUS_UNSPECIFIED","RECORD_INPUT_STATUS_PROPOSED","RECORD_INPUT_STATUS_RECORD"],"default":"RECORD_INPUT_STATUS_UNSPECIFIED","description":"- RECORD_INPUT_STATUS_UNSPECIFIED: RECORD_INPUT_STATUS_UNSPECIFIED indicates an invalid/unknown input type\\n - RECORD_INPUT_STATUS_PROPOSED: RECORD_INPUT_STATUS_PROPOSED indicates this input was an arbitrary piece of data that was hashed\\n - RECORD_INPUT_STATUS_RECORD: RECORD_INPUT_STATUS_RECORD indicates this input is a reference to a previously recorded fact on blockchain"}},"title":"Tracks the inputs used to establish this record"},"title":"inputs used with the process to achieve the output on this record"},"outputs":{"type":"array","items":{"type":"object","properties":{"hash":{"type":"string","title":"Hash of the data output that was output/generated for this record"},"status":{"title":"Status of the process execution associated with this output indicating success,failure, or pending","type":"string","enum":["RESULT_STATUS_UNSPECIFIED","RESULT_STATUS_PASS","RESULT_STATUS_SKIP","RESULT_STATUS_FAIL"],"default":"RESULT_STATUS_UNSPECIFIED","description":"- RESULT_STATUS_UNSPECIFIED: RESULT_STATUS_UNSPECIFIED indicates an unset condition\\n - RESULT_STATUS_PASS: RESULT_STATUS_PASS indicates the execution was successful\\n - RESULT_STATUS_SKIP: RESULT_STATUS_SKIP indicates condition/consideration was skipped due to missing inputs or delayed execution\\n - RESULT_STATUS_FAIL: RESULT_STATUS_FAIL indicates the execution of the condition/consideration failed."}},"title":"RecordOutput encapsulates the output of a process recorded on chain"},"title":"output(s) is the results of executing the process on the given process indicated in this record"},"specification_id":{"type":"string","format":"byte","description":"specification_id is the id of the record specification that was used to create this record."}},"title":"A record (of fact) is attached to a session or each consideration output from a contract","description":"record is the on-chain record message."},"record_id_info":{"description":"record_id_info contains information about the id/address of the record.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}},"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"RecordWrapper contains a single record and some extra identifiers for it."},"description":"records is any number of wrapped records contained in these sessions (if requested)."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"scope_id":{"type":"string","description":"scope_id can either be a uuid, e.g. 91978ba2-5f35-459a-86a7-feca1b0512e0 or a bech32 scope address, e.g.\\nscope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel."},"session_id":{"type":"string","description":"session_id can either be a uuid, e.g. 5803f8bc-6067-4eb5-951f-2121671c2ec0 or a bech32 session address, e.g.\\nsession1qxge0zaztu65tx5x5llv5xc9zts9sqlch3sxwn44j50jzgt8rshvqyfrjcr. This can only be a uuid if a scope_id is also\\nprovided."},"record_addr":{"type":"string","description":"record_addr is a bech32 record address, e.g. record1q2ge0zaztu65tx5x5llv5xc9ztsw42dq2jdvmdazuwzcaddhh8gmu3mcze3."},"record_name":{"type":"string","description":"record_name is the name of the record to find the session for in the provided scope."},"include_scope":{"type":"boolean","format":"boolean","description":"include_scope is a flag for whether to include the scope containing these sessions in the response."},"include_records":{"type":"boolean","format":"boolean","description":"include_records is a flag for whether to include the records of these sessions in the response."},"exclude_id_info":{"type":"boolean","format":"boolean","description":"exclude_id_info is a flag for whether to exclude the id info from the response."},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."}}}},"description":"SessionsResponse is the response type for the Query/Sessions RPC method."},"provenance.metadata.v1.ValueOwnershipRequest":{"type":"object","properties":{"address":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}},"description":"ValueOwnershipRequest is the request type for the Query/ValueOwnership RPC method."},"provenance.metadata.v1.ValueOwnershipResponse":{"type":"object","properties":{"scope_uuids":{"type":"array","items":{"type":"string"},"description":"A list of scope ids (uuid) associated with the given address."},"request":{"description":"request is a copy of the request that generated these results.","type":"object","properties":{"address":{"type":"string"},"include_request":{"type":"boolean","format":"boolean","description":"include_request is a flag for whether to include this request in your result."},"pagination":{"description":"pagination defines optional pagination parameters for the request.","type":"object","properties":{"key":{"type":"string","format":"byte","description":"key is a value returned in PageResponse.next_key to begin\\nquerying the next page most efficiently. Only one of offset or key\\nshould be set."},"offset":{"type":"string","format":"uint64","description":"offset is a numeric offset that can be used when key is unavailable.\\nIt is less efficient than using key. Only one of offset or key should\\nbe set."},"limit":{"type":"string","format":"uint64","description":"limit is the total number of results to be returned in the result page.\\nIf left empty it will default to a value to be set by each app."},"count_total":{"type":"boolean","format":"boolean","description":"count_total is set to true  to indicate that the result set should include\\na count of the total number of items available for pagination in UIs.\\ncount_total is only respected when offset is used. It is ignored when key\\nis set."},"reverse":{"type":"boolean","format":"boolean","description":"reverse is set to true if results are to be returned in the descending order.\\n\\nSince: cosmos-sdk 0.43"}},"title":"PageRequest is to be embedded in gRPC request messages for efficient\\npagination. Ex:"}}},"pagination":{"description":"pagination provides the pagination information of this response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"ValueOwnershipResponse is the response type for the Query/ValueOwnership RPC method."},"provenance.metadata.v1.MsgAddContractSpecToScopeSpecResponse":{"type":"object","description":"MsgAddContractSpecToScopeSpecResponse is the response type for the Msg/AddContractSpecToScopeSpec RPC method."},"provenance.metadata.v1.MsgAddNetAssetValuesResponse":{"type":"object","title":"MsgAddNetAssetValuesResponse defines the Msg/AddNetAssetValue response type"},"provenance.metadata.v1.MsgAddScopeDataAccessResponse":{"type":"object","title":"MsgAddScopeDataAccessResponse is the response for adding data access AccAddress to scope"},"provenance.metadata.v1.MsgAddScopeOwnerResponse":{"type":"object","title":"MsgAddScopeOwnerResponse is the response for adding owner AccAddresses to scope"},"provenance.metadata.v1.MsgBindOSLocatorResponse":{"type":"object","properties":{"locator":{"type":"object","properties":{"owner":{"type":"string","title":"account address the endpoint is owned by"},"locator_uri":{"type":"string","title":"locator endpoint uri"},"encryption_key":{"type":"string","title":"owners encryption key address"}},"description":"Defines an Locator object stored on chain, which represents a owner( blockchain address) associated with a endpoint\\nuri for it\'s associated object store."}},"description":"MsgBindOSLocatorResponse is the response type for the Msg/BindOSLocator RPC method."},"provenance.metadata.v1.MsgDeleteContractSpecFromScopeSpecResponse":{"type":"object","description":"MsgDeleteContractSpecFromScopeSpecResponse is the response type for the Msg/DeleteContractSpecFromScopeSpec RPC\\nmethod."},"provenance.metadata.v1.MsgDeleteContractSpecificationResponse":{"type":"object","description":"MsgDeleteContractSpecificationResponse is the response type for the Msg/DeleteContractSpecification RPC method."},"provenance.metadata.v1.MsgDeleteOSLocatorResponse":{"type":"object","properties":{"locator":{"type":"object","properties":{"owner":{"type":"string","title":"account address the endpoint is owned by"},"locator_uri":{"type":"string","title":"locator endpoint uri"},"encryption_key":{"type":"string","title":"owners encryption key address"}},"description":"Defines an Locator object stored on chain, which represents a owner( blockchain address) associated with a endpoint\\nuri for it\'s associated object store."}},"description":"MsgDeleteOSLocatorResponse is the response type for the Msg/DeleteOSLocator RPC method."},"provenance.metadata.v1.MsgDeleteRecordResponse":{"type":"object","description":"MsgDeleteRecordResponse is the response type for the Msg/DeleteRecord RPC method."},"provenance.metadata.v1.MsgDeleteRecordSpecificationResponse":{"type":"object","description":"MsgDeleteRecordSpecificationResponse is the response type for the Msg/DeleteRecordSpecification RPC method."},"provenance.metadata.v1.MsgDeleteScopeDataAccessResponse":{"type":"object","title":"MsgDeleteScopeDataAccessResponse is the response from removing data access AccAddress to scope"},"provenance.metadata.v1.MsgDeleteScopeOwnerResponse":{"type":"object","title":"MsgDeleteScopeOwnerResponse is the response from removing owner AccAddress to scope"},"provenance.metadata.v1.MsgDeleteScopeResponse":{"type":"object","description":"MsgDeleteScopeResponse is the response type for the Msg/DeleteScope RPC method."},"provenance.metadata.v1.MsgDeleteScopeSpecificationResponse":{"type":"object","description":"MsgDeleteScopeSpecificationResponse is the response type for the Msg/DeleteScopeSpecification RPC method."},"provenance.metadata.v1.MsgMigrateValueOwnerResponse":{"type":"object","description":"MsgMigrateValueOwnerResponse is the response from migrating a value owner address."},"provenance.metadata.v1.MsgModifyOSLocatorResponse":{"type":"object","properties":{"locator":{"type":"object","properties":{"owner":{"type":"string","title":"account address the endpoint is owned by"},"locator_uri":{"type":"string","title":"locator endpoint uri"},"encryption_key":{"type":"string","title":"owners encryption key address"}},"description":"Defines an Locator object stored on chain, which represents a owner( blockchain address) associated with a endpoint\\nuri for it\'s associated object store."}},"description":"MsgModifyOSLocatorResponse is the response type for the Msg/ModifyOSLocator RPC method."},"provenance.metadata.v1.MsgSetAccountDataResponse":{"type":"object","description":"MsgSetAccountDataResponse is the response from setting/updating/deleting a scope\'s account data."},"provenance.metadata.v1.MsgUpdateValueOwnersResponse":{"type":"object","description":"MsgUpdateValueOwnersResponse is the response from updating value owner addresses in one or more scopes."},"provenance.metadata.v1.MsgWriteContractSpecificationResponse":{"type":"object","properties":{"contract_spec_id_info":{"description":"contract_spec_id_info contains information about the id/address of the contract specification that was added or\\nupdated.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}},"description":"MsgWriteContractSpecificationResponse is the response type for the Msg/WriteContractSpecification RPC method."},"provenance.metadata.v1.MsgWriteRecordResponse":{"type":"object","properties":{"record_id_info":{"description":"record_id_info contains information about the id/address of the record that was added or updated.","type":"object","properties":{"record_id":{"type":"string","format":"byte","description":"record_id is the raw bytes of the record address."},"record_id_prefix":{"type":"string","format":"byte","description":"record_id_prefix is the prefix portion of the record_id."},"record_id_scope_uuid":{"type":"string","format":"byte","description":"record_id_scope_uuid is the scope_uuid portion of the record_id."},"record_id_hashed_name":{"type":"string","format":"byte","description":"record_id_hashed_name is the hashed name portion of the record_id."},"record_addr":{"type":"string","description":"record_addr is the bech32 string version of the record_id."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the record_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}}},"description":"MsgWriteRecordResponse is the response type for the Msg/WriteRecord RPC method."},"provenance.metadata.v1.MsgWriteRecordSpecificationResponse":{"type":"object","properties":{"record_spec_id_info":{"description":"record_spec_id_info contains information about the id/address of the record specification that was added or\\nupdated.","type":"object","properties":{"record_spec_id":{"type":"string","format":"byte","description":"record_spec_id is the raw bytes of the record specification address."},"record_spec_id_prefix":{"type":"string","format":"byte","description":"record_spec_id_prefix is the prefix portion of the record_spec_id."},"record_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"record_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the record_spec_id."},"record_spec_id_hashed_name":{"type":"string","format":"byte","description":"record_spec_id_hashed_name is the hashed name portion of the record_spec_id."},"record_spec_addr":{"type":"string","description":"record_spec_addr is the bech32 string version of the record_spec_id."},"contract_spec_id_info":{"description":"contract_spec_id_info is information about the contract spec id referenced in the record_spec_id.","type":"object","properties":{"contract_spec_id":{"type":"string","format":"byte","description":"contract_spec_id is the raw bytes of the contract specification address."},"contract_spec_id_prefix":{"type":"string","format":"byte","description":"contract_spec_id_prefix is the prefix portion of the contract_spec_id."},"contract_spec_id_contract_spec_uuid":{"type":"string","format":"byte","description":"contract_spec_id_contract_spec_uuid is the contract_spec_uuid portion of the contract_spec_id."},"contract_spec_addr":{"type":"string","description":"contract_spec_addr is the bech32 string version of the contract_spec_id."},"contract_spec_uuid":{"type":"string","description":"contract_spec_uuid is the uuid hex string of the contract_spec_id_contract_spec_uuid."}}}}}},"description":"MsgWriteRecordSpecificationResponse is the response type for the Msg/WriteRecordSpecification RPC method."},"provenance.metadata.v1.MsgWriteScopeResponse":{"type":"object","properties":{"scope_id_info":{"description":"scope_id_info contains information about the id/address of the scope that was added or updated.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}},"description":"MsgWriteScopeResponse is the response type for the Msg/WriteScope RPC method."},"provenance.metadata.v1.MsgWriteScopeSpecificationResponse":{"type":"object","properties":{"scope_spec_id_info":{"description":"scope_spec_id_info contains information about the id/address of the scope specification that was added or updated.","type":"object","properties":{"scope_spec_id":{"type":"string","format":"byte","description":"scope_spec_id is the raw bytes of the scope specification address."},"scope_spec_id_prefix":{"type":"string","format":"byte","description":"scope_spec_id_prefix is the prefix portion of the scope_spec_id."},"scope_spec_id_scope_spec_uuid":{"type":"string","format":"byte","description":"scope_spec_id_scope_spec_uuid is the scope_spec_uuid portion of the scope_spec_id."},"scope_spec_addr":{"type":"string","description":"scope_spec_addr is the bech32 string version of the scope_spec_id."},"scope_spec_uuid":{"type":"string","description":"scope_spec_uuid is the uuid hex string of the scope_spec_id_scope_spec_uuid."}}}},"description":"MsgWriteScopeSpecificationResponse is the response type for the Msg/WriteScopeSpecification RPC method."},"provenance.metadata.v1.MsgWriteSessionResponse":{"type":"object","properties":{"session_id_info":{"description":"session_id_info contains information about the id/address of the session that was added or updated.","type":"object","properties":{"session_id":{"type":"string","format":"byte","description":"session_id is the raw bytes of the session address."},"session_id_prefix":{"type":"string","format":"byte","description":"session_id_prefix is the prefix portion of the session_id."},"session_id_scope_uuid":{"type":"string","format":"byte","description":"session_id_scope_uuid is the scope_uuid portion of the session_id."},"session_id_session_uuid":{"type":"string","format":"byte","description":"session_id_session_uuid is the session_uuid portion of the session_id."},"session_addr":{"type":"string","description":"session_addr is the bech32 string version of the session_id."},"session_uuid":{"type":"string","description":"session_uuid is the uuid hex string of the session_id_session_uuid."},"scope_id_info":{"description":"scope_id_info is information about the scope id referenced in the session_id.","type":"object","properties":{"scope_id":{"type":"string","format":"byte","description":"scope_id is the raw bytes of the scope address."},"scope_id_prefix":{"type":"string","format":"byte","description":"scope_id_prefix is the prefix portion of the scope_id."},"scope_id_scope_uuid":{"type":"string","format":"byte","description":"scope_id_scope_uuid is the scope_uuid portion of the scope_id."},"scope_addr":{"type":"string","description":"scope_addr is the bech32 string version of the scope_id."},"scope_uuid":{"type":"string","description":"scope_uuid is the uuid hex string of the scope_id_scope_uuid."}}}}}},"description":"MsgWriteSessionResponse is the response type for the Msg/WriteSession RPC method."},"provenance.metadata.v1.SessionIdComponents":{"type":"object","properties":{"scope_uuid":{"type":"string","title":"scope_uuid is the uuid string for the scope, e.g. \\"91978ba2-5f35-459a-86a7-feca1b0512e0\\""},"scope_addr":{"type":"string","title":"scope_addr is the bech32 address string for the scope, g.g. \\"scope1qzge0zaztu65tx5x5llv5xc9ztsqxlkwel\\""},"session_uuid":{"type":"string","title":"session_uuid is a uuid string for identifying this session, e.g. \\"5803f8bc-6067-4eb5-951f-2121671c2ec0\\""}},"description":"SessionIDComponents contains fields for the components that make up a session id."},"provenance.msgfees.v1.CalculateTxFeesRequest":{"type":"object","properties":{"tx_bytes":{"type":"string","format":"byte","description":"tx_bytes is the transaction to simulate."},"default_base_denom":{"type":"string","description":"default_base_denom is used to set the denom used for gas fees\\nif not set it will default to nhash."},"gas_adjustment":{"type":"number","format":"float","title":"gas_adjustment is the adjustment factor to be multiplied against the estimate returned by the tx simulation"}},"description":"CalculateTxFeesRequest is the request type for the Query RPC method."},"provenance.msgfees.v1.CalculateTxFeesResponse":{"type":"object","properties":{"additional_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"title":"additional_fees are the amount of coins to be for addition msg fees"},"total_fees":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"total_fees are the total amount of fees needed for the transactions (msg fees + gas fee)\\nnote: the gas fee is calculated with the floor gas price module param."},"estimated_gas":{"type":"string","format":"uint64","title":"estimated_gas is the amount of gas needed for the transaction"}},"description":"CalculateTxFeesResponse is the response type for the Query RPC method."},"provenance.msgfees.v1.MsgFee":{"type":"object","properties":{"msg_type_url":{"type":"string"},"additional_fee":{"title":"additional_fee can pay in any Coin( basically a Denom and Amount, Amount can be zero)","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"recipient":{"type":"string"},"recipient_basis_points":{"type":"integer","format":"int64"}},"title":"MsgFee is the core of what gets stored on the blockchain\\nit consists of four parts\\n1. the msg type url, i.e. /cosmos.bank.v1beta1.MsgSend\\n2. minimum additional fees(can be of any denom)\\n3. optional recipient of fee based on `recipient_basis_points`\\n4. if recipient is declared they will recieve the basis points of the fee (0-10,000)"},"provenance.msgfees.v1.Params":{"type":"object","properties":{"floor_gas_price":{"description":"floor_gas_price is the constant used to calculate fees when gas fees shares denom with msg fee.\\n\\nConversions:\\n  - x nhash/usd-mil = 1,000,000/x usd/hash\\n  - y usd/hash = 1,000,000/y nhash/usd-mil\\n\\nExamples:\\n  - 40,000,000 nhash/usd-mil = 1,000,000/40,000,000 usd/hash = $0.025/hash,\\n  - $0.040/hash = 1,000,000/0.040 nhash/usd-mil = 25,000,000 nhash/usd-mil","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"nhash_per_usd_mil":{"type":"string","format":"uint64","description":"nhash_per_usd_mil is the total nhash per usd mil for converting usd to nhash."},"conversion_fee_denom":{"type":"string","description":"conversion_fee_denom is the denom usd is converted to."}},"description":"Params defines the set of params for the msgfees module."},"provenance.msgfees.v1.QueryAllMsgFeesResponse":{"type":"object","properties":{"msg_fees":{"type":"array","items":{"type":"object","properties":{"msg_type_url":{"type":"string"},"additional_fee":{"title":"additional_fee can pay in any Coin( basically a Denom and Amount, Amount can be zero)","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"recipient":{"type":"string"},"recipient_basis_points":{"type":"integer","format":"int64"}},"title":"MsgFee is the core of what gets stored on the blockchain\\nit consists of four parts\\n1. the msg type url, i.e. /cosmos.bank.v1beta1.MsgSend\\n2. minimum additional fees(can be of any denom)\\n3. optional recipient of fee based on `recipient_basis_points`\\n4. if recipient is declared they will recieve the basis points of the fee (0-10,000)"}},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"title":"response for querying all msg\'s with fees associated with them"},"provenance.msgfees.v1.QueryParamsResponse":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"floor_gas_price":{"description":"floor_gas_price is the constant used to calculate fees when gas fees shares denom with msg fee.\\n\\nConversions:\\n  - x nhash/usd-mil = 1,000,000/x usd/hash\\n  - y usd/hash = 1,000,000/y nhash/usd-mil\\n\\nExamples:\\n  - 40,000,000 nhash/usd-mil = 1,000,000/40,000,000 usd/hash = $0.025/hash,\\n  - $0.040/hash = 1,000,000/0.040 nhash/usd-mil = 25,000,000 nhash/usd-mil","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"nhash_per_usd_mil":{"type":"string","format":"uint64","description":"nhash_per_usd_mil is the total nhash per usd mil for converting usd to nhash."},"conversion_fee_denom":{"type":"string","description":"conversion_fee_denom is the denom usd is converted to."}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."},"provenance.msgfees.v1.MsgAddMsgFeeProposalResponse":{"type":"object","title":"MsgAddMsgFeeProposalResponse defines the Msg/AddMsgFeeProposal response type"},"provenance.msgfees.v1.MsgAssessCustomMsgFeeResponse":{"type":"object","description":"MsgAssessCustomMsgFeeResponse defines the Msg/AssessCustomMsgFeee response type."},"provenance.msgfees.v1.MsgRemoveMsgFeeProposalResponse":{"type":"object","title":"MsgRemoveMsgFeeProposalResponse defines the Msg/RemoveMsgFeeProposal response type"},"provenance.msgfees.v1.MsgUpdateConversionFeeDenomProposalResponse":{"type":"object","title":"MsgUpdateConversionFeeDenomProposalResponse defines the Msg/UpdateConversionFeeDenomProposal response type"},"provenance.msgfees.v1.MsgUpdateMsgFeeProposalResponse":{"type":"object","title":"MsgUpdateMsgFeeProposalResponse defines the Msg/RemoveMsgFeeProposal response type"},"provenance.msgfees.v1.MsgUpdateNhashPerUsdMilProposalResponse":{"type":"object","title":"MsgUpdateNhashPerUsdMilProposalResponse defines the Msg/UpdateNhashPerUsdMilProposal response type"},"provenance.name.v1.Params":{"type":"object","properties":{"max_segment_length":{"type":"integer","format":"int64","title":"maximum length of name segment to allow"},"min_segment_length":{"type":"integer","format":"int64","title":"minimum length of name segment to allow"},"max_name_levels":{"type":"integer","format":"int64","title":"maximum number of name segments to allow.  Example: `foo.bar.baz` would be 3"},"allow_unrestricted_names":{"type":"boolean","format":"boolean","title":"determines if unrestricted name keys are allowed or not"}},"description":"Params defines the set of params for the name module."},"provenance.name.v1.QueryParamsResponse":{"type":"object","properties":{"params":{"description":"params defines the parameters of the module.","type":"object","properties":{"max_segment_length":{"type":"integer","format":"int64","title":"maximum length of name segment to allow"},"min_segment_length":{"type":"integer","format":"int64","title":"minimum length of name segment to allow"},"max_name_levels":{"type":"integer","format":"int64","title":"maximum number of name segments to allow.  Example: `foo.bar.baz` would be 3"},"allow_unrestricted_names":{"type":"boolean","format":"boolean","title":"determines if unrestricted name keys are allowed or not"}}}},"description":"QueryParamsResponse is the response type for the Query/Params RPC method."},"provenance.name.v1.QueryResolveResponse":{"type":"object","properties":{"address":{"type":"string","title":"a string containing the address the name resolves to"},"restricted":{"type":"boolean","format":"boolean","description":"Whether owner signature is required to add sub-names."}},"description":"QueryResolveResponse is the response type for the Query/Resolve method."},"provenance.name.v1.QueryReverseLookupResponse":{"type":"object","properties":{"name":{"type":"array","items":{"type":"string"},"title":"an array of names bound against a given address"},"pagination":{"description":"pagination defines an optional pagination for the request.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryReverseLookupResponse is the response type for the Query/Resolve method."},"provenance.name.v1.MsgBindNameResponse":{"type":"object","description":"MsgBindNameResponse defines the Msg/BindName response type."},"provenance.name.v1.MsgCreateRootNameResponse":{"type":"object","description":"MsgCreateRootNameResponse defines Msg/CreateRootName response type."},"provenance.name.v1.MsgDeleteNameResponse":{"type":"object","description":"MsgDeleteNameResponse defines the Msg/DeleteName response type."},"provenance.name.v1.MsgModifyNameResponse":{"type":"object","description":"MsgModifyNameResponse defines the Msg/ModifyName response type."},"provenance.name.v1.NameRecord":{"type":"object","properties":{"name":{"type":"string","title":"the bound name"},"address":{"type":"string","title":"the address the name resolved to"},"restricted":{"type":"boolean","format":"boolean","title":"whether owner signature is required to add sub-names"}},"title":"NameRecord is a structure used to bind ownership of a name hierarchy to a collection of addresses"},"provenance.oracle.v1.QueryOracleAddressResponse":{"type":"object","properties":{"address":{"type":"string","title":"The address of the oracle"}},"description":"QueryOracleAddressResponse contains the address of the oracle."},"provenance.oracle.v1.QueryOracleResponse":{"type":"object","properties":{"data":{"type":"string","format":"byte","description":"Data contains the json data returned from the oracle."}},"description":"QueryOracleResponse contains the result of the query sent to the oracle."},"provenance.oracle.v1.MsgSendQueryOracleResponse":{"type":"object","properties":{"sequence":{"type":"string","format":"uint64","description":"The sequence number that uniquely identifies the query."}},"description":"MsgSendQueryOracleResponse contains the id of the oracle query."},"provenance.oracle.v1.MsgUpdateOracleResponse":{"type":"object","description":"MsgUpdateOracleResponse is the response type for updating the oracle."},"provenance.reward.v1.ActionDelegate":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful delegates."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful delegates."},"minimum_delegation_amount":{"description":"Minimum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"maximum_delegation_amount":{"description":"Maximum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"minimum_active_stake_percentile":{"type":"string","description":"Minimum percentile that can be below the validator\'s power ranking."},"maximum_active_stake_percentile":{"type":"string","description":"Maximum percentile that can be below the validator\'s power ranking."}},"description":"ActionDelegate represents the delegate action and its required eligibility criteria."},"provenance.reward.v1.ActionTransfer":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful transfers."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful transfers."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the transfer action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}}},"description":"ActionTransfer represents the transfer action and its required eligibility criteria."},"provenance.reward.v1.ActionVote":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful votes."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful votes."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the vote action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"validator_multiplier":{"type":"string","format":"uint64","title":"Positive multiplier that is applied to the shares awarded by the vote action when conditions\\nare met(for now the only condition is the current vote is a validator vote). A value of zero will behave the same\\nas one"}},"description":"ActionVote represents the voting action and its required eligibility criteria."},"provenance.reward.v1.ClaimPeriodRewardDistribution":{"type":"object","properties":{"claim_period_id":{"type":"string","format":"uint64","description":"The claim period id."},"reward_program_id":{"type":"string","format":"uint64","description":"The id of the reward program that this reward belongs to."},"total_rewards_pool_for_claim_period":{"description":"The sum of all the granted rewards for this claim period.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"rewards_pool":{"description":"The final allocated rewards for this claim period.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"total_shares":{"type":"string","format":"int64","description":"The total number of granted shares for this claim period."},"claim_period_ended":{"type":"boolean","format":"boolean","description":"A flag representing if the claim period for this reward has ended."}},"description":"ClaimPeriodRewardDistribution, this is updated at the end of every claim period."},"provenance.reward.v1.QualifyingAction":{"type":"object","properties":{"delegate":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful delegates."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful delegates."},"minimum_delegation_amount":{"description":"Minimum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"maximum_delegation_amount":{"description":"Maximum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"minimum_active_stake_percentile":{"type":"string","description":"Minimum percentile that can be below the validator\'s power ranking."},"maximum_active_stake_percentile":{"type":"string","description":"Maximum percentile that can be below the validator\'s power ranking."}},"description":"ActionDelegate represents the delegate action and its required eligibility criteria."},"transfer":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful transfers."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful transfers."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the transfer action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}}},"description":"ActionTransfer represents the transfer action and its required eligibility criteria."},"vote":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful votes."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful votes."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the vote action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"validator_multiplier":{"type":"string","format":"uint64","title":"Positive multiplier that is applied to the shares awarded by the vote action when conditions\\nare met(for now the only condition is the current vote is a validator vote). A value of zero will behave the same\\nas one"}},"description":"ActionVote represents the voting action and its required eligibility criteria."}},"description":"QualifyingAction can be one of many action types."},"provenance.reward.v1.QueryClaimPeriodRewardDistributionsByIDResponse":{"type":"object","properties":{"claim_period_reward_distribution":{"type":"object","properties":{"claim_period_id":{"type":"string","format":"uint64","description":"The claim period id."},"reward_program_id":{"type":"string","format":"uint64","description":"The id of the reward program that this reward belongs to."},"total_rewards_pool_for_claim_period":{"description":"The sum of all the granted rewards for this claim period.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"rewards_pool":{"description":"The final allocated rewards for this claim period.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"total_shares":{"type":"string","format":"int64","description":"The total number of granted shares for this claim period."},"claim_period_ended":{"type":"boolean","format":"boolean","description":"A flag representing if the claim period for this reward has ended."}},"description":"ClaimPeriodRewardDistribution, this is updated at the end of every claim period."}},"title":"QueryClaimPeriodRewardDistributionsByIDResponse returns the requested ClaimPeriodRewardDistribution"},"provenance.reward.v1.QueryClaimPeriodRewardDistributionsResponse":{"type":"object","properties":{"claim_period_reward_distributions":{"type":"array","items":{"type":"object","properties":{"claim_period_id":{"type":"string","format":"uint64","description":"The claim period id."},"reward_program_id":{"type":"string","format":"uint64","description":"The id of the reward program that this reward belongs to."},"total_rewards_pool_for_claim_period":{"description":"The sum of all the granted rewards for this claim period.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"rewards_pool":{"description":"The final allocated rewards for this claim period.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"total_shares":{"type":"string","format":"int64","description":"The total number of granted shares for this claim period."},"claim_period_ended":{"type":"boolean","format":"boolean","description":"A flag representing if the claim period for this reward has ended."}},"description":"ClaimPeriodRewardDistribution, this is updated at the end of every claim period."},"description":"List of all ClaimPeriodRewardDistribution objects queried for."},"pagination":{"description":"pagination defines an optional pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"title":"QueryClaimPeriodRewardDistributionsResponse returns the list of paginated ClaimPeriodRewardDistributions"},"provenance.reward.v1.QueryRewardDistributionsByAddressResponse":{"type":"object","properties":{"address":{"type":"string","description":"The address that the reward account belongs to."},"reward_account_state":{"type":"array","items":{"type":"object","properties":{"reward_program_id":{"type":"string","format":"uint64","description":"The id of the reward program that this claim belongs to."},"total_reward_claim":{"description":"total rewards claimed for all eligible claim periods in program.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claim_status":{"description":"The status of the claim.","type":"string","enum":["CLAIM_STATUS_UNSPECIFIED","CLAIM_STATUS_UNCLAIMABLE","CLAIM_STATUS_CLAIMABLE","CLAIM_STATUS_CLAIMED","CLAIM_STATUS_EXPIRED"],"default":"CLAIM_STATUS_UNSPECIFIED","title":"ClaimStatus is the state a claim is in"},"claim_id":{"type":"string","format":"uint64","description":"The claim period that the claim belongs to."}},"description":"RewardAccountResponse is an address\' reward claim for a reward program\'s claim period."},"description":"List of RewardAccounts queried for."},"pagination":{"description":"pagination defines an optional pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryRewardDistributionsByAddressResponse returns the reward claims for an address that match the claim_status."},"provenance.reward.v1.QueryRewardProgramByIDResponse":{"type":"object","properties":{"reward_program":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"An integer to uniquely identify the reward program."},"title":{"type":"string","title":"Name to help identify the Reward Program.(MaxTitleLength=140)"},"description":{"type":"string","title":"Short summary describing the Reward Program.(MaxDescriptionLength=10000)"},"distribute_from_address":{"type":"string","description":"address that provides funds for the total reward pool."},"total_reward_pool":{"description":"The total amount of funding given to the RewardProgram.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"remaining_pool_balance":{"description":"The remaining funds available to distribute after n claim periods have passed.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claimed_amount":{"description":"The total amount of all funds claimed by participants for all past claim periods.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"max_reward_by_address":{"description":"Maximum reward per claim period per address.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"minimum_rollover_amount":{"description":"Minimum amount of coins for a program to rollover.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claim_period_seconds":{"type":"string","format":"uint64","description":"Number of seconds that a claim period lasts."},"program_start_time":{"type":"string","format":"date-time","description":"Time that a RewardProgram should start and switch to STARTED state."},"expected_program_end_time":{"type":"string","format":"date-time","description":"Time that a RewardProgram is expected to end, based on data when it was setup."},"program_end_time_max":{"type":"string","format":"date-time","description":"Time that a RewardProgram MUST end."},"claim_period_end_time":{"type":"string","format":"date-time","description":"Used internally to calculate and track the current claim period\'s ending time."},"actual_program_end_time":{"type":"string","format":"date-time","description":"Time the RewardProgram switched to FINISHED state. Initially set as empty."},"claim_periods":{"type":"string","format":"uint64","description":"Number of claim periods this program will run for."},"current_claim_period":{"type":"string","format":"uint64","description":"Current claim period of the RewardProgram. Uses 1-based indexing."},"max_rollover_claim_periods":{"type":"string","format":"uint64","description":"maximum number of claim periods a reward program can rollover."},"state":{"description":"Current state of the RewardProgram.","type":"string","enum":["STATE_UNSPECIFIED","STATE_PENDING","STATE_STARTED","STATE_FINISHED","STATE_EXPIRED"],"default":"STATE_UNSPECIFIED","title":"State is the state of the reward program"},"expiration_offset":{"type":"string","format":"uint64","description":"Grace period after a RewardProgram FINISHED. It is the number of seconds until a RewardProgram enters the EXPIRED\\nstate."},"qualifying_actions":{"type":"array","items":{"type":"object","properties":{"delegate":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful delegates."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful delegates."},"minimum_delegation_amount":{"description":"Minimum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"maximum_delegation_amount":{"description":"Maximum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"minimum_active_stake_percentile":{"type":"string","description":"Minimum percentile that can be below the validator\'s power ranking."},"maximum_active_stake_percentile":{"type":"string","description":"Maximum percentile that can be below the validator\'s power ranking."}},"description":"ActionDelegate represents the delegate action and its required eligibility criteria."},"transfer":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful transfers."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful transfers."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the transfer action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}}},"description":"ActionTransfer represents the transfer action and its required eligibility criteria."},"vote":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful votes."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful votes."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the vote action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"validator_multiplier":{"type":"string","format":"uint64","title":"Positive multiplier that is applied to the shares awarded by the vote action when conditions\\nare met(for now the only condition is the current vote is a validator vote). A value of zero will behave the same\\nas one"}},"description":"ActionVote represents the voting action and its required eligibility criteria."}},"description":"QualifyingAction can be one of many action types."},"description":"Actions that count towards the reward."}},"title":"RewardProgram","description":"The reward program object that was queried for."}},"title":"QueryRewardProgramByIDResponse contains the requested RewardProgram"},"provenance.reward.v1.QueryRewardProgramsRequest.QueryType":{"type":"string","enum":["QUERY_TYPE_UNSPECIFIED","QUERY_TYPE_ALL","QUERY_TYPE_PENDING","QUERY_TYPE_ACTIVE","QUERY_TYPE_OUTSTANDING","QUERY_TYPE_FINISHED"],"default":"QUERY_TYPE_UNSPECIFIED","description":"- QUERY_TYPE_UNSPECIFIED: unspecified type\\n - QUERY_TYPE_ALL: all reward programs states\\n - QUERY_TYPE_PENDING: pending reward program state=\\n - QUERY_TYPE_ACTIVE: active reward program state\\n - QUERY_TYPE_OUTSTANDING: pending and active reward program states\\n - QUERY_TYPE_FINISHED: finished reward program state","title":"QueryType is the state of reward program to query"},"provenance.reward.v1.QueryRewardProgramsResponse":{"type":"object","properties":{"reward_programs":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"An integer to uniquely identify the reward program."},"title":{"type":"string","title":"Name to help identify the Reward Program.(MaxTitleLength=140)"},"description":{"type":"string","title":"Short summary describing the Reward Program.(MaxDescriptionLength=10000)"},"distribute_from_address":{"type":"string","description":"address that provides funds for the total reward pool."},"total_reward_pool":{"description":"The total amount of funding given to the RewardProgram.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"remaining_pool_balance":{"description":"The remaining funds available to distribute after n claim periods have passed.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claimed_amount":{"description":"The total amount of all funds claimed by participants for all past claim periods.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"max_reward_by_address":{"description":"Maximum reward per claim period per address.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"minimum_rollover_amount":{"description":"Minimum amount of coins for a program to rollover.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claim_period_seconds":{"type":"string","format":"uint64","description":"Number of seconds that a claim period lasts."},"program_start_time":{"type":"string","format":"date-time","description":"Time that a RewardProgram should start and switch to STARTED state."},"expected_program_end_time":{"type":"string","format":"date-time","description":"Time that a RewardProgram is expected to end, based on data when it was setup."},"program_end_time_max":{"type":"string","format":"date-time","description":"Time that a RewardProgram MUST end."},"claim_period_end_time":{"type":"string","format":"date-time","description":"Used internally to calculate and track the current claim period\'s ending time."},"actual_program_end_time":{"type":"string","format":"date-time","description":"Time the RewardProgram switched to FINISHED state. Initially set as empty."},"claim_periods":{"type":"string","format":"uint64","description":"Number of claim periods this program will run for."},"current_claim_period":{"type":"string","format":"uint64","description":"Current claim period of the RewardProgram. Uses 1-based indexing."},"max_rollover_claim_periods":{"type":"string","format":"uint64","description":"maximum number of claim periods a reward program can rollover."},"state":{"description":"Current state of the RewardProgram.","type":"string","enum":["STATE_UNSPECIFIED","STATE_PENDING","STATE_STARTED","STATE_FINISHED","STATE_EXPIRED"],"default":"STATE_UNSPECIFIED","title":"State is the state of the reward program"},"expiration_offset":{"type":"string","format":"uint64","description":"Grace period after a RewardProgram FINISHED. It is the number of seconds until a RewardProgram enters the EXPIRED\\nstate."},"qualifying_actions":{"type":"array","items":{"type":"object","properties":{"delegate":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful delegates."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful delegates."},"minimum_delegation_amount":{"description":"Minimum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"maximum_delegation_amount":{"description":"Maximum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"minimum_active_stake_percentile":{"type":"string","description":"Minimum percentile that can be below the validator\'s power ranking."},"maximum_active_stake_percentile":{"type":"string","description":"Maximum percentile that can be below the validator\'s power ranking."}},"description":"ActionDelegate represents the delegate action and its required eligibility criteria."},"transfer":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful transfers."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful transfers."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the transfer action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}}},"description":"ActionTransfer represents the transfer action and its required eligibility criteria."},"vote":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful votes."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful votes."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the vote action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"validator_multiplier":{"type":"string","format":"uint64","title":"Positive multiplier that is applied to the shares awarded by the vote action when conditions\\nare met(for now the only condition is the current vote is a validator vote). A value of zero will behave the same\\nas one"}},"description":"ActionVote represents the voting action and its required eligibility criteria."}},"description":"QualifyingAction can be one of many action types."},"description":"Actions that count towards the reward."}},"title":"RewardProgram"},"description":"List of RewardProgram objects matching the query_type."},"pagination":{"description":"pagination defines an optional pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"title":"QueryRewardProgramsResponse contains the list of RewardPrograms matching the query"},"provenance.reward.v1.RewardAccountResponse":{"type":"object","properties":{"reward_program_id":{"type":"string","format":"uint64","description":"The id of the reward program that this claim belongs to."},"total_reward_claim":{"description":"total rewards claimed for all eligible claim periods in program.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claim_status":{"description":"The status of the claim.","type":"string","enum":["CLAIM_STATUS_UNSPECIFIED","CLAIM_STATUS_UNCLAIMABLE","CLAIM_STATUS_CLAIMABLE","CLAIM_STATUS_CLAIMED","CLAIM_STATUS_EXPIRED"],"default":"CLAIM_STATUS_UNSPECIFIED","title":"ClaimStatus is the state a claim is in"},"claim_id":{"type":"string","format":"uint64","description":"The claim period that the claim belongs to."}},"description":"RewardAccountResponse is an address\' reward claim for a reward program\'s claim period."},"provenance.reward.v1.RewardAccountState.ClaimStatus":{"type":"string","enum":["CLAIM_STATUS_UNSPECIFIED","CLAIM_STATUS_UNCLAIMABLE","CLAIM_STATUS_CLAIMABLE","CLAIM_STATUS_CLAIMED","CLAIM_STATUS_EXPIRED"],"default":"CLAIM_STATUS_UNSPECIFIED","description":"- CLAIM_STATUS_UNSPECIFIED: undefined state\\n - CLAIM_STATUS_UNCLAIMABLE: unclaimable status\\n - CLAIM_STATUS_CLAIMABLE: unclaimable claimable\\n - CLAIM_STATUS_CLAIMED: unclaimable claimed\\n - CLAIM_STATUS_EXPIRED: unclaimable expired","title":"ClaimStatus is the state a claim is in"},"provenance.reward.v1.RewardProgram":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"An integer to uniquely identify the reward program."},"title":{"type":"string","title":"Name to help identify the Reward Program.(MaxTitleLength=140)"},"description":{"type":"string","title":"Short summary describing the Reward Program.(MaxDescriptionLength=10000)"},"distribute_from_address":{"type":"string","description":"address that provides funds for the total reward pool."},"total_reward_pool":{"description":"The total amount of funding given to the RewardProgram.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"remaining_pool_balance":{"description":"The remaining funds available to distribute after n claim periods have passed.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claimed_amount":{"description":"The total amount of all funds claimed by participants for all past claim periods.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"max_reward_by_address":{"description":"Maximum reward per claim period per address.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"minimum_rollover_amount":{"description":"Minimum amount of coins for a program to rollover.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"claim_period_seconds":{"type":"string","format":"uint64","description":"Number of seconds that a claim period lasts."},"program_start_time":{"type":"string","format":"date-time","description":"Time that a RewardProgram should start and switch to STARTED state."},"expected_program_end_time":{"type":"string","format":"date-time","description":"Time that a RewardProgram is expected to end, based on data when it was setup."},"program_end_time_max":{"type":"string","format":"date-time","description":"Time that a RewardProgram MUST end."},"claim_period_end_time":{"type":"string","format":"date-time","description":"Used internally to calculate and track the current claim period\'s ending time."},"actual_program_end_time":{"type":"string","format":"date-time","description":"Time the RewardProgram switched to FINISHED state. Initially set as empty."},"claim_periods":{"type":"string","format":"uint64","description":"Number of claim periods this program will run for."},"current_claim_period":{"type":"string","format":"uint64","description":"Current claim period of the RewardProgram. Uses 1-based indexing."},"max_rollover_claim_periods":{"type":"string","format":"uint64","description":"maximum number of claim periods a reward program can rollover."},"state":{"description":"Current state of the RewardProgram.","type":"string","enum":["STATE_UNSPECIFIED","STATE_PENDING","STATE_STARTED","STATE_FINISHED","STATE_EXPIRED"],"default":"STATE_UNSPECIFIED","title":"State is the state of the reward program"},"expiration_offset":{"type":"string","format":"uint64","description":"Grace period after a RewardProgram FINISHED. It is the number of seconds until a RewardProgram enters the EXPIRED\\nstate."},"qualifying_actions":{"type":"array","items":{"type":"object","properties":{"delegate":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful delegates."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful delegates."},"minimum_delegation_amount":{"description":"Minimum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"maximum_delegation_amount":{"description":"Maximum amount that the user must have currently delegated on the validator.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"minimum_active_stake_percentile":{"type":"string","description":"Minimum percentile that can be below the validator\'s power ranking."},"maximum_active_stake_percentile":{"type":"string","description":"Maximum percentile that can be below the validator\'s power ranking."}},"description":"ActionDelegate represents the delegate action and its required eligibility criteria."},"transfer":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful transfers."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful transfers."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the transfer action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}}},"description":"ActionTransfer represents the transfer action and its required eligibility criteria."},"vote":{"type":"object","properties":{"minimum_actions":{"type":"string","format":"uint64","description":"Minimum number of successful votes."},"maximum_actions":{"type":"string","format":"uint64","description":"Maximum number of successful votes."},"minimum_delegation_amount":{"description":"Minimum delegation amount the account must have across all validators, for the vote action to be counted.","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}}},"validator_multiplier":{"type":"string","format":"uint64","title":"Positive multiplier that is applied to the shares awarded by the vote action when conditions\\nare met(for now the only condition is the current vote is a validator vote). A value of zero will behave the same\\nas one"}},"description":"ActionVote represents the voting action and its required eligibility criteria."}},"description":"QualifyingAction can be one of many action types."},"description":"Actions that count towards the reward."}},"title":"RewardProgram"},"provenance.reward.v1.RewardProgram.State":{"type":"string","enum":["STATE_UNSPECIFIED","STATE_PENDING","STATE_STARTED","STATE_FINISHED","STATE_EXPIRED"],"default":"STATE_UNSPECIFIED","description":"- STATE_UNSPECIFIED: undefined program state\\n - STATE_PENDING: pending state of reward program\\n - STATE_STARTED: started state of reward program\\n - STATE_FINISHED: finished state of reward program\\n - STATE_EXPIRED: expired state of reward program","title":"State is the state of the reward program"},"provenance.reward.v1.ClaimedRewardPeriodDetail":{"type":"object","properties":{"claim_period_id":{"type":"string","format":"uint64","title":"claim period id"},"total_shares":{"type":"string","format":"uint64","title":"total shares accumulated for claim period"},"claim_period_reward":{"title":"total rewards for claim period","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"ClaimedRewardPeriodDetail is information regarding an addresses\' shares and reward for a claim period."},"provenance.reward.v1.MsgClaimAllRewardsResponse":{"type":"object","properties":{"total_reward_claim":{"type":"array","items":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"description":"total rewards claimed for all eligible claim periods in all programs."},"claim_details":{"type":"array","items":{"type":"object","properties":{"reward_program_id":{"type":"string","format":"uint64","description":"reward program id."},"total_reward_claim":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"claimed_reward_period_details":{"type":"array","items":{"type":"object","properties":{"claim_period_id":{"type":"string","format":"uint64","title":"claim period id"},"total_shares":{"type":"string","format":"uint64","title":"total shares accumulated for claim period"},"claim_period_reward":{"title":"total rewards for claim period","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"ClaimedRewardPeriodDetail is information regarding an addresses\' shares and reward for a claim period."},"description":"claim period details."}},"description":"RewardProgramClaimDetail is the response object regarding an address\'s shares and reward for a reward program."},"description":"details about acquired rewards from a reward program."}},"title":"MsgClaimRewardsResponse is the response type for claiming rewards from all reward programs RPC"},"provenance.reward.v1.MsgClaimRewardsResponse":{"type":"object","properties":{"claim_details":{"type":"object","properties":{"reward_program_id":{"type":"string","format":"uint64","description":"reward program id."},"total_reward_claim":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"claimed_reward_period_details":{"type":"array","items":{"type":"object","properties":{"claim_period_id":{"type":"string","format":"uint64","title":"claim period id"},"total_shares":{"type":"string","format":"uint64","title":"total shares accumulated for claim period"},"claim_period_reward":{"title":"total rewards for claim period","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"ClaimedRewardPeriodDetail is information regarding an addresses\' shares and reward for a claim period."},"description":"claim period details."}},"description":"RewardProgramClaimDetail is the response object regarding an address\'s shares and reward for a reward program."}},"title":"MsgClaimRewardsResponse is the response type for claiming reward from reward program RPC"},"provenance.reward.v1.MsgCreateRewardProgramResponse":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"reward program id that is generated on creation."}},"title":"MsgCreateRewardProgramResponse is the response type for creating a reward program RPC"},"provenance.reward.v1.MsgEndRewardProgramResponse":{"type":"object","title":"MsgEndRewardProgramResponse is the response type for ending a reward program RPC"},"provenance.reward.v1.RewardProgramClaimDetail":{"type":"object","properties":{"reward_program_id":{"type":"string","format":"uint64","description":"reward program id."},"total_reward_claim":{"type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."},"claimed_reward_period_details":{"type":"array","items":{"type":"object","properties":{"claim_period_id":{"type":"string","format":"uint64","title":"claim period id"},"total_shares":{"type":"string","format":"uint64","title":"total shares accumulated for claim period"},"claim_period_reward":{"title":"total rewards for claim period","type":"object","properties":{"denom":{"type":"string"},"amount":{"type":"string"}},"description":"Coin defines a token with a denomination and an amount.\\n\\nNOTE: The amount field is an Int which implements the custom method\\nsignatures required by gogoproto."}},"description":"ClaimedRewardPeriodDetail is information regarding an addresses\' shares and reward for a claim period."},"description":"claim period details."}},"description":"RewardProgramClaimDetail is the response object regarding an address\'s shares and reward for a reward program."},"provenance.trigger.v1.QueryTriggerByIDResponse":{"type":"object","properties":{"trigger":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"An integer to uniquely identify the trigger."},"owner":{"type":"string","description":"The owner of the trigger."},"event":{"description":"The event that must be detected for the trigger to fire.","type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}}},"actions":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"The messages to run when the trigger fires."}},"title":"Trigger","description":"The trigger object that was queried for."}},"description":"QueryTriggerByIDResponse contains the requested Trigger."},"provenance.trigger.v1.QueryTriggersResponse":{"type":"object","properties":{"triggers":{"type":"array","items":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"An integer to uniquely identify the trigger."},"owner":{"type":"string","description":"The owner of the trigger."},"event":{"description":"The event that must be detected for the trigger to fire.","type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}}},"actions":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"The messages to run when the trigger fires."}},"title":"Trigger"},"description":"List of Trigger objects."},"pagination":{"description":"pagination defines an optional pagination for the response.","type":"object","properties":{"next_key":{"type":"string","format":"byte","description":"next_key is the key to be passed to PageRequest.key to\\nquery the next page most efficiently. It will be empty if\\nthere are no more results."},"total":{"type":"string","format":"uint64","title":"total is total number of results available if PageRequest.count_total\\nwas set, its value is undefined otherwise"}}}},"description":"QueryTriggersResponse contains the list of Triggers."},"provenance.trigger.v1.Trigger":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"An integer to uniquely identify the trigger."},"owner":{"type":"string","description":"The owner of the trigger."},"event":{"description":"The event that must be detected for the trigger to fire.","type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}}},"actions":{"type":"array","items":{"type":"object","properties":{"type_url":{"type":"string","description":"A URL/resource name that uniquely identifies the type of the serialized\\nprotocol buffer message. This string must contain at least\\none \\"/\\" character. The last segment of the URL\'s path must represent\\nthe fully qualified name of the type (as in\\n`path/google.protobuf.Duration`). The name should be in a canonical form\\n(e.g., leading \\".\\" is not accepted).\\n\\nIn practice, teams usually precompile into the binary all types that they\\nexpect it to use in the context of Any. However, for URLs which use the\\nscheme `http`, `https`, or no scheme, one can optionally set up a type\\nserver that maps type URLs to message definitions as follows:\\n\\n* If no scheme is provided, `https` is assumed.\\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\\n  value in binary format, or produce an error.\\n* Applications are allowed to cache lookup results based on the\\n  URL, or have them precompiled into a binary to avoid any\\n  lookup. Therefore, binary compatibility needs to be preserved\\n  on changes to types. (Use versioned type names to manage\\n  breaking changes.)\\n\\nNote: this functionality is not currently available in the official\\nprotobuf release, and it is not used for type URLs beginning with\\ntype.googleapis.com.\\n\\nSchemes other than `http`, `https` (or the empty scheme) might be\\nused with implementation specific semantics."},"value":{"type":"string","format":"byte","description":"Must be a valid serialized protocol buffer of the above specified type."}},"description":"`Any` contains an arbitrary serialized protocol buffer message along with a\\nURL that describes the type of the serialized message.\\n\\nProtobuf library provides support to pack/unpack Any values in the form\\nof utility functions or additional generated methods of the Any type.\\n\\nExample 1: Pack and unpack a message in C++.\\n\\n    Foo foo = ...;\\n    Any any;\\n    any.PackFrom(foo);\\n    ...\\n    if (any.UnpackTo(&foo)) {\\n      ...\\n    }\\n\\nExample 2: Pack and unpack a message in Java.\\n\\n    Foo foo = ...;\\n    Any any = Any.pack(foo);\\n    ...\\n    if (any.is(Foo.class)) {\\n      foo = any.unpack(Foo.class);\\n    }\\n\\n Example 3: Pack and unpack a message in Python.\\n\\n    foo = Foo(...)\\n    any = Any()\\n    any.Pack(foo)\\n    ...\\n    if any.Is(Foo.DESCRIPTOR):\\n      any.Unpack(foo)\\n      ...\\n\\n Example 4: Pack and unpack a message in Go\\n\\n     foo := &pb.Foo{...}\\n     any, err := ptypes.MarshalAny(foo)\\n     ...\\n     foo := &pb.Foo{}\\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\\n       ...\\n     }\\n\\nThe pack methods provided by protobuf library will by default use\\n\'type.googleapis.com/full.type.name\' as the type URL and the unpack\\nmethods only use the fully qualified type name after the last \'/\'\\nin the type URL, for example \\"foo.bar.com/x/y.z\\" will yield type\\nname \\"y.z\\".\\n\\n\\nJSON\\n====\\nThe JSON representation of an `Any` value uses the regular\\nrepresentation of the deserialized, embedded message, with an\\nadditional field `@type` which contains the type URL. Example:\\n\\n    package google.profile;\\n    message Person {\\n      string first_name = 1;\\n      string last_name = 2;\\n    }\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.profile.Person\\",\\n      \\"firstName\\": <string>,\\n      \\"lastName\\": <string>\\n    }\\n\\nIf the embedded message type is well-known and has a custom JSON\\nrepresentation, that representation will be embedded adding a field\\n`value` which holds the custom JSON in addition to the `@type`\\nfield. Example (for message [google.protobuf.Duration][]):\\n\\n    {\\n      \\"@type\\": \\"type.googleapis.com/google.protobuf.Duration\\",\\n      \\"value\\": \\"1.212s\\"\\n    }"},"description":"The messages to run when the trigger fires."}},"title":"Trigger"},"provenance.trigger.v1.MsgCreateTriggerResponse":{"type":"object","properties":{"id":{"type":"string","format":"uint64","description":"trigger id that is generated on creation."}},"title":"MsgCreateTriggerResponse is the response type for creating a trigger RPC"},"provenance.trigger.v1.MsgDestroyTriggerResponse":{"type":"object","title":"MsgDestroyTriggerResponse is the response type for creating a trigger RPC"}}}}}},"docusaurus-theme-redoc":{"theme-redoc":{"lightTheme":{"typography":{"fontFamily":"var(--ifm-font-family-base)","fontSize":"var(--ifm-font-size-base)","lineHeight":"var(--ifm-line-height-base)","fontWeightLight":"var(--ifm-font-weight-light)","fontWeightRegular":"var(--ifm-font-weight-base)","fontWeightBold":"var(--ifm-font-weight-bold)","headings":{"fontFamily":"var(--ifm-heading-font-family)","fontWeight":"var(--ifm-heading-font-weight)","lineHeight":"var(--ifm-heading-line-height)"},"code":{"fontFamily":"var(--ifm-font-family-monospace)","lineHeight":"var(--ifm-pre-line-height)"}},"sidebar":{"width":"300px","backgroundColor":"#ffffff"},"rightPanel":{"backgroundColor":"#303846"},"colors":{"primary":{"main":"#18367C"}},"theme":{"prism":{"additionalLanguages":["scala"]}}},"darkTheme":{"typography":{"fontFamily":"var(--ifm-font-family-base)","fontSize":"var(--ifm-font-size-base)","lineHeight":"var(--ifm-line-height-base)","fontWeightLight":"var(--ifm-font-weight-light)","fontWeightRegular":"var(--ifm-font-weight-base)","fontWeightBold":"var(--ifm-font-weight-bold)","headings":{"fontFamily":"var(--ifm-heading-font-family)","fontWeight":"var(--ifm-heading-font-weight)","lineHeight":"var(--ifm-heading-line-height)"},"code":{"fontFamily":"var(--ifm-font-family-monospace)","lineHeight":"var(--ifm-pre-line-height)"}},"sidebar":{"width":"300px","backgroundColor":"rgb(24, 25, 26)","textColor":"#f5f6f7","arrow":{"color":"#f5f6f7"}},"colors":{"text":{"primary":"#f5f6f7","secondary":"rgba(255, 255, 255, 1)"},"gray":{"50":"#FAFAFA","100":"#F5F5F5"},"border":{"dark":"#ffffff","light":"rgba(0,0,0, 0.1)"},"primary":{"main":"#18367C"}},"schema":{"nestedBackground":"rgb(24, 25, 26)","typeNameColor":"rgba(255, 255, 255, 1)","typeTitleColor":"rgba(255, 255, 255, 1)"},"theme":{"prism":{"additionalLanguages":["scala"]}}},"options":{"scrollYOffset":"nav.navbar","expandSingleSchemaField":true,"menuToggle":true,"suppressWarnings":true}}},"docusaurus-plugin-google-gtag":{"default":{"trackingID":["G-J8X4N657D9"],"anonymizeIP":true,"id":"default"}},"docusaurus-plugin-content-docs":{"default":{"path":"/docs","versions":[{"name":"current","label":"Next","isLast":true,"path":"/docs","mainDocId":"index","docs":[{"id":"build/clients","path":"/docs/build/clients","sidebar":"buildSidebar"},{"id":"build/dev-environment","path":"/docs/build/dev-environment","sidebar":"buildSidebar"},{"id":"build/libraries","path":"/docs/build/libraries","sidebar":"buildSidebar"},{"id":"discover/dapps","path":"/docs/discover/dapps"},{"id":"discover/explorer","path":"/docs/discover/explorer"},{"id":"discover/explorer/explorer-as-a-service/index","path":"/docs/discover/explorer/explorer-as-a-service/"},{"id":"discover/explorer/explorer-as-a-service/ingestion","path":"/docs/discover/explorer/explorer-as-a-service/ingestion"},{"id":"discover/explorer/index","path":"/docs/discover/explorer/"},{"id":"discover/explorer/ui-walkthrough/account-address","path":"/docs/discover/explorer/ui-walkthrough/account-address"},{"id":"discover/explorer/ui-walkthrough/assets","path":"/docs/discover/explorer/ui-walkthrough/assets"},{"id":"discover/explorer/ui-walkthrough/dashboard/blocks","path":"/docs/discover/explorer/ui-walkthrough/dashboard/blocks"},{"id":"discover/explorer/ui-walkthrough/dashboard/index","path":"/docs/discover/explorer/ui-walkthrough/dashboard/"},{"id":"discover/explorer/ui-walkthrough/forthcoming/blockchain-statistics","path":"/docs/discover/explorer/ui-walkthrough/forthcoming/blockchain-statistics"},{"id":"discover/explorer/ui-walkthrough/forthcoming/ibc","path":"/docs/discover/explorer/ui-walkthrough/forthcoming/ibc"},{"id":"discover/explorer/ui-walkthrough/governance","path":"/docs/discover/explorer/ui-walkthrough/governance"},{"id":"discover/explorer/ui-walkthrough/staking-validators/index","path":"/docs/discover/explorer/ui-walkthrough/staking-validators/"},{"id":"discover/explorer/ui-walkthrough/staking-validators/validator-details","path":"/docs/discover/explorer/ui-walkthrough/staking-validators/validator-details"},{"id":"discover/explorer/ui-walkthrough/transactions","path":"/docs/discover/explorer/ui-walkthrough/transactions"},{"id":"discover/explorer/ui-walkthrough/walkthru","path":"/docs/discover/explorer/ui-walkthrough/walkthru"},{"id":"discover/hash","path":"/docs/discover/hash"},{"id":"discover/money","path":"/docs/discover/money"},{"id":"discover/ramps","path":"/docs/discover/ramps"},{"id":"discover/resources","path":"/docs/discover/resources"},{"id":"discover/smart-contract-catalog","path":"/docs/discover/smart-contract-catalog"},{"id":"discover/solutions","path":"/docs/discover/solutions"},{"id":"discover/staking","path":"/docs/discover/staking"},{"id":"discover/usdf","path":"/docs/discover/usdf"},{"id":"discover/wallets","path":"/docs/discover/wallets"},{"id":"index","path":"/docs/","sidebar":"documentationSidebar"},{"id":"learn/about-provenance/foundation","path":"/docs/learn/about-provenance/foundation"},{"id":"learn/about-provenance/index","path":"/docs/learn/about-provenance/"},{"id":"learn/asset-lifecycle/asset-lifecycle","path":"/docs/learn/asset-lifecycle/"},{"id":"learn/asset-lifecycle/assets-overview","path":"/docs/learn/asset-lifecycle/assets-overview","sidebar":"assetLifecycleSidebar"},{"id":"learn/asset-lifecycle/capital-raise-example","path":"/docs/learn/asset-lifecycle/capital-raise-example","sidebar":"assetLifecycleSidebar"},{"id":"learn/asset-lifecycle/issue","path":"/docs/learn/asset-lifecycle/issue"},{"id":"learn/asset-lifecycle/lending-example","path":"/docs/learn/asset-lifecycle/lending-example","sidebar":"assetLifecycleSidebar"},{"id":"learn/asset-lifecycle/manage","path":"/docs/learn/asset-lifecycle/manage"},{"id":"learn/asset-lifecycle/markers","path":"/docs/learn/asset-lifecycle/markers","sidebar":"assetLifecycleSidebar"},{"id":"learn/asset-lifecycle/nfts","path":"/docs/learn/asset-lifecycle/nfts","sidebar":"assetLifecycleSidebar"},{"id":"learn/asset-lifecycle/trade","path":"/docs/learn/asset-lifecycle/trade"},{"id":"learn/dapps/blockchain-communication","path":"/docs/learn/dapps/blockchain-communication"},{"id":"learn/dapps/dapp-architecture","path":"/docs/learn/dapps/dapp-architecture"},{"id":"learn/dapps/dapps-overview","path":"/docs/learn/dapps/dapps-overview","sidebar":"dappsSidebar"},{"id":"learn/dapps/data-privacy","path":"/docs/learn/dapps/data-privacy"},{"id":"learn/dapps/fiat-ramps","path":"/docs/learn/dapps/fiat-ramps"},{"id":"learn/dapps/identity-verification","path":"/docs/learn/dapps/identity-verification","sidebar":"dappsSidebar"},{"id":"learn/dapps/identity-verification/attribute-names","path":"/docs/learn/dapps/identity-verification/attribute-names","sidebar":"dappsSidebar"},{"id":"learn/dapps/identity-verification/attribute-values","path":"/docs/learn/dapps/identity-verification/attribute-values","sidebar":"dappsSidebar"},{"id":"learn/dapps/identity-verification/flow","path":"/docs/learn/dapps/identity-verification/flow","sidebar":"dappsSidebar"},{"id":"learn/dapps/identity-verification/identity-attribute-tutorial","path":"/docs/learn/dapps/identity-verification/identity-attribute-tutorial"},{"id":"learn/dapps/identity-verification/identity-nfts","path":"/docs/learn/dapps/identity-verification/identity-nfts","sidebar":"dappsSidebar"},{"id":"learn/dapps/organization-management","path":"/docs/learn/dapps/organization-management"},{"id":"learn/dapps/ui-ux","path":"/docs/learn/dapps/ui-ux"},{"id":"learn/learn-about","path":"/docs/learn/learn-about"},{"id":"learn/provenance-applications/apps-powered-by-provenance","path":"/docs/learn/provenance-applications/apps-powered-by-provenance"},{"id":"learn/provenance-applications/loan-origination-system-los/assets","path":"/docs/learn/provenance-applications/loan-origination-system-los/assets"},{"id":"learn/provenance-applications/loan-origination-system-los/data-sharing-with-portfolio-manager","path":"/docs/learn/provenance-applications/loan-origination-system-los/data-sharing-with-portfolio-manager"},{"id":"learn/provenance-applications/loan-origination-system-los/funding","path":"/docs/learn/provenance-applications/loan-origination-system-los/funding"},{"id":"learn/provenance-applications/loan-origination-system-los/index","path":"/docs/learn/provenance-applications/loan-origination-system-los/"},{"id":"learn/provenance-applications/loan-origination-system-los/loan-servicing","path":"/docs/learn/provenance-applications/loan-origination-system-los/loan-servicing"},{"id":"learn/provenance-applications/loan-origination-system-los/loan-validation/3rd-party-digital-signatures","path":"/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/3rd-party-digital-signatures"},{"id":"learn/provenance-applications/loan-origination-system-los/loan-validation/index","path":"/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/"},{"id":"learn/provenance-applications/loan-origination-system-los/loan-validation/loan-servicing","path":"/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/loan-servicing"},{"id":"learn/provenance-applications/loan-origination-system-los/onboarding-contract","path":"/docs/learn/provenance-applications/loan-origination-system-los/onboarding-contract"},{"id":"learn/provenance-applications/omnibus","path":"/docs/learn/provenance-applications/omnibus"},{"id":"learn/whitepapers/blockchain-impact-on-credit-ratings","path":"/docs/learn/whitepapers/blockchain-impact-on-credit-ratings"},{"id":"learn/whitepapers/investment-fund-services-on-provenance","path":"/docs/learn/whitepapers/investment-fund-services-on-provenance"},{"id":"learn/whitepapers/loan-participation-on-provenance","path":"/docs/learn/whitepapers/loan-participation-on-provenance"},{"id":"learn/whitepapers/securitization-on-provenance","path":"/docs/learn/whitepapers/securitization-on-provenance"},{"id":"learn/whitepapers/supply-chain-finance-on-provenance","path":"/docs/learn/whitepapers/supply-chain-finance-on-provenance"},{"id":"learn/why-cosmos","path":"/docs/learn/why-cosmos"},{"id":"pb/blockchain/basics/accounts","path":"/docs/pb/blockchain/basics/accounts","sidebar":"documentationSidebar"},{"id":"pb/blockchain/basics/anatomy-of-a-provenance-application","path":"/docs/pb/blockchain/basics/anatomy-of-a-provenance-application","sidebar":"documentationSidebar"},{"id":"pb/blockchain/basics/gas-and-fees","path":"/docs/pb/blockchain/basics/gas-and-fees","sidebar":"documentationSidebar"},{"id":"pb/blockchain/basics/query-lifecycle","path":"/docs/pb/blockchain/basics/query-lifecycle","sidebar":"documentationSidebar"},{"id":"pb/blockchain/basics/stablecoin","path":"/docs/pb/blockchain/basics/stablecoin","sidebar":"documentationSidebar"},{"id":"pb/blockchain/basics/transaction-lifecycle","path":"/docs/pb/blockchain/basics/transaction-lifecycle","sidebar":"documentationSidebar"},{"id":"pb/blockchain/introduction/application-architecture","path":"/docs/pb/blockchain/introduction/application-architecture","sidebar":"documentationSidebar"},{"id":"pb/blockchain/introduction/index","path":"/docs/pb/blockchain/introduction/","sidebar":"documentationSidebar"},{"id":"pb/blockchain/introduction/major-components","path":"/docs/pb/blockchain/introduction/major-components","sidebar":"documentationSidebar"},{"id":"pb/blockchain/running-a-node/index","path":"/docs/pb/blockchain/running-a-node/","sidebar":"documentationSidebar"},{"id":"pb/blockchain/running-a-node/running-a-node-1/become-a-validator","path":"/docs/pb/blockchain/running-a-node/running-a-node-1/become-a-validator","sidebar":"documentationSidebar"},{"id":"pb/blockchain/running-a-node/running-a-node-1/configure-a-sentry","path":"/docs/pb/blockchain/running-a-node/running-a-node-1/configure-a-sentry","sidebar":"documentationSidebar"},{"id":"pb/blockchain/running-a-node/running-a-node-1/index","path":"/docs/pb/blockchain/running-a-node/running-a-node-1/","sidebar":"documentationSidebar"},{"id":"pb/blockchain/running-a-node/running-a-node-1/join-provenance-testnet/index","path":"/docs/pb/blockchain/running-a-node/running-a-node-1/join-provenance-testnet/","sidebar":"documentationSidebar"},{"id":"pb/blockchain/running-a-node/running-a-node-1/join-provenance-testnet/running-a-testnet-node-from-quicksync","path":"/docs/pb/blockchain/running-a-node/running-a-node-1/join-provenance-testnet/running-a-testnet-node-from-quicksync","sidebar":"documentationSidebar"},{"id":"pb/blockchain/running-a-node/running-a-node-1/running-a-mainnet-node","path":"/docs/pb/blockchain/running-a-node/running-a-node-1/running-a-mainnet-node","sidebar":"documentationSidebar"},{"id":"pb/blockchain/using-provenance/index","path":"/docs/pb/blockchain/using-provenance/","sidebar":"documentationSidebar"},{"id":"pb/blockchain/using-provenance/query-command","path":"/docs/pb/blockchain/using-provenance/query-command","sidebar":"documentationSidebar"},{"id":"pb/blockchain/using-provenance/tx-command","path":"/docs/pb/blockchain/using-provenance/tx-command","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/administration","path":"/docs/pb/contributing/adr/administration","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/base-infrastructure/account-metadata","path":"/docs/pb/contributing/adr/base-infrastructure/account-metadata","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/base-infrastructure/index","path":"/docs/pb/contributing/adr/base-infrastructure/","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/base-infrastructure/name-service","path":"/docs/pb/contributing/adr/base-infrastructure/name-service","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/blockchain-configuration-and-concepts/genesis-network-configuration","path":"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/genesis-network-configuration","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/blockchain-configuration-and-concepts/hd-wallets-key-pairs-addresses","path":"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/hd-wallets-key-pairs-addresses","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/blockchain-configuration-and-concepts/index","path":"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/blockchain-configuration-and-concepts/markers-tokens-and-coins","path":"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/markers-tokens-and-coins","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/blockchain-configuration-and-concepts/transaction-fees-and-gas","path":"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/transaction-fees-and-gas","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/business-applications","path":"/docs/pb/contributing/adr/business-applications","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/core-concepts/hash","path":"/docs/pb/contributing/adr/core-concepts/hash","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/core-concepts/identity","path":"/docs/pb/contributing/adr/core-concepts/identity","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/core-concepts/index","path":"/docs/pb/contributing/adr/core-concepts/","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/governance","path":"/docs/pb/contributing/adr/governance","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/index","path":"/docs/pb/contributing/adr/","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/smart-contracts/index","path":"/docs/pb/contributing/adr/smart-contracts/","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/smart-contracts/omnibus","path":"/docs/pb/contributing/adr/smart-contracts/omnibus","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/smart-contracts/p8e-metadata","path":"/docs/pb/contributing/adr/smart-contracts/p8e-metadata","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/smart-contracts/p8e-smart-contracts","path":"/docs/pb/contributing/adr/smart-contracts/p8e-smart-contracts","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/smart-contracts/p8e-specifications","path":"/docs/pb/contributing/adr/smart-contracts/p8e-specifications","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/smart-contracts/smart-contracts-1","path":"/docs/pb/contributing/adr/smart-contracts/smart-contracts-1","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/smart-contracts/upgrading","path":"/docs/pb/contributing/adr/smart-contracts/upgrading","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/system-migration","path":"/docs/pb/contributing/adr/system-migration","sidebar":"documentationSidebar"},{"id":"pb/contributing/adr/template","path":"/docs/pb/contributing/adr/template","sidebar":"documentationSidebar"},{"id":"pb/ecosystem/community/asset-originators","path":"/docs/pb/ecosystem/community/asset-originators","sidebar":"documentationSidebar"},{"id":"pb/ecosystem/community/delegator","path":"/docs/pb/ecosystem/community/delegator","sidebar":"documentationSidebar"},{"id":"pb/ecosystem/community/validator","path":"/docs/pb/ecosystem/community/validator","sidebar":"documentationSidebar"},{"id":"pb/ecosystem/financial-services-blockchain/distribution","path":"/docs/pb/ecosystem/financial-services-blockchain/distribution","sidebar":"documentationSidebar"},{"id":"pb/ecosystem/financial-services-blockchain/index","path":"/docs/pb/ecosystem/financial-services-blockchain/","sidebar":"documentationSidebar"},{"id":"pb/ecosystem/financial-services-blockchain/token-economics","path":"/docs/pb/ecosystem/financial-services-blockchain/token-economics"},{"id":"pb/ecosystem/governance/index","path":"/docs/pb/ecosystem/governance/","sidebar":"documentationSidebar"},{"id":"pb/ecosystem/governance/software-upgrade-proposal","path":"/docs/pb/ecosystem/governance/software-upgrade-proposal","sidebar":"documentationSidebar"},{"id":"pb/ecosystem/governance/voting","path":"/docs/pb/ecosystem/governance/voting","sidebar":"documentationSidebar"},{"id":"pb/faq/delegator-faq","path":"/docs/pb/faq/delegator-faq","sidebar":"documentationSidebar"},{"id":"pb/faq/transactions-error-codes","path":"/docs/pb/faq/transactions-error-codes","sidebar":"documentationSidebar"},{"id":"pb/faq/validator-faq","path":"/docs/pb/faq/validator-faq","sidebar":"documentationSidebar"},{"id":"pb/integrating/asset-originators-guide","path":"/docs/pb/integrating/asset-originators-guide"},{"id":"pb/integrating/integrating-with-p8e/index","path":"/docs/pb/integrating/integrating-with-p8e/","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/lending-ecosystem/data-mapping","path":"/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/data-mapping","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/lending-ecosystem/index","path":"/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/lending-ecosystem/life-cycle-of-a-loan","path":"/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/life-cycle-of-a-loan","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/configuration-endpoints","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/configuration-endpoints","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/approve-contract","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/approve-contract","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/execute-contract","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/execute-contract","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/index","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/index","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/index","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/retrieve-file","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/retrieve-file","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/retrieve-object","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/retrieve-object","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/store-file","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/store-file","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/store-object","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/store-object","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/p8e-endpoints","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/p8e-endpoints","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/error-handling","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/error-handling","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/index","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/loan-onboarding","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/loan-onboarding","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/validation-request","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/validation-request","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/validation-response","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/validation-response","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/loan-onboarding-service/index","path":"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/deploying-the-encrypted-object-store/configuring-replication","path":"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/deploying-the-encrypted-object-store/configuring-replication","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/deploying-the-encrypted-object-store/index","path":"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/deploying-the-encrypted-object-store/","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/index","path":"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/key-management/index","path":"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/key-management/","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/key-management/permissioning-others","path":"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/key-management/permissioning-others","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/p8e-contracts/example-loan-contracts","path":"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/p8e-contracts/example-loan-contracts","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/p8e-contracts/index","path":"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/p8e-contracts/","sidebar":"documentationSidebar"},{"id":"pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/summary","path":"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/summary","sidebar":"documentationSidebar"},{"id":"pb/modules/attribute-module","path":"/docs/pb/modules/attribute-module"},{"id":"pb/modules/cosmos-modules","path":"/docs/pb/modules/cosmos-modules","sidebar":"documentationSidebar"},{"id":"pb/modules/ibc-and-zones","path":"/docs/pb/modules/ibc-and-zones","sidebar":"documentationSidebar"},{"id":"pb/modules/marker-module","path":"/docs/pb/modules/marker-module","sidebar":"documentationSidebar"},{"id":"pb/modules/metadata-module","path":"/docs/pb/modules/metadata-module","sidebar":"documentationSidebar"},{"id":"pb/modules/modules","path":"/docs/pb/modules/","sidebar":"documentationSidebar"},{"id":"pb/modules/name-module","path":"/docs/pb/modules/name-module","sidebar":"documentationSidebar"},{"id":"pb/modules/provwasm-smart-contracts","path":"/docs/pb/modules/provwasm-smart-contracts","sidebar":"documentationSidebar"},{"id":"pb/p8e/client-contract-execution-environment-faq","path":"/docs/pb/p8e/client-contract-execution-environment-faq"},{"id":"pb/p8e/components-1/api","path":"/docs/pb/p8e/components-1/api"},{"id":"pb/p8e/components-1/index-engine","path":"/docs/pb/p8e/components-1/index-engine"},{"id":"pb/p8e/contract-life-cycle","path":"/docs/pb/p8e/contract-life-cycle"},{"id":"pb/p8e/index","path":"/docs/pb/p8e/"},{"id":"pb/p8e/overview/api","path":"/docs/pb/p8e/overview/api","sidebar":"documentationSidebar"},{"id":"pb/p8e/overview/api/authentication","path":"/docs/pb/p8e/overview/api/authentication"},{"id":"pb/p8e/overview/api/contract-life-cycle","path":"/docs/pb/p8e/overview/api/contract-life-cycle"},{"id":"pb/p8e/overview/api/index-engine","path":"/docs/pb/p8e/overview/api/index-engine"},{"id":"pb/p8e/overview/api/README","path":"/docs/pb/p8e/overview/api/"},{"id":"pb/p8e/overview/api/signing-and-encryption","path":"/docs/pb/p8e/overview/api/signing-and-encryption"},{"id":"pb/p8e/overview/encrypted-object-store/dime-encryption-envelope-specification","path":"/docs/pb/p8e/overview/encrypted-object-store/dime-encryption-envelope-specification","sidebar":"documentationSidebar"},{"id":"pb/p8e/overview/encrypted-object-store/encryption-scheme","path":"/docs/pb/p8e/overview/encrypted-object-store/encryption-scheme","sidebar":"documentationSidebar"},{"id":"pb/p8e/overview/encrypted-object-store/index","path":"/docs/pb/p8e/overview/encrypted-object-store/","sidebar":"documentationSidebar"},{"id":"pb/p8e/overview/index","path":"/docs/pb/p8e/overview/","sidebar":"documentationSidebar"},{"id":"pb/p8e/overview/p8e-transition-flow","path":"/docs/pb/p8e/overview/p8e-transition-flow"},{"id":"pb/p8e/overview/p8e-ui","path":"/docs/pb/p8e/overview/p8e-ui"},{"id":"pb/p8e/p8e-usage/architecture","path":"/docs/pb/p8e/p8e-usage/architecture","sidebar":"documentationSidebar"},{"id":"pb/p8e/p8e-usage/building-new-contracts","path":"/docs/pb/p8e/p8e-usage/building-new-contracts","sidebar":"documentationSidebar"},{"id":"pb/p8e/p8e-usage/cross-scope-contract-example","path":"/docs/pb/p8e/p8e-usage/cross-scope-contract-example","sidebar":"documentationSidebar"},{"id":"pb/p8e/p8e-usage/data-retrieval","path":"/docs/pb/p8e/p8e-usage/data-retrieval","sidebar":"documentationSidebar"},{"id":"pb/p8e/p8e-usage/multi-contract-example","path":"/docs/pb/p8e/p8e-usage/multi-contract-example","sidebar":"documentationSidebar"},{"id":"pb/p8e/p8e-usage/multi-step-contract-example","path":"/docs/pb/p8e/p8e-usage/multi-step-contract-example","sidebar":"documentationSidebar"},{"id":"pb/p8e/p8e-usage/next-steps","path":"/docs/pb/p8e/p8e-usage/next-steps","sidebar":"documentationSidebar"},{"id":"pb/p8e/p8e-usage/p8e-setup","path":"/docs/pb/p8e/p8e-usage/p8e-setup"},{"id":"pb/p8e/p8e-usage/quick-start/hello-world-example","path":"/docs/pb/p8e/p8e-usage/quick-start/hello-world-example"},{"id":"pb/p8e/p8e-usage/quick-start/README","path":"/docs/pb/p8e/p8e-usage/quick-start/"},{"id":"pb/p8e/p8e-usage/specifications","path":"/docs/pb/p8e/p8e-usage/specifications","sidebar":"documentationSidebar"},{"id":"pb/p8e/security","path":"/docs/pb/p8e/security"},{"id":"pb/p8e/untitled/3rd-party-digital-signatures","path":"/docs/pb/p8e/untitled/3rd-party-digital-signatures"},{"id":"pb/p8e/untitled/README","path":"/docs/pb/p8e/untitled/"},{"id":"quick-start/become-a-validator","path":"/docs/quick-start/become-a-validator"},{"id":"quick-start/build-a-dapp","path":"/docs/quick-start/build-a-dapp"},{"id":"quick-start/start-here","path":"/docs/quick-start/start-here"},{"id":"quick-start/wallet-and-hash","path":"/docs/quick-start/wallet-and-hash"},{"id":"quick-start/write-a-smart-contract","path":"/docs/quick-start/write-a-smart-contract"},{"id":"sdk/attribute/events","path":"/docs/sdk/attribute/events","sidebar":"documentationSidebar"},{"id":"sdk/attribute/messages","path":"/docs/sdk/attribute/messages","sidebar":"documentationSidebar"},{"id":"sdk/attribute/params","path":"/docs/sdk/attribute/params","sidebar":"documentationSidebar"},{"id":"sdk/attribute/README","path":"/docs/sdk/attribute/","sidebar":"documentationSidebar"},{"id":"sdk/attribute/state","path":"/docs/sdk/attribute/state","sidebar":"documentationSidebar"},{"id":"sdk/exchange/concepts","path":"/docs/sdk/exchange/concepts","sidebar":"documentationSidebar"},{"id":"sdk/exchange/events","path":"/docs/sdk/exchange/events","sidebar":"documentationSidebar"},{"id":"sdk/exchange/messages","path":"/docs/sdk/exchange/messages","sidebar":"documentationSidebar"},{"id":"sdk/exchange/params","path":"/docs/sdk/exchange/params","sidebar":"documentationSidebar"},{"id":"sdk/exchange/queries","path":"/docs/sdk/exchange/queries","sidebar":"documentationSidebar"},{"id":"sdk/exchange/README","path":"/docs/sdk/exchange/","sidebar":"documentationSidebar"},{"id":"sdk/exchange/state","path":"/docs/sdk/exchange/state","sidebar":"documentationSidebar"},{"id":"sdk/hold/concepts","path":"/docs/sdk/hold/concepts","sidebar":"documentationSidebar"},{"id":"sdk/hold/events","path":"/docs/sdk/hold/events","sidebar":"documentationSidebar"},{"id":"sdk/hold/queries","path":"/docs/sdk/hold/queries","sidebar":"documentationSidebar"},{"id":"sdk/hold/README","path":"/docs/sdk/hold/","sidebar":"documentationSidebar"},{"id":"sdk/hold/state","path":"/docs/sdk/hold/state","sidebar":"documentationSidebar"},{"id":"sdk/ibchooks/README","path":"/docs/sdk/ibchooks/","sidebar":"documentationSidebar"},{"id":"sdk/ibcratelimit/README","path":"/docs/sdk/ibcratelimit/","sidebar":"documentationSidebar"},{"id":"sdk/marker/authorization","path":"/docs/sdk/marker/authorization","sidebar":"documentationSidebar"},{"id":"sdk/marker/begin_block","path":"/docs/sdk/marker/begin_block","sidebar":"documentationSidebar"},{"id":"sdk/marker/end_block","path":"/docs/sdk/marker/end_block","sidebar":"documentationSidebar"},{"id":"sdk/marker/events","path":"/docs/sdk/marker/events","sidebar":"documentationSidebar"},{"id":"sdk/marker/governance","path":"/docs/sdk/marker/governance","sidebar":"documentationSidebar"},{"id":"sdk/marker/hooks","path":"/docs/sdk/marker/hooks","sidebar":"documentationSidebar"},{"id":"sdk/marker/messages","path":"/docs/sdk/marker/messages","sidebar":"documentationSidebar"},{"id":"sdk/marker/params","path":"/docs/sdk/marker/params","sidebar":"documentationSidebar"},{"id":"sdk/marker/README","path":"/docs/sdk/marker/","sidebar":"documentationSidebar"},{"id":"sdk/marker/state","path":"/docs/sdk/marker/state","sidebar":"documentationSidebar"},{"id":"sdk/marker/state_transitions","path":"/docs/sdk/marker/state_transitions","sidebar":"documentationSidebar"},{"id":"sdk/marker/telemetry","path":"/docs/sdk/marker/telemetry","sidebar":"documentationSidebar"},{"id":"sdk/marker/transfers","path":"/docs/sdk/marker/transfers","sidebar":"documentationSidebar"},{"id":"sdk/metadata/authz","path":"/docs/sdk/metadata/authz","sidebar":"documentationSidebar"},{"id":"sdk/metadata/concepts","path":"/docs/sdk/metadata/concepts","sidebar":"documentationSidebar"},{"id":"sdk/metadata/events","path":"/docs/sdk/metadata/events","sidebar":"documentationSidebar"},{"id":"sdk/metadata/examples/kotlin/README","path":"/docs/sdk/metadata/examples/kotlin/","sidebar":"documentationSidebar"},{"id":"sdk/metadata/messages","path":"/docs/sdk/metadata/messages","sidebar":"documentationSidebar"},{"id":"sdk/metadata/params","path":"/docs/sdk/metadata/params","sidebar":"documentationSidebar"},{"id":"sdk/metadata/queries","path":"/docs/sdk/metadata/queries","sidebar":"documentationSidebar"},{"id":"sdk/metadata/README","path":"/docs/sdk/metadata/","sidebar":"documentationSidebar"},{"id":"sdk/metadata/state","path":"/docs/sdk/metadata/state","sidebar":"documentationSidebar"},{"id":"sdk/metadata/telemetry","path":"/docs/sdk/metadata/telemetry","sidebar":"documentationSidebar"},{"id":"sdk/msgfees/concepts","path":"/docs/sdk/msgfees/concepts","sidebar":"documentationSidebar"},{"id":"sdk/msgfees/events","path":"/docs/sdk/msgfees/events","sidebar":"documentationSidebar"},{"id":"sdk/msgfees/genesis","path":"/docs/sdk/msgfees/genesis","sidebar":"documentationSidebar"},{"id":"sdk/msgfees/governance","path":"/docs/sdk/msgfees/governance","sidebar":"documentationSidebar"},{"id":"sdk/msgfees/messages","path":"/docs/sdk/msgfees/messages","sidebar":"documentationSidebar"},{"id":"sdk/msgfees/params","path":"/docs/sdk/msgfees/params","sidebar":"documentationSidebar"},{"id":"sdk/msgfees/queries","path":"/docs/sdk/msgfees/queries","sidebar":"documentationSidebar"},{"id":"sdk/msgfees/README","path":"/docs/sdk/msgfees/","sidebar":"documentationSidebar"},{"id":"sdk/msgfees/start_end_block","path":"/docs/sdk/msgfees/start_end_block","sidebar":"documentationSidebar"},{"id":"sdk/msgfees/state","path":"/docs/sdk/msgfees/state","sidebar":"documentationSidebar"},{"id":"sdk/name/concepts","path":"/docs/sdk/name/concepts","sidebar":"documentationSidebar"},{"id":"sdk/name/events","path":"/docs/sdk/name/events","sidebar":"documentationSidebar"},{"id":"sdk/name/messages","path":"/docs/sdk/name/messages","sidebar":"documentationSidebar"},{"id":"sdk/name/params","path":"/docs/sdk/name/params","sidebar":"documentationSidebar"},{"id":"sdk/name/README","path":"/docs/sdk/name/","sidebar":"documentationSidebar"},{"id":"sdk/name/state","path":"/docs/sdk/name/state","sidebar":"documentationSidebar"},{"id":"sdk/oracle/concepts","path":"/docs/sdk/oracle/concepts","sidebar":"documentationSidebar"},{"id":"sdk/oracle/events","path":"/docs/sdk/oracle/events","sidebar":"documentationSidebar"},{"id":"sdk/oracle/genesis","path":"/docs/sdk/oracle/genesis","sidebar":"documentationSidebar"},{"id":"sdk/oracle/messages","path":"/docs/sdk/oracle/messages","sidebar":"documentationSidebar"},{"id":"sdk/oracle/queries","path":"/docs/sdk/oracle/queries","sidebar":"documentationSidebar"},{"id":"sdk/oracle/README","path":"/docs/sdk/oracle/","sidebar":"documentationSidebar"},{"id":"sdk/oracle/state","path":"/docs/sdk/oracle/state","sidebar":"documentationSidebar"},{"id":"sdk/README","path":"/docs/sdk/","sidebar":"documentationSidebar"},{"id":"sdk/reward/begin_and_end_blocker","path":"/docs/sdk/reward/begin_and_end_blocker","sidebar":"documentationSidebar"},{"id":"sdk/reward/concepts","path":"/docs/sdk/reward/concepts","sidebar":"documentationSidebar"},{"id":"sdk/reward/events","path":"/docs/sdk/reward/events","sidebar":"documentationSidebar"},{"id":"sdk/reward/genesis","path":"/docs/sdk/reward/genesis","sidebar":"documentationSidebar"},{"id":"sdk/reward/messages","path":"/docs/sdk/reward/messages","sidebar":"documentationSidebar"},{"id":"sdk/reward/queries","path":"/docs/sdk/reward/queries","sidebar":"documentationSidebar"},{"id":"sdk/reward/README","path":"/docs/sdk/reward/","sidebar":"documentationSidebar"},{"id":"sdk/reward/state","path":"/docs/sdk/reward/state","sidebar":"documentationSidebar"},{"id":"sdk/reward/state_transitions","path":"/docs/sdk/reward/state_transitions","sidebar":"documentationSidebar"},{"id":"sdk/trigger/begin_and_end_blocker","path":"/docs/sdk/trigger/begin_and_end_blocker","sidebar":"documentationSidebar"},{"id":"sdk/trigger/concepts","path":"/docs/sdk/trigger/concepts","sidebar":"documentationSidebar"},{"id":"sdk/trigger/events","path":"/docs/sdk/trigger/events","sidebar":"documentationSidebar"},{"id":"sdk/trigger/genesis","path":"/docs/sdk/trigger/genesis","sidebar":"documentationSidebar"},{"id":"sdk/trigger/messages","path":"/docs/sdk/trigger/messages","sidebar":"documentationSidebar"},{"id":"sdk/trigger/queries","path":"/docs/sdk/trigger/queries","sidebar":"documentationSidebar"},{"id":"sdk/trigger/README","path":"/docs/sdk/trigger/","sidebar":"documentationSidebar"},{"id":"sdk/trigger/state","path":"/docs/sdk/trigger/state","sidebar":"documentationSidebar"}],"draftIds":[],"sidebars":{"dappsSidebar":{"link":{"path":"/docs/learn/dapps/dapps-overview","label":"learn/dapps/dapps-overview"}},"assetLifecycleSidebar":{"link":{"path":"/docs/learn/asset-lifecycle/assets-overview","label":"learn/asset-lifecycle/assets-overview"}},"buildSidebar":{"link":{"path":"/docs/build/dev-environment","label":"build/dev-environment"}},"documentationSidebar":{"link":{"path":"/docs/","label":"index"}}}}],"breadcrumbs":true}}}'),a=JSON.parse('{"defaultLocale":"en","locales":["en"],"path":"i18n","currentLocale":"en","localeConfigs":{"en":{"label":"English","direction":"ltr","htmlLang":"en","calendar":"gregory","path":"en"}}}');var r=n(57529);const p=JSON.parse('{"docusaurusVersion":"3.0.1","siteVersion":"0.0.0","pluginVersions":{"docusaurus-plugin-content-docs":{"type":"package","name":"@docusaurus/plugin-content-docs","version":"3.0.1"},"docusaurus-plugin-content-pages":{"type":"package","name":"@docusaurus/plugin-content-pages","version":"3.0.1"},"docusaurus-plugin-google-gtag":{"type":"package","name":"@docusaurus/plugin-google-gtag","version":"3.0.1"},"docusaurus-plugin-sitemap":{"type":"package","name":"@docusaurus/plugin-sitemap","version":"3.0.1"},"docusaurus-plugin-redoc":{"type":"package","name":"docusaurus-plugin-redoc","version":"2.0.0"},"docusaurus-theme-classic":{"type":"package","name":"@docusaurus/theme-classic","version":"3.0.1"},"docusaurus-theme-search-algolia":{"type":"package","name":"@docusaurus/theme-search-algolia","version":"3.0.1"},"docusaurus-theme-redoc":{"type":"package","name":"docusaurus-theme-redoc","version":"2.0.0"},"docusaurus-tailwindcss":{"type":"local"},"docusaurus-plugin-client-redirects":{"type":"package","name":"@docusaurus/plugin-client-redirects","version":"3.0.1"}}}');var c=n(85893);const d={siteConfig:i.default,siteMetadata:p,globalData:s,i18n:a,codeTranslations:r},l=o.createContext(d);function u(e){let{children:t}=e;return(0,c.jsx)(l.Provider,{value:d,children:t})}},44763:(e,t,n)=>{"use strict";n.d(t,{Z:()=>h});var o=n(67294),i=n(10412),s=n(35742),a=n(18780),r=n(7372),p=n(85893);function c(e){let{error:t,tryAgain:n}=e;return(0,p.jsxs)("div",{style:{display:"flex",flexDirection:"column",justifyContent:"center",alignItems:"flex-start",minHeight:"100vh",width:"100%",maxWidth:"80ch",fontSize:"20px",margin:"0 auto",padding:"1rem"},children:[(0,p.jsx)("h1",{style:{fontSize:"3rem"},children:"This page crashed"}),(0,p.jsx)("button",{type:"button",onClick:n,style:{margin:"1rem 0",fontSize:"2rem",cursor:"pointer",borderRadius:20,padding:"1rem"},children:"Try again"}),(0,p.jsx)(d,{error:t})]})}function d(e){let{error:t}=e;const n=(0,a.getErrorCausalChain)(t).map((e=>e.message)).join("\n\nCause:\n");return(0,p.jsx)("p",{style:{whiteSpace:"pre-wrap"},children:n})}function l(e){let{error:t,tryAgain:n}=e;return(0,p.jsxs)(h,{fallback:()=>(0,p.jsx)(c,{error:t,tryAgain:n}),children:[(0,p.jsx)(s.Z,{children:(0,p.jsx)("title",{children:"Page Error"})}),(0,p.jsx)(r.Z,{children:(0,p.jsx)(c,{error:t,tryAgain:n})})]})}const u=e=>(0,p.jsx)(l,{...e});class h extends o.Component{constructor(e){super(e),this.state={error:null}}componentDidCatch(e){i.default.canUseDOM&&this.setState({error:e})}render(){const{children:e}=this.props,{error:t}=this.state;if(t){const e={error:t,tryAgain:()=>this.setState({error:null})};return(this.props.fallback??u)(e)}return e??null}}},10412:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>i});const o="undefined"!=typeof window&&"document"in window&&"createElement"in window.document,i={canUseDOM:o,canUseEventListeners:o&&("addEventListener"in window||"attachEvent"in window),canUseIntersectionObserver:o&&"IntersectionObserver"in window,canUseViewport:o&&"screen"in window}},35742:(e,t,n)=>{"use strict";n.d(t,{Z:()=>s});n(67294);var o=n(70405),i=n(85893);function s(e){return(0,i.jsx)(o.ql,{...e})}},39960:(e,t,n)=>{"use strict";n.d(t,{Z:()=>h});var o=n(67294),i=n(73727),s=n(18780),a=n(52263),r=n(13919),p=n(10412),c=n(85893);const d=o.createContext({collectLink:()=>{}});var l=n(44996);function u(e,t){let{isNavLink:n,to:u,href:h,activeClassName:f,isActive:y,"data-noBrokenLinkCheck":m,autoAddBaseUrl:g=!0,..._}=e;const{siteConfig:{trailingSlash:b,baseUrl:T}}=(0,a.Z)(),{withBaseUrl:v}=(0,l.C)(),P=(0,o.useContext)(d),E=(0,o.useRef)(null);(0,o.useImperativeHandle)(t,(()=>E.current));const R=u||h;const A=(0,r.Z)(R),k=R?.replace("pathname://","");let w=void 0!==k?(S=k,g&&(e=>e.startsWith("/"))(S)?v(S):S):void 0;var S;w&&A&&(w=(0,s.applyTrailingSlash)(w,{trailingSlash:b,baseUrl:T}));const I=(0,o.useRef)(!1),O=n?i.OL:i.rU,x=p.default.canUseIntersectionObserver,N=(0,o.useRef)(),U=()=>{I.current||null==w||(window.docusaurus.preload(w),I.current=!0)};(0,o.useEffect)((()=>(!x&&A&&null!=w&&window.docusaurus.prefetch(w),()=>{x&&N.current&&N.current.disconnect()})),[N,w,x,A]);const Y=w?.startsWith("#")??!1,C=!w||!A||Y;return C||m||P.collectLink(w),C?(0,c.jsx)("a",{ref:E,href:w,...R&&!A&&{target:"_blank",rel:"noopener noreferrer"},..._}):(0,c.jsx)(O,{..._,onMouseEnter:U,onTouchStart:U,innerRef:e=>{E.current=e,x&&e&&A&&(N.current=new window.IntersectionObserver((t=>{t.forEach((t=>{e===t.target&&(t.isIntersecting||t.intersectionRatio>0)&&(N.current.unobserve(e),N.current.disconnect(),null!=w&&window.docusaurus.prefetch(w))}))})),N.current.observe(e))},to:w,...n&&{isActive:y,activeClassName:f}})}const h=o.forwardRef(u)},95999:(e,t,n)=>{"use strict";n.d(t,{Z:()=>c,I:()=>p});var o=n(67294),i=n(85893);function s(e,t){const n=e.split(/(\{\w+\})/).map(((e,n)=>{if(n%2==1){const n=t?.[e.slice(1,-1)];if(void 0!==n)return n}return e}));return n.some((e=>(0,o.isValidElement)(e)))?n.map(((e,t)=>(0,o.isValidElement)(e)?o.cloneElement(e,{key:t}):e)).filter((e=>""!==e)):n.join("")}var a=n(57529);function r(e){let{id:t,message:n}=e;if(void 0===t&&void 0===n)throw new Error("Docusaurus translation declarations must have at least a translation id or a default translation message");return a[t??n]??n??t}function p(e,t){let{message:n,id:o}=e;return s(r({message:n,id:o}),t)}function c(e){let{children:t,id:n,values:o}=e;if(t&&"string"!=typeof t)throw console.warn("Illegal <Translate> children",t),new Error("The Docusaurus <Translate> component only accept simple string values");const a=r({message:t,id:n});return(0,i.jsx)(i.Fragment,{children:s(a,o)})}},29935:(e,t,n)=>{"use strict";n.d(t,{m:()=>o});const o="default"},13919:(e,t,n)=>{"use strict";function o(e){return/^(?:\w*:|\/\/)/.test(e)}function i(e){return void 0!==e&&!o(e)}n.d(t,{Z:()=>i,b:()=>o})},44996:(e,t,n)=>{"use strict";n.d(t,{C:()=>a,Z:()=>r});var o=n(67294),i=n(52263),s=n(13919);function a(){const{siteConfig:{baseUrl:e,url:t}}=(0,i.Z)(),n=(0,o.useCallback)(((n,o)=>function(e,t,n,o){let{forcePrependBaseUrl:i=!1,absolute:a=!1}=void 0===o?{}:o;if(!n||n.startsWith("#")||(0,s.b)(n))return n;if(i)return t+n.replace(/^\//,"");if(n===t.replace(/\/$/,""))return t;const r=n.startsWith(t)?n:t+n.replace(/^\//,"");return a?e+r:r}(t,e,n,o)),[t,e]);return{withBaseUrl:n}}function r(e,t){void 0===t&&(t={});const{withBaseUrl:n}=a();return n(e,t)}},52263:(e,t,n)=>{"use strict";n.d(t,{Z:()=>s});var o=n(67294),i=n(58940);function s(){return(0,o.useContext)(i._)}},28084:(e,t,n)=>{"use strict";n.d(t,{OD:()=>s,eZ:()=>a});var o=n(52263),i=n(29935);function s(e,t){void 0===t&&(t={});const n=function(){const{globalData:e}=(0,o.Z)();return e}()[e];if(!n&&t.failfast)throw new Error(`Docusaurus plugin global data not found for "${e}" plugin.`);return n}function a(e,t,n){void 0===t&&(t=i.m),void 0===n&&(n={});const o=s(e),a=o?.[t];if(!a&&n.failfast)throw new Error(`Docusaurus plugin global data not found for "${e}" plugin with id "${t}".`);return a}},72389:(e,t,n)=>{"use strict";n.d(t,{Z:()=>s});var o=n(67294),i=n(98934);function s(){return(0,o.useContext)(i._)}},20469:(e,t,n)=>{"use strict";n.d(t,{Z:()=>i});var o=n(67294);const i=n(10412).default.canUseDOM?o.useLayoutEffect:o.useEffect},99670:(e,t,n)=>{"use strict";n.d(t,{Z:()=>i});const o=e=>"object"==typeof e&&!!e&&Object.keys(e).length>0;function i(e){const t={};return function e(n,i){Object.entries(n).forEach((n=>{let[s,a]=n;const r=i?`${i}.${s}`:s;o(a)?e(a,r):t[r]=a}))}(e),t}},30226:(e,t,n)=>{"use strict";n.d(t,{_:()=>s,z:()=>a});var o=n(67294),i=n(85893);const s=o.createContext(null);function a(e){let{children:t,value:n}=e;const a=o.useContext(s),r=(0,o.useMemo)((()=>function(e){let{parent:t,value:n}=e;if(!t){if(!n)throw new Error("Unexpected: no Docusaurus route context found");if(!("plugin"in n))throw new Error("Unexpected: Docusaurus topmost route context has no `plugin` attribute");return n}const o={...t.data,...n?.data};return{plugin:t.plugin,data:o}}({parent:a,value:n})),[a,n]);return(0,i.jsx)(s.Provider,{value:r,children:t})}},94104:(e,t,n)=>{"use strict";n.d(t,{Iw:()=>y,gA:()=>l,WS:()=>u,_r:()=>c,Jo:()=>m,zh:()=>d,yW:()=>f,gB:()=>h});var o=n(16550),i=n(28084);const s=e=>e.versions.find((e=>e.isLast));function a(e,t){const n=s(e);return[...e.versions.filter((e=>e!==n)),n].find((e=>!!(0,o.LX)(t,{path:e.path,exact:!1,strict:!1})))}function r(e,t){const n=a(e,t),i=n?.docs.find((e=>!!(0,o.LX)(t,{path:e.path,exact:!0,strict:!1})));return{activeVersion:n,activeDoc:i,alternateDocVersions:i?function(t){const n={};return e.versions.forEach((e=>{e.docs.forEach((o=>{o.id===t&&(n[e.name]=o)}))})),n}(i.id):{}}}const p={},c=()=>(0,i.OD)("docusaurus-plugin-content-docs")??p,d=e=>(0,i.eZ)("docusaurus-plugin-content-docs",e,{failfast:!0});function l(e){void 0===e&&(e={});const t=c(),{pathname:n}=(0,o.TH)();return function(e,t,n){void 0===n&&(n={});const i=Object.entries(e).sort(((e,t)=>t[1].path.localeCompare(e[1].path))).find((e=>{let[,n]=e;return!!(0,o.LX)(t,{path:n.path,exact:!1,strict:!1})})),s=i?{pluginId:i[0],pluginData:i[1]}:void 0;if(!s&&n.failfast)throw new Error(`Can't find active docs plugin for "${t}" pathname, while it was expected to be found. Maybe you tried to use a docs feature that can only be used on a docs-related page? Existing docs plugin paths are: ${Object.values(e).map((e=>e.path)).join(", ")}`);return s}(t,n,e)}function u(e){void 0===e&&(e={});const t=l(e),{pathname:n}=(0,o.TH)();if(!t)return;return{activePlugin:t,activeVersion:a(t.pluginData,n)}}function h(e){return d(e).versions}function f(e){const t=d(e);return s(t)}function y(e){const t=d(e),{pathname:n}=(0,o.TH)();return r(t,n)}function m(e){const t=d(e),{pathname:n}=(0,o.TH)();return function(e,t){const n=s(e);return{latestDocSuggestion:r(e,t).alternateDocVersions[n.name],latestVersionSuggestion:n}}(t,n)}},56657:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>o});const o={onRouteDidUpdate(e){let{location:t,previousLocation:n}=e;!n||t.pathname===n.pathname&&t.search===n.search&&t.hash===n.hash||setTimeout((()=>{window.gtag("set","page_path",t.pathname+t.search+t.hash),window.gtag("event","page_view")}))}}},18320:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>s});var o=n(74865),i=n.n(o);i().configure({showSpinner:!1});const s={onRouteUpdate(e){let{location:t,previousLocation:n}=e;if(n&&t.pathname!==n.pathname){const e=window.setTimeout((()=>{i().start()}),200);return()=>window.clearTimeout(e)}},onRouteDidUpdate(){i().done()}}},3310:(e,t,n)=>{"use strict";n.r(t);var o=n(34798),i=n(36809);!function(e){const{themeConfig:{prism:t}}=i.default,{additionalLanguages:o}=t;globalThis.Prism=e,o.forEach((e=>{"php"===e&&n(96854),n(30142)(`./prism-${e}`)})),delete globalThis.Prism}(o.p1)},92503:(e,t,n)=>{"use strict";n.d(t,{Z:()=>c});n(67294);var o=n(90512),i=n(95999),s=n(86668),a=n(39960);const r={anchorWithStickyNavbar:"anchorWithStickyNavbar_LWe7",anchorWithHideOnScrollNavbar:"anchorWithHideOnScrollNavbar_WYt5"};var p=n(85893);function c(e){let{as:t,id:n,...c}=e;const{navbar:{hideOnScroll:d}}=(0,s.L)();if("h1"===t||!n)return(0,p.jsx)(t,{...c,id:void 0});const l=(0,i.I)({id:"theme.common.headingLinkTitle",message:"Direct link to {heading}",description:"Title for link to heading"},{heading:"string"==typeof c.children?c.children:n});return(0,p.jsxs)(t,{...c,className:(0,o.Z)("anchor",d?r.anchorWithHideOnScrollNavbar:r.anchorWithStickyNavbar,c.className),id:n,children:[c.children,(0,p.jsx)(a.Z,{className:"hash-link",to:`#${n}`,"aria-label":l,title:l,children:"\u200b"})]})}},39471:(e,t,n)=>{"use strict";n.d(t,{Z:()=>s});n(67294);const o={iconExternalLink:"iconExternalLink_nPIU"};var i=n(85893);function s(e){let{width:t=13.5,height:n=13.5}=e;return(0,i.jsx)("svg",{width:t,height:n,"aria-hidden":"true",viewBox:"0 0 24 24",className:o.iconExternalLink,children:(0,i.jsx)("path",{fill:"currentColor",d:"M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"})})}},7372:(e,t,n)=>{"use strict";n.d(t,{Z:()=>Nt});var o=n(67294),i=n(90512),s=n(44763),a=n(10833),r=n(16550),p=n(95999),c=n(85936),d=n(85893);const l="__docusaurus_skipToContent_fallback";function u(e){e.setAttribute("tabindex","-1"),e.focus(),e.removeAttribute("tabindex")}function h(){const e=(0,o.useRef)(null),{action:t}=(0,r.k6)(),n=(0,o.useCallback)((e=>{e.preventDefault();const t=document.querySelector("main:first-of-type")??document.getElementById(l);t&&u(t)}),[]);return(0,c.S)((n=>{let{location:o}=n;e.current&&!o.hash&&"PUSH"===t&&u(e.current)})),{containerRef:e,onClick:n}}const f=(0,p.I)({id:"theme.common.skipToMainContent",description:"The skip to content label used for accessibility, allowing to rapidly navigate to main content with keyboard tab/enter navigation",message:"Skip to main content"});function y(e){const t=e.children??f,{containerRef:n,onClick:o}=h();return(0,d.jsx)("div",{ref:n,role:"region","aria-label":f,children:(0,d.jsx)("a",{...e,href:`#${l}`,onClick:o,children:t})})}var m=n(35281),g=n(19727);const _={skipToContent:"skipToContent_fXgn"};function b(){return(0,d.jsx)(y,{className:_.skipToContent})}var T=n(86668),v=n(59689);function P(e){let{width:t=21,height:n=21,color:o="currentColor",strokeWidth:i=1.2,className:s,...a}=e;return(0,d.jsx)("svg",{viewBox:"0 0 15 15",width:t,height:n,...a,children:(0,d.jsx)("g",{stroke:o,strokeWidth:i,children:(0,d.jsx)("path",{d:"M.75.75l13.5 13.5M14.25.75L.75 14.25"})})})}const E={closeButton:"closeButton_CVFx"};function R(e){return(0,d.jsx)("button",{type:"button","aria-label":(0,p.I)({id:"theme.AnnouncementBar.closeButtonAriaLabel",message:"Close",description:"The ARIA label for close button of announcement bar"}),...e,className:(0,i.Z)("clean-btn close",E.closeButton,e.className),children:(0,d.jsx)(P,{width:14,height:14,strokeWidth:3.1})})}const A={content:"content_knG7"};function k(e){const{announcementBar:t}=(0,T.L)(),{content:n}=t;return(0,d.jsx)("div",{...e,className:(0,i.Z)(A.content,e.className),dangerouslySetInnerHTML:{__html:n}})}const w={announcementBar:"announcementBar_mb4j",announcementBarPlaceholder:"announcementBarPlaceholder_vyr4",announcementBarClose:"announcementBarClose_gvF7",announcementBarContent:"announcementBarContent_xLdY"};function S(){const{announcementBar:e}=(0,T.L)(),{isActive:t,close:n}=(0,v.nT)();if(!t)return null;const{backgroundColor:o,textColor:i,isCloseable:s}=e;return(0,d.jsxs)("div",{className:w.announcementBar,style:{backgroundColor:o,color:i},role:"banner",children:[s&&(0,d.jsx)("div",{className:w.announcementBarPlaceholder}),(0,d.jsx)(k,{className:w.announcementBarContent}),s&&(0,d.jsx)(R,{onClick:n,className:w.announcementBarClose})]})}var I=n(93163),O=n(12466);var x=n(902),N=n(13102);const U=o.createContext(null);function Y(e){let{children:t}=e;const n=function(){const e=(0,I.e)(),t=(0,N.HY)(),[n,i]=(0,o.useState)(!1),s=null!==t.component,a=(0,x.D9)(s);return(0,o.useEffect)((()=>{s&&!a&&i(!0)}),[s,a]),(0,o.useEffect)((()=>{s?e.shown||i(!0):i(!1)}),[e.shown,s]),(0,o.useMemo)((()=>[n,i]),[n])}();return(0,d.jsx)(U.Provider,{value:n,children:t})}function C(e){if(e.component){const t=e.component;return(0,d.jsx)(t,{...e.props})}}function L(){const e=(0,o.useContext)(U);if(!e)throw new x.i6("NavbarSecondaryMenuDisplayProvider");const[t,n]=e,i=(0,o.useCallback)((()=>n(!1)),[n]),s=(0,N.HY)();return(0,o.useMemo)((()=>({shown:t,hide:i,content:C(s)})),[i,s,t])}function D(e){let{header:t,primaryMenu:n,secondaryMenu:o}=e;const{shown:s}=L();return(0,d.jsxs)("div",{className:"navbar-sidebar",children:[t,(0,d.jsxs)("div",{className:(0,i.Z)("navbar-sidebar__items",{"navbar-sidebar__items--show-secondary":s}),children:[(0,d.jsx)("div",{className:"navbar-sidebar__item menu",children:n}),(0,d.jsx)("div",{className:"navbar-sidebar__item menu",children:o})]})]})}var q=n(92949),F=n(72389);function j(e){return(0,d.jsx)("svg",{viewBox:"0 0 24 24",width:24,height:24,...e,children:(0,d.jsx)("path",{fill:"currentColor",d:"M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"})})}function M(e){return(0,d.jsx)("svg",{viewBox:"0 0 24 24",width:24,height:24,...e,children:(0,d.jsx)("path",{fill:"currentColor",d:"M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"})})}const z={toggle:"toggle_vylO",toggleButton:"toggleButton_gllP",darkToggleIcon:"darkToggleIcon_wfgR",lightToggleIcon:"lightToggleIcon_pyhR",toggleButtonDisabled:"toggleButtonDisabled_aARS"};function V(e){let{className:t,buttonClassName:n,value:o,onChange:s}=e;const a=(0,F.Z)(),r=(0,p.I)({message:"Switch between dark and light mode (currently {mode})",id:"theme.colorToggle.ariaLabel",description:"The ARIA label for the navbar color mode toggle"},{mode:"dark"===o?(0,p.I)({message:"dark mode",id:"theme.colorToggle.ariaLabel.mode.dark",description:"The name for the dark color mode"}):(0,p.I)({message:"light mode",id:"theme.colorToggle.ariaLabel.mode.light",description:"The name for the light color mode"})});return(0,d.jsx)("div",{className:(0,i.Z)(z.toggle,t),children:(0,d.jsxs)("button",{className:(0,i.Z)("clean-btn",z.toggleButton,!a&&z.toggleButtonDisabled,n),type:"button",onClick:()=>s("dark"===o?"light":"dark"),disabled:!a,title:r,"aria-label":r,"aria-live":"polite",children:[(0,d.jsx)(j,{className:(0,i.Z)(z.toggleIcon,z.lightToggleIcon)}),(0,d.jsx)(M,{className:(0,i.Z)(z.toggleIcon,z.darkToggleIcon)})]})})}const G=o.memo(V),B={darkNavbarColorModeToggle:"darkNavbarColorModeToggle_X3D1"};function J(e){let{className:t}=e;const n=(0,T.L)().navbar.style,o=(0,T.L)().colorMode.disableSwitch,{colorMode:i,setColorMode:s}=(0,q.I)();return o?null:(0,d.jsx)(G,{className:t,buttonClassName:"dark"===n?B.darkNavbarColorModeToggle:void 0,value:i,onChange:s})}var Q=n(21327);function H(){return(0,d.jsx)(Q.Z,{className:"navbar__brand",imageClassName:"navbar__logo",titleClassName:"navbar__title text--truncate"})}function W(){const e=(0,I.e)();return(0,d.jsx)("button",{type:"button","aria-label":(0,p.I)({id:"theme.docs.sidebar.closeSidebarButtonAriaLabel",message:"Close navigation bar",description:"The ARIA label for close button of mobile sidebar"}),className:"clean-btn navbar-sidebar__close",onClick:()=>e.toggle(),children:(0,d.jsx)(P,{color:"var(--ifm-color-emphasis-600)"})})}function K(){return(0,d.jsxs)("div",{className:"navbar-sidebar__brand",children:[(0,d.jsx)(H,{}),(0,d.jsx)(J,{className:"margin-right--md"}),(0,d.jsx)(W,{})]})}var $=n(39960),Z=n(44996),X=n(13919),ee=n(98022),te=n(39471);function ne(e){let{activeBasePath:t,activeBaseRegex:n,to:o,href:i,label:s,html:a,isDropdownLink:r,prependBaseUrlToHref:p,...c}=e;const l=(0,Z.Z)(o),u=(0,Z.Z)(t),h=(0,Z.Z)(i,{forcePrependBaseUrl:!0}),f=s&&i&&!(0,X.Z)(i),y=a?{dangerouslySetInnerHTML:{__html:a}}:{children:(0,d.jsxs)(d.Fragment,{children:[s,f&&(0,d.jsx)(te.Z,{...r&&{width:12,height:12}})]})};return i?(0,d.jsx)($.Z,{href:p?h:i,...c,...y}):(0,d.jsx)($.Z,{to:l,isNavLink:!0,...(t||n)&&{isActive:(e,t)=>n?(0,ee.F)(n,t.pathname):t.pathname.startsWith(u)},...c,...y})}function oe(e){let{className:t,isDropdownItem:n=!1,...o}=e;const s=(0,d.jsx)(ne,{className:(0,i.Z)(n?"dropdown__link":"navbar__item navbar__link",t),isDropdownLink:n,...o});return n?(0,d.jsx)("li",{children:s}):s}function ie(e){let{className:t,isDropdownItem:n,...o}=e;return(0,d.jsx)("li",{className:"menu__list-item",children:(0,d.jsx)(ne,{className:(0,i.Z)("menu__link",t),...o})})}function se(e){let{mobile:t=!1,position:n,...o}=e;const i=t?ie:oe;return(0,d.jsx)(i,{...o,activeClassName:o.activeClassName??(t?"menu__link--active":"navbar__link--active")})}var ae=n(86043),re=n(48596),pe=n(52263);const ce={dropdownNavbarItemMobile:"dropdownNavbarItemMobile_S0Fm"};function de(e,t){return e.some((e=>function(e,t){return!!(0,re.Mg)(e.to,t)||!!(0,ee.F)(e.activeBaseRegex,t)||!(!e.activeBasePath||!t.startsWith(e.activeBasePath))}(e,t)))}function le(e){let{items:t,position:n,className:s,onClick:a,...r}=e;const p=(0,o.useRef)(null),[c,l]=(0,o.useState)(!1);return(0,o.useEffect)((()=>{const e=e=>{p.current&&!p.current.contains(e.target)&&l(!1)};return document.addEventListener("mousedown",e),document.addEventListener("touchstart",e),document.addEventListener("focusin",e),()=>{document.removeEventListener("mousedown",e),document.removeEventListener("touchstart",e),document.removeEventListener("focusin",e)}}),[p]),(0,d.jsxs)("div",{ref:p,className:(0,i.Z)("navbar__item","dropdown","dropdown--hoverable",{"dropdown--right":"right"===n,"dropdown--show":c}),children:[(0,d.jsx)(ne,{"aria-haspopup":"true","aria-expanded":c,role:"button",href:r.to?void 0:"#",className:(0,i.Z)("navbar__link",s),...r,onClick:r.to?void 0:e=>e.preventDefault(),onKeyDown:e=>{"Enter"===e.key&&(e.preventDefault(),l(!c))},children:r.children??r.label}),(0,d.jsx)("ul",{className:"dropdown__menu",children:t.map(((e,t)=>(0,o.createElement)(Ge,{isDropdownItem:!0,activeClassName:"dropdown__link--active",...e,key:t})))})]})}function ue(e){let{items:t,className:n,position:s,onClick:a,...p}=e;const c=function(){const{siteConfig:{baseUrl:e}}=(0,pe.Z)(),{pathname:t}=(0,r.TH)();return t.replace(e,"/")}(),l=de(t,c),{collapsed:u,toggleCollapsed:h,setCollapsed:f}=(0,ae.u)({initialState:()=>!l});return(0,o.useEffect)((()=>{l&&f(!l)}),[c,l,f]),(0,d.jsxs)("li",{className:(0,i.Z)("menu__list-item",{"menu__list-item--collapsed":u}),children:[(0,d.jsx)(ne,{role:"button",className:(0,i.Z)(ce.dropdownNavbarItemMobile,"menu__link menu__link--sublist menu__link--sublist-caret",n),...p,onClick:e=>{e.preventDefault(),h()},children:p.children??p.label}),(0,d.jsx)(ae.z,{lazy:!0,as:"ul",className:"menu__list",collapsed:u,children:t.map(((e,t)=>(0,o.createElement)(Ge,{mobile:!0,isDropdownItem:!0,onClick:a,activeClassName:"menu__link--active",...e,key:t})))})]})}function he(e){let{mobile:t=!1,...n}=e;const o=t?ue:le;return(0,d.jsx)(o,{...n})}var fe=n(94711);function ye(e){let{width:t=20,height:n=20,...o}=e;return(0,d.jsx)("svg",{viewBox:"0 0 24 24",width:t,height:n,"aria-hidden":!0,...o,children:(0,d.jsx)("path",{fill:"currentColor",d:"M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"})})}const me="iconLanguage_nlXk";function ge(){return o.createElement("svg",{width:"15",height:"15",className:"DocSearch-Control-Key-Icon"},o.createElement("path",{d:"M4.505 4.496h2M5.505 5.496v5M8.216 4.496l.055 5.993M10 7.5c.333.333.5.667.5 1v2M12.326 4.5v5.996M8.384 4.496c1.674 0 2.116 0 2.116 1.5s-.442 1.5-2.116 1.5M3.205 9.303c-.09.448-.277 1.21-1.241 1.203C1 10.5.5 9.513.5 8V7c0-1.57.5-2.5 1.464-2.494.964.006 1.134.598 1.24 1.342M12.553 10.5h1.953",strokeWidth:"1.2",stroke:"currentColor",fill:"none",strokeLinecap:"square"}))}var _e=n(20830),be=["translations"];function Te(){return Te=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},Te.apply(this,arguments)}function ve(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==n)return;var o,i,s=[],a=!0,r=!1;try{for(n=n.call(e);!(a=(o=n.next()).done)&&(s.push(o.value),!t||s.length!==t);a=!0);}catch(p){r=!0,i=p}finally{try{a||null==n.return||n.return()}finally{if(r)throw i}}return s}(e,t)||function(e,t){if(!e)return;if("string"==typeof e)return Pe(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);"Object"===n&&e.constructor&&(n=e.constructor.name);if("Map"===n||"Set"===n)return Array.from(e);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return Pe(e,t)}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function Pe(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,o=new Array(t);n<t;n++)o[n]=e[n];return o}function Ee(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var Re="Ctrl";var Ae=o.forwardRef((function(e,t){var n=e.translations,i=void 0===n?{}:n,s=Ee(e,be),a=i.buttonText,r=void 0===a?"Search":a,p=i.buttonAriaLabel,c=void 0===p?"Search":p,d=ve((0,o.useState)(null),2),l=d[0],u=d[1];return(0,o.useEffect)((function(){"undefined"!=typeof navigator&&(/(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)?u("\u2318"):u(Re))}),[]),o.createElement("button",Te({type:"button",className:"DocSearch DocSearch-Button","aria-label":c},s,{ref:t}),o.createElement("span",{className:"DocSearch-Button-Container"},o.createElement(_e.W,null),o.createElement("span",{className:"DocSearch-Button-Placeholder"},r)),o.createElement("span",{className:"DocSearch-Button-Keys"},null!==l&&o.createElement(o.Fragment,null,o.createElement("kbd",{className:"DocSearch-Button-Key"},l===Re?o.createElement(ge,null):l),o.createElement("kbd",{className:"DocSearch-Button-Key"},"K"))))})),ke=n(35742),we=n(66177),Se=n(239),Ie=n(43320);var Oe=n(73935);const xe={button:{buttonText:(0,p.I)({id:"theme.SearchBar.label",message:"Search",description:"The ARIA label and placeholder for search button"}),buttonAriaLabel:(0,p.I)({id:"theme.SearchBar.label",message:"Search",description:"The ARIA label and placeholder for search button"})},modal:{searchBox:{resetButtonTitle:(0,p.I)({id:"theme.SearchModal.searchBox.resetButtonTitle",message:"Clear the query",description:"The label and ARIA label for search box reset button"}),resetButtonAriaLabel:(0,p.I)({id:"theme.SearchModal.searchBox.resetButtonTitle",message:"Clear the query",description:"The label and ARIA label for search box reset button"}),cancelButtonText:(0,p.I)({id:"theme.SearchModal.searchBox.cancelButtonText",message:"Cancel",description:"The label and ARIA label for search box cancel button"}),cancelButtonAriaLabel:(0,p.I)({id:"theme.SearchModal.searchBox.cancelButtonText",message:"Cancel",description:"The label and ARIA label for search box cancel button"})},startScreen:{recentSearchesTitle:(0,p.I)({id:"theme.SearchModal.startScreen.recentSearchesTitle",message:"Recent",description:"The title for recent searches"}),noRecentSearchesText:(0,p.I)({id:"theme.SearchModal.startScreen.noRecentSearchesText",message:"No recent searches",description:"The text when no recent searches"}),saveRecentSearchButtonTitle:(0,p.I)({id:"theme.SearchModal.startScreen.saveRecentSearchButtonTitle",message:"Save this search",description:"The label for save recent search button"}),removeRecentSearchButtonTitle:(0,p.I)({id:"theme.SearchModal.startScreen.removeRecentSearchButtonTitle",message:"Remove this search from history",description:"The label for remove recent search button"}),favoriteSearchesTitle:(0,p.I)({id:"theme.SearchModal.startScreen.favoriteSearchesTitle",message:"Favorite",description:"The title for favorite searches"}),removeFavoriteSearchButtonTitle:(0,p.I)({id:"theme.SearchModal.startScreen.removeFavoriteSearchButtonTitle",message:"Remove this search from favorites",description:"The label for remove favorite search button"})},errorScreen:{titleText:(0,p.I)({id:"theme.SearchModal.errorScreen.titleText",message:"Unable to fetch results",description:"The title for error screen of search modal"}),helpText:(0,p.I)({id:"theme.SearchModal.errorScreen.helpText",message:"You might want to check your network connection.",description:"The help text for error screen of search modal"})},footer:{selectText:(0,p.I)({id:"theme.SearchModal.footer.selectText",message:"to select",description:"The explanatory text of the action for the enter key"}),selectKeyAriaLabel:(0,p.I)({id:"theme.SearchModal.footer.selectKeyAriaLabel",message:"Enter key",description:"The ARIA label for the Enter key button that makes the selection"}),navigateText:(0,p.I)({id:"theme.SearchModal.footer.navigateText",message:"to navigate",description:"The explanatory text of the action for the Arrow up and Arrow down key"}),navigateUpKeyAriaLabel:(0,p.I)({id:"theme.SearchModal.footer.navigateUpKeyAriaLabel",message:"Arrow up",description:"The ARIA label for the Arrow up key button that makes the navigation"}),navigateDownKeyAriaLabel:(0,p.I)({id:"theme.SearchModal.footer.navigateDownKeyAriaLabel",message:"Arrow down",description:"The ARIA label for the Arrow down key button that makes the navigation"}),closeText:(0,p.I)({id:"theme.SearchModal.footer.closeText",message:"to close",description:"The explanatory text of the action for Escape key"}),closeKeyAriaLabel:(0,p.I)({id:"theme.SearchModal.footer.closeKeyAriaLabel",message:"Escape key",description:"The ARIA label for the Escape key button that close the modal"}),searchByText:(0,p.I)({id:"theme.SearchModal.footer.searchByText",message:"Search by",description:"The text explain that the search is making by Algolia"})},noResultsScreen:{noResultsText:(0,p.I)({id:"theme.SearchModal.noResultsScreen.noResultsText",message:"No results for",description:"The text explains that there are no results for the following search"}),suggestedQueryText:(0,p.I)({id:"theme.SearchModal.noResultsScreen.suggestedQueryText",message:"Try searching for",description:"The text for the suggested query when no results are found for the following search"}),reportMissingResultsText:(0,p.I)({id:"theme.SearchModal.noResultsScreen.reportMissingResultsText",message:"Believe this query should return results?",description:"The text for the question where the user thinks there are missing results"}),reportMissingResultsLinkText:(0,p.I)({id:"theme.SearchModal.noResultsScreen.reportMissingResultsLinkText",message:"Let us know.",description:"The text for the link to report missing results"})}},placeholder:(0,p.I)({id:"theme.SearchModal.placeholder",message:"Search docs",description:"The placeholder of the input of the DocSearch pop-up modal"})};let Ne=null;function Ue(e){let{hit:t,children:n}=e;return(0,d.jsx)($.Z,{to:t.url,children:n})}function Ye(e){let{state:t,onClose:n}=e;const o=(0,we.M)();return(0,d.jsx)($.Z,{to:o(t.query),onClick:n,children:(0,d.jsx)(p.Z,{id:"theme.SearchBar.seeAll",values:{count:t.context.nbHits},children:"See all {count} results"})})}function Ce(e){let{contextualSearch:t,externalUrlRegex:i,...s}=e;const{siteMetadata:a}=(0,pe.Z)(),p=(0,Se.l)(),c=function(){const{locale:e,tags:t}=(0,Ie._q)();return[`language:${e}`,t.map((e=>`docusaurus_tag:${e}`))]}(),l=s.searchParameters?.facetFilters??[],u=t?function(e,t){const n=e=>"string"==typeof e?[e]:e;return[...n(e),...n(t)]}(c,l):l,h={...s.searchParameters,facetFilters:u},f=(0,r.k6)(),y=(0,o.useRef)(null),m=(0,o.useRef)(null),[g,_]=(0,o.useState)(!1),[b,T]=(0,o.useState)(void 0),v=(0,o.useCallback)((()=>Ne?Promise.resolve():Promise.all([n.e(1426).then(n.bind(n,61426)),Promise.all([n.e(532),n.e(6945)]).then(n.bind(n,46945)),Promise.all([n.e(532),n.e(8894)]).then(n.bind(n,18894))]).then((e=>{let[{DocSearchModal:t}]=e;Ne=t}))),[]),P=(0,o.useCallback)((()=>{v().then((()=>{y.current=document.createElement("div"),document.body.insertBefore(y.current,document.body.firstChild),_(!0)}))}),[v,_]),E=(0,o.useCallback)((()=>{_(!1),y.current?.remove()}),[_]),R=(0,o.useCallback)((e=>{v().then((()=>{_(!0),T(e.key)}))}),[v,_,T]),A=(0,o.useRef)({navigate(e){let{itemUrl:t}=e;(0,ee.F)(i,t)?window.location.href=t:f.push(t)}}).current,k=(0,o.useRef)((e=>s.transformItems?s.transformItems(e):e.map((e=>({...e,url:p(e.url)}))))).current,w=(0,o.useMemo)((()=>e=>(0,d.jsx)(Ye,{...e,onClose:E})),[E]),S=(0,o.useCallback)((e=>(e.addAlgoliaAgent("docusaurus",a.docusaurusVersion),e)),[a.docusaurusVersion]);return function(e){var t=e.isOpen,n=e.onOpen,i=e.onClose,s=e.onInput,a=e.searchButtonRef;o.useEffect((function(){function e(e){var o;(27===e.keyCode&&t||"k"===(null===(o=e.key)||void 0===o?void 0:o.toLowerCase())&&(e.metaKey||e.ctrlKey)||!function(e){var t=e.target,n=t.tagName;return t.isContentEditable||"INPUT"===n||"SELECT"===n||"TEXTAREA"===n}(e)&&"/"===e.key&&!t)&&(e.preventDefault(),t?i():document.body.classList.contains("DocSearch--active")||document.body.classList.contains("DocSearch--active")||n()),a&&a.current===document.activeElement&&s&&/[a-zA-Z0-9]/.test(String.fromCharCode(e.keyCode))&&s(e)}return window.addEventListener("keydown",e),function(){window.removeEventListener("keydown",e)}}),[t,n,i,s,a])}({isOpen:g,onOpen:P,onClose:E,onInput:R,searchButtonRef:m}),(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(ke.Z,{children:(0,d.jsx)("link",{rel:"preconnect",href:`https://${s.appId}-dsn.algolia.net`,crossOrigin:"anonymous"})}),(0,d.jsx)(Ae,{onTouchStart:v,onFocus:v,onMouseOver:v,onClick:P,ref:m,translations:xe.button}),g&&Ne&&y.current&&(0,Oe.createPortal)((0,d.jsx)(Ne,{onClose:E,initialScrollY:window.scrollY,initialQuery:b,navigator:A,transformItems:k,hitComponent:Ue,transformSearchClient:S,...s.searchPagePath&&{resultsFooterComponent:w},...s,searchParameters:h,placeholder:xe.placeholder,translations:xe.modal}),y.current)]})}function Le(){const{siteConfig:e}=(0,pe.Z)();return(0,d.jsx)(Ce,{...e.themeConfig.algolia})}const De={navbarSearchContainer:"navbarSearchContainer_Bca1"};function qe(e){let{children:t,className:n}=e;return(0,d.jsx)("div",{className:(0,i.Z)(n,De.navbarSearchContainer),children:t})}var Fe=n(94104),je=n(53438);var Me=n(60373);const ze=e=>e.docs.find((t=>t.id===e.mainDocId));const Ve={default:se,localeDropdown:function(e){let{mobile:t,dropdownItemsBefore:n,dropdownItemsAfter:o,queryString:i="",...s}=e;const{i18n:{currentLocale:a,locales:c,localeConfigs:l}}=(0,pe.Z)(),u=(0,fe.l)(),{search:h,hash:f}=(0,r.TH)(),y=[...n,...c.map((e=>{const n=`${`pathname://${u.createUrl({locale:e,fullyQualified:!1})}`}${h}${f}${i}`;return{label:l[e].label,lang:l[e].htmlLang,to:n,target:"_self",autoAddBaseUrl:!1,className:e===a?t?"menu__link--active":"dropdown__link--active":""}})),...o],m=t?(0,p.I)({message:"Languages",id:"theme.navbar.mobileLanguageDropdown.label",description:"The label for the mobile language switcher dropdown"}):l[a].label;return(0,d.jsx)(he,{...s,mobile:t,label:(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(ye,{className:me}),m]}),items:y})},search:function(e){let{mobile:t,className:n}=e;return t?null:(0,d.jsx)(qe,{className:n,children:(0,d.jsx)(Le,{})})},dropdown:he,html:function(e){let{value:t,className:n,mobile:o=!1,isDropdownItem:s=!1}=e;const a=s?"li":"div";return(0,d.jsx)(a,{className:(0,i.Z)({navbar__item:!o&&!s,"menu__list-item":o},n),dangerouslySetInnerHTML:{__html:t}})},doc:function(e){let{docId:t,label:n,docsPluginId:o,...i}=e;const{activeDoc:s}=(0,Fe.Iw)(o),a=(0,je.vY)(t,o),r=s?.path===a?.path;return null===a||a.unlisted&&!r?null:(0,d.jsx)(se,{exact:!0,...i,isActive:()=>r||!!s?.sidebar&&s.sidebar===a.sidebar,label:n??a.id,to:a.path})},docSidebar:function(e){let{sidebarId:t,label:n,docsPluginId:o,...i}=e;const{activeDoc:s}=(0,Fe.Iw)(o),a=(0,je.oz)(t,o).link;if(!a)throw new Error(`DocSidebarNavbarItem: Sidebar with ID "${t}" doesn't have anything to be linked to.`);return(0,d.jsx)(se,{exact:!0,...i,isActive:()=>s?.sidebar===t,label:n??a.label,to:a.path})},docsVersion:function(e){let{label:t,to:n,docsPluginId:o,...i}=e;const s=(0,je.lO)(o)[0],a=t??s.label,r=n??(e=>e.docs.find((t=>t.id===e.mainDocId)))(s).path;return(0,d.jsx)(se,{...i,label:a,to:r})},docsVersionDropdown:function(e){let{mobile:t,docsPluginId:n,dropdownActiveClassDisabled:o,dropdownItemsBefore:i,dropdownItemsAfter:s,...a}=e;const{search:c,hash:l}=(0,r.TH)(),u=(0,Fe.Iw)(n),h=(0,Fe.gB)(n),{savePreferredVersionName:f}=(0,Me.J)(n),y=[...i,...h.map((e=>{const t=u.alternateDocVersions[e.name]??ze(e);return{label:e.label,to:`${t.path}${c}${l}`,isActive:()=>e===u.activeVersion,onClick:()=>f(e.name)}})),...s],m=(0,je.lO)(n)[0],g=t&&y.length>1?(0,p.I)({id:"theme.navbar.mobileVersionsDropdown.label",message:"Versions",description:"The label for the navbar versions dropdown on mobile view"}):m.label,_=t&&y.length>1?void 0:ze(m).path;return y.length<=1?(0,d.jsx)(se,{...a,mobile:t,label:g,to:_,isActive:o?()=>!1:void 0}):(0,d.jsx)(he,{...a,mobile:t,label:g,to:_,items:y,isActive:o?()=>!1:void 0})}};function Ge(e){let{type:t,...n}=e;const o=function(e,t){return e&&"default"!==e?e:"items"in t?"dropdown":"default"}(t,n),i=Ve[o];if(!i)throw new Error(`No NavbarItem component found for type "${t}".`);return(0,d.jsx)(i,{...n})}function Be(){const e=(0,I.e)(),t=(0,T.L)().navbar.items;return(0,d.jsx)("ul",{className:"menu__list",children:t.map(((t,n)=>(0,o.createElement)(Ge,{mobile:!0,...t,onClick:()=>e.toggle(),key:n})))})}function Je(e){return(0,d.jsx)("button",{...e,type:"button",className:"clean-btn navbar-sidebar__back",children:(0,d.jsx)(p.Z,{id:"theme.navbar.mobileSidebarSecondaryMenu.backButtonLabel",description:"The label of the back button to return to main menu, inside the mobile navbar sidebar secondary menu (notably used to display the docs sidebar)",children:"\u2190 Back to main menu"})})}function Qe(){const e=0===(0,T.L)().navbar.items.length,t=L();return(0,d.jsxs)(d.Fragment,{children:[!e&&(0,d.jsx)(Je,{onClick:()=>t.hide()}),t.content]})}function He(){const e=(0,I.e)();var t;return void 0===(t=e.shown)&&(t=!0),(0,o.useEffect)((()=>(document.body.style.overflow=t?"hidden":"visible",()=>{document.body.style.overflow="visible"})),[t]),e.shouldRender?(0,d.jsx)(D,{header:(0,d.jsx)(K,{}),primaryMenu:(0,d.jsx)(Be,{}),secondaryMenu:(0,d.jsx)(Qe,{})}):null}const We={navbarHideable:"navbarHideable_m1mJ",navbarHidden:"navbarHidden_jGov"};function Ke(e){return(0,d.jsx)("div",{role:"presentation",...e,className:(0,i.Z)("navbar-sidebar__backdrop",e.className)})}function $e(e){let{children:t}=e;const{navbar:{hideOnScroll:n,style:s}}=(0,T.L)(),a=(0,I.e)(),{navbarRef:r,isNavbarVisible:l}=function(e){const[t,n]=(0,o.useState)(e),i=(0,o.useRef)(!1),s=(0,o.useRef)(0),a=(0,o.useCallback)((e=>{null!==e&&(s.current=e.getBoundingClientRect().height)}),[]);return(0,O.RF)(((t,o)=>{let{scrollY:a}=t;if(!e)return;if(a<s.current)return void n(!0);if(i.current)return void(i.current=!1);const r=o?.scrollY,p=document.documentElement.scrollHeight-s.current,c=window.innerHeight;r&&a>=r?n(!1):a+c<p&&n(!0)})),(0,c.S)((t=>{if(!e)return;const o=t.location.hash;if(o?document.getElementById(o.substring(1)):void 0)return i.current=!0,void n(!1);n(!0)})),{navbarRef:a,isNavbarVisible:t}}(n);return(0,d.jsxs)("nav",{ref:r,"aria-label":(0,p.I)({id:"theme.NavBar.navAriaLabel",message:"Main",description:"The ARIA label for the main navigation"}),className:(0,i.Z)("navbar","navbar--fixed-top",n&&[We.navbarHideable,!l&&We.navbarHidden],{"navbar--dark":"dark"===s,"navbar--primary":"primary"===s,"navbar-sidebar--show":a.shown}),children:[t,(0,d.jsx)(Ke,{onClick:a.toggle}),(0,d.jsx)(He,{})]})}var Ze=n(18780);const Xe={errorBoundaryError:"errorBoundaryError_a6uf",errorBoundaryFallback:"errorBoundaryFallback_VBag"};function et(e){return(0,d.jsx)("button",{type:"button",...e,children:(0,d.jsx)(p.Z,{id:"theme.ErrorPageContent.tryAgain",description:"The label of the button to try again rendering when the React error boundary captures an error",children:"Try again"})})}function tt(e){let{error:t}=e;const n=(0,Ze.getErrorCausalChain)(t).map((e=>e.message)).join("\n\nCause:\n");return(0,d.jsx)("p",{className:Xe.errorBoundaryError,children:n})}class nt extends o.Component{componentDidCatch(e,t){throw this.props.onError(e,t)}render(){return this.props.children}}const ot="right";function it(e){let{width:t=30,height:n=30,className:o,...i}=e;return(0,d.jsx)("svg",{className:o,width:t,height:n,viewBox:"0 0 30 30","aria-hidden":"true",...i,children:(0,d.jsx)("path",{stroke:"currentColor",strokeLinecap:"round",strokeMiterlimit:"10",strokeWidth:"2",d:"M4 7h22M4 15h22M4 23h22"})})}function st(){const{toggle:e,shown:t}=(0,I.e)();return(0,d.jsx)("button",{onClick:e,"aria-label":(0,p.I)({id:"theme.docs.sidebar.toggleSidebarButtonAriaLabel",message:"Toggle navigation bar",description:"The ARIA label for hamburger menu button of mobile navigation"}),"aria-expanded":t,className:"navbar__toggle clean-btn",type:"button",children:(0,d.jsx)(it,{})})}const at={colorModeToggle:"colorModeToggle_DEke"};function rt(e){let{items:t}=e;return(0,d.jsx)(d.Fragment,{children:t.map(((e,t)=>(0,d.jsx)(nt,{onError:t=>new Error(`A theme navbar item failed to render.\nPlease double-check the following navbar item (themeConfig.navbar.items) of your Docusaurus config:\n${JSON.stringify(e,null,2)}`,{cause:t}),children:(0,d.jsx)(Ge,{...e})},t)))})}function pt(e){let{left:t,right:n}=e;return(0,d.jsxs)("div",{className:"navbar__inner",children:[(0,d.jsx)("div",{className:"navbar__items",children:t}),(0,d.jsx)("div",{className:"navbar__items navbar__items--right",children:n})]})}function ct(){const e=(0,I.e)(),t=(0,T.L)().navbar.items,[n,o]=function(e){function t(e){return"left"===(e.position??ot)}return[e.filter(t),e.filter((e=>!t(e)))]}(t),i=t.find((e=>"search"===e.type));return(0,d.jsx)(pt,{left:(0,d.jsxs)(d.Fragment,{children:[!e.disabled&&(0,d.jsx)(st,{}),(0,d.jsx)(H,{}),(0,d.jsx)(rt,{items:n})]}),right:(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(rt,{items:o}),(0,d.jsx)(J,{className:at.colorModeToggle}),!i&&(0,d.jsx)(qe,{children:(0,d.jsx)(Le,{})})]})})}function dt(){return(0,d.jsx)($e,{children:(0,d.jsx)(ct,{})})}function lt(e){let{item:t}=e;const{to:n,href:o,label:i,prependBaseUrlToHref:s,...a}=t,r=(0,Z.Z)(n),p=(0,Z.Z)(o,{forcePrependBaseUrl:!0});return(0,d.jsxs)($.Z,{className:"footer__link-item",...o?{href:s?p:o}:{to:r},...a,children:[i,o&&!(0,X.Z)(o)&&(0,d.jsx)(te.Z,{})]})}function ut(e){let{item:t}=e;return t.html?(0,d.jsx)("li",{className:"footer__item",dangerouslySetInnerHTML:{__html:t.html}}):(0,d.jsx)("li",{className:"footer__item",children:(0,d.jsx)(lt,{item:t})},t.href??t.to)}function ht(e){let{column:t}=e;return(0,d.jsxs)("div",{className:"col footer__col",children:[(0,d.jsx)("div",{className:"footer__title",children:t.title}),(0,d.jsx)("ul",{className:"footer__items clean-list",children:t.items.map(((e,t)=>(0,d.jsx)(ut,{item:e},t)))})]})}function ft(e){let{columns:t}=e;return(0,d.jsx)("div",{className:"row footer__links",children:t.map(((e,t)=>(0,d.jsx)(ht,{column:e},t)))})}function yt(){return(0,d.jsx)("span",{className:"footer__link-separator",children:"\xb7"})}function mt(e){let{item:t}=e;return t.html?(0,d.jsx)("span",{className:"footer__link-item",dangerouslySetInnerHTML:{__html:t.html}}):(0,d.jsx)(lt,{item:t})}function gt(e){let{links:t}=e;return(0,d.jsx)("div",{className:"footer__links text--center",children:(0,d.jsx)("div",{className:"footer__links",children:t.map(((e,n)=>(0,d.jsxs)(o.Fragment,{children:[(0,d.jsx)(mt,{item:e}),t.length!==n+1&&(0,d.jsx)(yt,{})]},n)))})})}function _t(e){let{links:t}=e;return function(e){return"title"in e[0]}(t)?(0,d.jsx)(ft,{columns:t}):(0,d.jsx)(gt,{links:t})}var bt=n(19965);const Tt={footerLogoLink:"footerLogoLink_BH7S"};function vt(e){let{logo:t}=e;const{withBaseUrl:n}=(0,Z.C)(),o={light:n(t.src),dark:n(t.srcDark??t.src)};return(0,d.jsx)(bt.Z,{className:(0,i.Z)("footer__logo",t.className),alt:t.alt,sources:o,width:t.width,height:t.height,style:t.style})}function Pt(e){let{logo:t}=e;return t.href?(0,d.jsx)($.Z,{href:t.href,className:Tt.footerLogoLink,target:t.target,children:(0,d.jsx)(vt,{logo:t})}):(0,d.jsx)(vt,{logo:t})}function Et(e){let{copyright:t}=e;return(0,d.jsx)("div",{className:"footer__copyright",dangerouslySetInnerHTML:{__html:t}})}function Rt(e){let{style:t,links:n,logo:o,copyright:s}=e;return(0,d.jsx)("footer",{className:(0,i.Z)("footer",{"footer--dark":"dark"===t}),children:(0,d.jsxs)("div",{className:"container container-fluid",children:[n,(o||s)&&(0,d.jsxs)("div",{className:"footer__bottom text--center",children:[o&&(0,d.jsx)("div",{className:"margin-bottom--sm",children:o}),s]})]})})}function At(){const{footer:e}=(0,T.L)();if(!e)return null;const{copyright:t,links:n,logo:o,style:i}=e;return(0,d.jsx)(Rt,{style:i,links:n&&n.length>0&&(0,d.jsx)(_t,{links:n}),logo:o&&(0,d.jsx)(Pt,{logo:o}),copyright:t&&(0,d.jsx)(Et,{copyright:t})})}const kt=o.memo(At),wt=(0,x.Qc)([q.S,v.pl,O.OC,Me.L5,a.VC,function(e){let{children:t}=e;return(0,d.jsx)(N.n2,{children:(0,d.jsx)(I.M,{children:(0,d.jsx)(Y,{children:t})})})}]);function St(e){let{children:t}=e;return(0,d.jsx)(wt,{children:t})}var It=n(92503);function Ot(e){let{error:t,tryAgain:n}=e;return(0,d.jsx)("main",{className:"container margin-vert--xl",children:(0,d.jsx)("div",{className:"row",children:(0,d.jsxs)("div",{className:"col col--6 col--offset-3",children:[(0,d.jsx)(It.Z,{as:"h1",className:"hero__title",children:(0,d.jsx)(p.Z,{id:"theme.ErrorPageContent.title",description:"The title of the fallback page when the page crashed",children:"This page crashed."})}),(0,d.jsx)("div",{className:"margin-vert--lg",children:(0,d.jsx)(et,{onClick:n,className:"button button--primary shadow--lw"})}),(0,d.jsx)("hr",{}),(0,d.jsx)("div",{className:"margin-vert--md",children:(0,d.jsx)(tt,{error:t})})]})})})}const xt={mainWrapper:"mainWrapper_z2l0"};function Nt(e){const{children:t,noFooter:n,wrapperClassName:o,title:r,description:p}=e;return(0,g.t)(),(0,d.jsxs)(St,{children:[(0,d.jsx)(a.d,{title:r,description:p}),(0,d.jsx)(b,{}),(0,d.jsx)(S,{}),(0,d.jsx)(dt,{}),(0,d.jsx)("div",{id:l,className:(0,i.Z)(m.k.wrapper.main,xt.mainWrapper,o),children:(0,d.jsx)(s.Z,{fallback:e=>(0,d.jsx)(Ot,{...e}),children:t})}),!n&&(0,d.jsx)(kt,{})]})}},21327:(e,t,n)=>{"use strict";n.d(t,{Z:()=>d});n(67294);var o=n(39960),i=n(44996),s=n(52263),a=n(86668),r=n(19965),p=n(85893);function c(e){let{logo:t,alt:n,imageClassName:o}=e;const s={light:(0,i.Z)(t.src),dark:(0,i.Z)(t.srcDark||t.src)},a=(0,p.jsx)(r.Z,{className:t.className,sources:s,height:t.height,width:t.width,alt:n,style:t.style});return o?(0,p.jsx)("div",{className:o,children:a}):a}function d(e){const{siteConfig:{title:t}}=(0,s.Z)(),{navbar:{title:n,logo:r}}=(0,a.L)(),{imageClassName:d,titleClassName:l,...u}=e,h=(0,i.Z)(r?.href||"/"),f=n?"":t,y=r?.alt??f;return(0,p.jsxs)(o.Z,{to:h,...u,...r?.target&&{target:r.target},children:[r&&(0,p.jsx)(c,{logo:r,alt:y,imageClassName:d}),null!=n&&(0,p.jsx)("b",{className:l,children:n})]})}},90197:(e,t,n)=>{"use strict";n.d(t,{Z:()=>s});n(67294);var o=n(35742),i=n(85893);function s(e){let{locale:t,version:n,tag:s}=e;const a=t;return(0,i.jsxs)(o.Z,{children:[t&&(0,i.jsx)("meta",{name:"docusaurus_locale",content:t}),n&&(0,i.jsx)("meta",{name:"docusaurus_version",content:n}),s&&(0,i.jsx)("meta",{name:"docusaurus_tag",content:s}),a&&(0,i.jsx)("meta",{name:"docsearch:language",content:a}),n&&(0,i.jsx)("meta",{name:"docsearch:version",content:n}),s&&(0,i.jsx)("meta",{name:"docsearch:docusaurus_tag",content:s})]})}},19965:(e,t,n)=>{"use strict";n.d(t,{Z:()=>d});var o=n(67294),i=n(90512),s=n(72389),a=n(92949);const r={themedComponent:"themedComponent_mlkZ","themedComponent--light":"themedComponent--light_NVdE","themedComponent--dark":"themedComponent--dark_xIcU"};var p=n(85893);function c(e){let{className:t,children:n}=e;const c=(0,s.Z)(),{colorMode:d}=(0,a.I)();return(0,p.jsx)(p.Fragment,{children:(c?"dark"===d?["dark"]:["light"]:["light","dark"]).map((e=>{const s=n({theme:e,className:(0,i.Z)(t,r.themedComponent,r[`themedComponent--${e}`])});return(0,p.jsx)(o.Fragment,{children:s},e)}))})}function d(e){const{sources:t,className:n,alt:o,...i}=e;return(0,p.jsx)(c,{className:n,children:e=>{let{theme:n,className:s}=e;return(0,p.jsx)("img",{src:t[n],alt:o,className:s,...i})}})}},86043:(e,t,n)=>{"use strict";n.d(t,{u:()=>c,z:()=>g});var o=n(67294),i=n(10412),s=n(20469),a=n(91442),r=n(85893);const p="ease-in-out";function c(e){let{initialState:t}=e;const[n,i]=(0,o.useState)(t??!1),s=(0,o.useCallback)((()=>{i((e=>!e))}),[]);return{collapsed:n,setCollapsed:i,toggleCollapsed:s}}const d={display:"none",overflow:"hidden",height:"0px"},l={display:"block",overflow:"visible",height:"auto"};function u(e,t){const n=t?d:l;e.style.display=n.display,e.style.overflow=n.overflow,e.style.height=n.height}function h(e){let{collapsibleRef:t,collapsed:n,animation:i}=e;const s=(0,o.useRef)(!1);(0,o.useEffect)((()=>{const e=t.current;function o(){const t=e.scrollHeight,n=i?.duration??function(e){if((0,a.n)())return 1;const t=e/36;return Math.round(10*(4+15*t**.25+t/5))}(t);return{transition:`height ${n}ms ${i?.easing??p}`,height:`${t}px`}}function r(){const t=o();e.style.transition=t.transition,e.style.height=t.height}if(!s.current)return u(e,n),void(s.current=!0);return e.style.willChange="height",function(){const t=requestAnimationFrame((()=>{n?(r(),requestAnimationFrame((()=>{e.style.height=d.height,e.style.overflow=d.overflow}))):(e.style.display="block",requestAnimationFrame((()=>{r()})))}));return()=>cancelAnimationFrame(t)}()}),[t,n,i])}function f(e){if(!i.default.canUseDOM)return e?d:l}function y(e){let{as:t="div",collapsed:n,children:i,animation:s,onCollapseTransitionEnd:a,className:p,disableSSRStyle:c}=e;const d=(0,o.useRef)(null);return h({collapsibleRef:d,collapsed:n,animation:s}),(0,r.jsx)(t,{ref:d,style:c?void 0:f(n),onTransitionEnd:e=>{"height"===e.propertyName&&(u(d.current,n),a?.(n))},className:p,children:i})}function m(e){let{collapsed:t,...n}=e;const[i,a]=(0,o.useState)(!t),[p,c]=(0,o.useState)(t);return(0,s.Z)((()=>{t||a(!0)}),[t]),(0,s.Z)((()=>{i&&c(t)}),[i,t]),i?(0,r.jsx)(y,{...n,collapsed:p}):null}function g(e){let{lazy:t,...n}=e;const o=t?m:y;return(0,r.jsx)(o,{...n})}},59689:(e,t,n)=>{"use strict";n.d(t,{nT:()=>y,pl:()=>f});var o=n(67294),i=n(72389),s=n(50012),a=n(902),r=n(86668),p=n(85893);const c=(0,s.WA)("docusaurus.announcement.dismiss"),d=(0,s.WA)("docusaurus.announcement.id"),l=()=>"true"===c.get(),u=e=>c.set(String(e)),h=o.createContext(null);function f(e){let{children:t}=e;const n=function(){const{announcementBar:e}=(0,r.L)(),t=(0,i.Z)(),[n,s]=(0,o.useState)((()=>!!t&&l()));(0,o.useEffect)((()=>{s(l())}),[]);const a=(0,o.useCallback)((()=>{u(!0),s(!0)}),[]);return(0,o.useEffect)((()=>{if(!e)return;const{id:t}=e;let n=d.get();"annoucement-bar"===n&&(n="announcement-bar");const o=t!==n;d.set(t),o&&u(!1),!o&&l()||s(!1)}),[e]),(0,o.useMemo)((()=>({isActive:!!e&&!n,close:a})),[e,n,a])}();return(0,p.jsx)(h.Provider,{value:n,children:t})}function y(){const e=(0,o.useContext)(h);if(!e)throw new a.i6("AnnouncementBarProvider");return e}},92949:(e,t,n)=>{"use strict";n.d(t,{I:()=>g,S:()=>m});var o=n(67294),i=n(10412),s=n(902),a=n(50012),r=n(86668),p=n(85893);const c=o.createContext(void 0),d="theme",l=(0,a.WA)(d),u={light:"light",dark:"dark"},h=e=>e===u.dark?u.dark:u.light,f=e=>i.default.canUseDOM?h(document.documentElement.getAttribute("data-theme")):h(e),y=e=>{l.set(h(e))};function m(e){let{children:t}=e;const n=function(){const{colorMode:{defaultMode:e,disableSwitch:t,respectPrefersColorScheme:n}}=(0,r.L)(),[i,s]=(0,o.useState)(f(e));(0,o.useEffect)((()=>{t&&l.del()}),[t]);const a=(0,o.useCallback)((function(t,o){void 0===o&&(o={});const{persist:i=!0}=o;t?(s(t),i&&y(t)):(s(n?window.matchMedia("(prefers-color-scheme: dark)").matches?u.dark:u.light:e),l.del())}),[n,e]);(0,o.useEffect)((()=>{document.documentElement.setAttribute("data-theme",h(i))}),[i]),(0,o.useEffect)((()=>{if(t)return;const e=e=>{if(e.key!==d)return;const t=l.get();null!==t&&a(h(t))};return window.addEventListener("storage",e),()=>window.removeEventListener("storage",e)}),[t,a]);const p=(0,o.useRef)(!1);return(0,o.useEffect)((()=>{if(t&&!n)return;const e=window.matchMedia("(prefers-color-scheme: dark)"),o=()=>{window.matchMedia("print").matches||p.current?p.current=window.matchMedia("print").matches:a(null)};return e.addListener(o),()=>e.removeListener(o)}),[a,t,n]),(0,o.useMemo)((()=>({colorMode:i,setColorMode:a,get isDarkTheme(){return i===u.dark},setLightTheme(){a(u.light)},setDarkTheme(){a(u.dark)}})),[i,a])}();return(0,p.jsx)(c.Provider,{value:n,children:t})}function g(){const e=(0,o.useContext)(c);if(null==e)throw new s.i6("ColorModeProvider","Please see https://docusaurus.io/docs/api/themes/configuration#use-color-mode.");return e}},60373:(e,t,n)=>{"use strict";n.d(t,{J:()=>b,L5:()=>g,Oh:()=>T});var o=n(67294),i=n(94104),s=n(29935),a=n(86668),r=n(53438),p=n(902),c=n(50012),d=n(85893);const l=e=>`docs-preferred-version-${e}`,u={save:(e,t,n)=>{(0,c.WA)(l(e),{persistence:t}).set(n)},read:(e,t)=>(0,c.WA)(l(e),{persistence:t}).get(),clear:(e,t)=>{(0,c.WA)(l(e),{persistence:t}).del()}},h=e=>Object.fromEntries(e.map((e=>[e,{preferredVersionName:null}])));const f=o.createContext(null);function y(){const e=(0,i._r)(),t=(0,a.L)().docs.versionPersistence,n=(0,o.useMemo)((()=>Object.keys(e)),[e]),[s,r]=(0,o.useState)((()=>h(n)));(0,o.useEffect)((()=>{r(function(e){let{pluginIds:t,versionPersistence:n,allDocsData:o}=e;function i(e){const t=u.read(e,n);return o[e].versions.some((e=>e.name===t))?{preferredVersionName:t}:(u.clear(e,n),{preferredVersionName:null})}return Object.fromEntries(t.map((e=>[e,i(e)])))}({allDocsData:e,versionPersistence:t,pluginIds:n}))}),[e,t,n]);return[s,(0,o.useMemo)((()=>({savePreferredVersion:function(e,n){u.save(e,t,n),r((t=>({...t,[e]:{preferredVersionName:n}})))}})),[t])]}function m(e){let{children:t}=e;const n=y();return(0,d.jsx)(f.Provider,{value:n,children:t})}function g(e){let{children:t}=e;return r.cE?(0,d.jsx)(m,{children:t}):(0,d.jsx)(d.Fragment,{children:t})}function _(){const e=(0,o.useContext)(f);if(!e)throw new p.i6("DocsPreferredVersionContextProvider");return e}function b(e){void 0===e&&(e=s.m);const t=(0,i.zh)(e),[n,a]=_(),{preferredVersionName:r}=n[e];return{preferredVersion:t.versions.find((e=>e.name===r))??null,savePreferredVersionName:(0,o.useCallback)((t=>{a.savePreferredVersion(e,t)}),[a,e])}}function T(){const e=(0,i._r)(),[t]=_();function n(n){const o=e[n],{preferredVersionName:i}=t[n];return o.versions.find((e=>e.name===i))??null}const o=Object.keys(e);return Object.fromEntries(o.map((e=>[e,n(e)])))}},1116:(e,t,n)=>{"use strict";n.d(t,{V:()=>c,b:()=>p});var o=n(67294),i=n(902),s=n(85893);const a=Symbol("EmptyContext"),r=o.createContext(a);function p(e){let{children:t,name:n,items:i}=e;const a=(0,o.useMemo)((()=>n&&i?{name:n,items:i}:null),[n,i]);return(0,s.jsx)(r.Provider,{value:a,children:t})}function c(){const e=(0,o.useContext)(r);if(e===a)throw new i.i6("DocsSidebarProvider");return e}},74477:(e,t,n)=>{"use strict";n.d(t,{E:()=>p,q:()=>r});var o=n(67294),i=n(902),s=n(85893);const a=o.createContext(null);function r(e){let{children:t,version:n}=e;return(0,s.jsx)(a.Provider,{value:n,children:t})}function p(){const e=(0,o.useContext)(a);if(null===e)throw new i.i6("DocsVersionProvider");return e}},93163:(e,t,n)=>{"use strict";n.d(t,{M:()=>u,e:()=>h});var o=n(67294),i=n(13102),s=n(87524),a=n(91980),r=n(86668),p=n(902),c=n(85893);const d=o.createContext(void 0);function l(){const e=function(){const e=(0,i.HY)(),{items:t}=(0,r.L)().navbar;return 0===t.length&&!e.component}(),t=(0,s.i)(),n=!e&&"mobile"===t,[p,c]=(0,o.useState)(!1);(0,a.Rb)((()=>{if(p)return c(!1),!1}));const d=(0,o.useCallback)((()=>{c((e=>!e))}),[]);return(0,o.useEffect)((()=>{"desktop"===t&&c(!1)}),[t]),(0,o.useMemo)((()=>({disabled:e,shouldRender:n,toggle:d,shown:p})),[e,n,d,p])}function u(e){let{children:t}=e;const n=l();return(0,c.jsx)(d.Provider,{value:n,children:t})}function h(){const e=o.useContext(d);if(void 0===e)throw new p.i6("NavbarMobileSidebarProvider");return e}},13102:(e,t,n)=>{"use strict";n.d(t,{HY:()=>p,Zo:()=>c,n2:()=>r});var o=n(67294),i=n(902),s=n(85893);const a=o.createContext(null);function r(e){let{children:t}=e;const n=(0,o.useState)({component:null,props:null});return(0,s.jsx)(a.Provider,{value:n,children:t})}function p(){const e=(0,o.useContext)(a);if(!e)throw new i.i6("NavbarSecondaryMenuContentProvider");return e[0]}function c(e){let{component:t,props:n}=e;const s=(0,o.useContext)(a);if(!s)throw new i.i6("NavbarSecondaryMenuContentProvider");const[,r]=s,p=(0,i.Ql)(n);return(0,o.useEffect)((()=>{r({component:t,props:p})}),[r,t,p]),(0,o.useEffect)((()=>()=>r({component:null,props:null})),[r]),null}},19727:(e,t,n)=>{"use strict";n.d(t,{h:()=>i,t:()=>s});var o=n(67294);const i="navigation-with-keyboard";function s(){(0,o.useEffect)((()=>{function e(e){"keydown"===e.type&&"Tab"===e.key&&document.body.classList.add(i),"mousedown"===e.type&&document.body.classList.remove(i)}return document.addEventListener("keydown",e),document.addEventListener("mousedown",e),()=>{document.body.classList.remove(i),document.removeEventListener("keydown",e),document.removeEventListener("mousedown",e)}}),[])}},66177:(e,t,n)=>{"use strict";n.d(t,{K:()=>r,M:()=>p});var o=n(67294),i=n(52263),s=n(91980);const a="q";function r(){return(0,s.Nc)(a)}function p(){const{siteConfig:{baseUrl:e,themeConfig:t}}=(0,i.Z)(),{algolia:{searchPagePath:n}}=t;return(0,o.useCallback)((t=>`${e}${n}?${a}=${encodeURIComponent(t)}`),[e,n])}},87524:(e,t,n)=>{"use strict";n.d(t,{i:()=>r});var o=n(67294),i=n(10412);const s={desktop:"desktop",mobile:"mobile",ssr:"ssr"},a=996;function r(){const[e,t]=(0,o.useState)((()=>"ssr"));return(0,o.useEffect)((()=>{function e(){t(function(){if(!i.default.canUseDOM)throw new Error("getWindowSize() should only be called after React hydration");return window.innerWidth>a?s.desktop:s.mobile}())}return e(),window.addEventListener("resize",e),()=>{window.removeEventListener("resize",e)}}),[]),e}},35281:(e,t,n)=>{"use strict";n.d(t,{k:()=>o});const o={page:{blogListPage:"blog-list-page",blogPostPage:"blog-post-page",blogTagsListPage:"blog-tags-list-page",blogTagPostListPage:"blog-tags-post-list-page",docsDocPage:"docs-doc-page",docsTagsListPage:"docs-tags-list-page",docsTagDocListPage:"docs-tags-doc-list-page",mdxPage:"mdx-page"},wrapper:{main:"main-wrapper",blogPages:"blog-wrapper",docsPages:"docs-wrapper",mdxPages:"mdx-wrapper"},common:{editThisPage:"theme-edit-this-page",lastUpdated:"theme-last-updated",backToTopButton:"theme-back-to-top-button",codeBlock:"theme-code-block",admonition:"theme-admonition",unlistedBanner:"theme-unlisted-banner",admonitionType:e=>`theme-admonition-${e}`},layout:{},docs:{docVersionBanner:"theme-doc-version-banner",docVersionBadge:"theme-doc-version-badge",docBreadcrumbs:"theme-doc-breadcrumbs",docMarkdown:"theme-doc-markdown",docTocMobile:"theme-doc-toc-mobile",docTocDesktop:"theme-doc-toc-desktop",docFooter:"theme-doc-footer",docFooterTagsRow:"theme-doc-footer-tags-row",docFooterEditMetaRow:"theme-doc-footer-edit-meta-row",docSidebarContainer:"theme-doc-sidebar-container",docSidebarMenu:"theme-doc-sidebar-menu",docSidebarItemCategory:"theme-doc-sidebar-item-category",docSidebarItemLink:"theme-doc-sidebar-item-link",docSidebarItemCategoryLevel:e=>`theme-doc-sidebar-item-category-level-${e}`,docSidebarItemLinkLevel:e=>`theme-doc-sidebar-item-link-level-${e}`},blog:{}}},91442:(e,t,n)=>{"use strict";function o(){return window.matchMedia("(prefers-reduced-motion: reduce)").matches}n.d(t,{n:()=>o})},53438:(e,t,n)=>{"use strict";n.d(t,{LM:()=>h,SN:()=>R,_F:()=>m,cE:()=>u,f:()=>_,lO:()=>v,oz:()=>P,s1:()=>T,vY:()=>E});var o=n(67294),i=n(16550),s=n(18790),a=n(94104),r=n(60373),p=n(74477),c=n(1116),d=n(67392),l=n(48596);const u=!!a._r;function h(e){return"link"!==e.type||e.unlisted?"category"===e.type?function(e){if(e.href&&!e.linkUnlisted)return e.href;for(const t of e.items){const e=h(t);if(e)return e}}(e):void 0:e.href}const f=(e,t)=>void 0!==e&&(0,l.Mg)(e,t),y=(e,t)=>e.some((e=>m(e,t)));function m(e,t){return"link"===e.type?f(e.href,t):"category"===e.type&&(f(e.href,t)||y(e.items,t))}function g(e,t){switch(e.type){case"category":return m(e,t)||e.items.some((e=>g(e,t)));case"link":return!e.unlisted||m(e,t);default:return!0}}function _(e,t){return(0,o.useMemo)((()=>e.filter((e=>g(e,t)))),[e,t])}function b(e){let{sidebarItems:t,pathname:n,onlyCategories:o=!1}=e;const i=[];return function e(t){for(const s of t)if("category"===s.type&&((0,l.Mg)(s.href,n)||e(s.items))||"link"===s.type&&(0,l.Mg)(s.href,n)){return o&&"category"!==s.type||i.unshift(s),!0}return!1}(t),i}function T(){const e=(0,c.V)(),{pathname:t}=(0,i.TH)(),n=(0,a.gA)()?.pluginData.breadcrumbs;return!1!==n&&e?b({sidebarItems:e.items,pathname:t}):null}function v(e){const{activeVersion:t}=(0,a.Iw)(e),{preferredVersion:n}=(0,r.J)(e),i=(0,a.yW)(e);return(0,o.useMemo)((()=>(0,d.j)([t,n,i].filter(Boolean))),[t,n,i])}function P(e,t){const n=v(t);return(0,o.useMemo)((()=>{const t=n.flatMap((e=>e.sidebars?Object.entries(e.sidebars):[])),o=t.find((t=>t[0]===e));if(!o)throw new Error(`Can't find any sidebar with id "${e}" in version${n.length>1?"s":""} ${n.map((e=>e.name)).join(", ")}".\nAvailable sidebar ids are:\n- ${t.map((e=>e[0])).join("\n- ")}`);return o[1]}),[e,n])}function E(e,t){const n=v(t);return(0,o.useMemo)((()=>{const t=n.flatMap((e=>e.docs)),o=t.find((t=>t.id===e));if(!o){if(n.flatMap((e=>e.draftIds)).includes(e))return null;throw new Error(`Couldn't find any doc with id "${e}" in version${n.length>1?"s":""} "${n.map((e=>e.name)).join(", ")}".\nAvailable doc ids are:\n- ${(0,d.j)(t.map((e=>e.id))).join("\n- ")}`)}return o}),[e,n])}function R(e){let{route:t}=e;const n=(0,i.TH)(),o=(0,p.E)(),a=t.routes,r=a.find((e=>(0,i.LX)(n.pathname,e)));if(!r)return null;const c=r.sidebar,d=c?o.docsSidebars[c]:void 0;return{docElement:(0,s.H)(a),sidebarName:c,sidebarItems:d}}},82128:(e,t,n)=>{"use strict";n.d(t,{p:()=>i});var o=n(52263);function i(e){const{siteConfig:t}=(0,o.Z)(),{title:n,titleDelimiter:i}=t;return e?.trim().length?`${e.trim()} ${i} ${n}`:n}},91980:(e,t,n)=>{"use strict";n.d(t,{Nc:()=>p,Rb:()=>a,_X:()=>r});var o=n(67294),i=n(16550),s=n(902);function a(e){!function(e){const t=(0,i.k6)(),n=(0,s.zX)(e);(0,o.useEffect)((()=>t.block(((e,t)=>n(e,t)))),[t,n])}(((t,n)=>{if("POP"===n)return e(t,n)}))}function r(e){return function(e){const t=(0,i.k6)();return(0,o.useSyncExternalStore)(t.listen,(()=>e(t)),(()=>e(t)))}((t=>null===e?null:new URLSearchParams(t.location.search).get(e)))}function p(e){const t=r(e)??"",n=function(){const e=(0,i.k6)();return(0,o.useCallback)(((t,n,o)=>{const i=new URLSearchParams(e.location.search);n?i.set(t,n):i.delete(t),(o?.push?e.push:e.replace)({search:i.toString()})}),[e])}();return[t,(0,o.useCallback)(((t,o)=>{n(e,t,o)}),[n,e])]}},67392:(e,t,n)=>{"use strict";function o(e,t){return void 0===t&&(t=(e,t)=>e===t),e.filter(((n,o)=>e.findIndex((e=>t(e,n)))!==o))}function i(e){return Array.from(new Set(e))}n.d(t,{j:()=>i,l:()=>o})},10833:(e,t,n)=>{"use strict";n.d(t,{FG:()=>h,d:()=>l,VC:()=>f});var o=n(67294),i=n(90512),s=n(35742),a=n(30226);function r(){const e=o.useContext(a._);if(!e)throw new Error("Unexpected: no Docusaurus route context found");return e}var p=n(44996),c=n(82128),d=n(85893);function l(e){let{title:t,description:n,keywords:o,image:i,children:a}=e;const r=(0,c.p)(t),{withBaseUrl:l}=(0,p.C)(),u=i?l(i,{absolute:!0}):void 0;return(0,d.jsxs)(s.Z,{children:[t&&(0,d.jsx)("title",{children:r}),t&&(0,d.jsx)("meta",{property:"og:title",content:r}),n&&(0,d.jsx)("meta",{name:"description",content:n}),n&&(0,d.jsx)("meta",{property:"og:description",content:n}),o&&(0,d.jsx)("meta",{name:"keywords",content:Array.isArray(o)?o.join(","):o}),u&&(0,d.jsx)("meta",{property:"og:image",content:u}),u&&(0,d.jsx)("meta",{name:"twitter:image",content:u}),a]})}const u=o.createContext(void 0);function h(e){let{className:t,children:n}=e;const a=o.useContext(u),r=(0,i.Z)(a,t);return(0,d.jsxs)(u.Provider,{value:r,children:[(0,d.jsx)(s.Z,{children:(0,d.jsx)("html",{className:r})}),n]})}function f(e){let{children:t}=e;const n=r(),o=`plugin-${n.plugin.name.replace(/docusaurus-(?:plugin|theme)-(?:content-)?/gi,"")}`;const s=`plugin-id-${n.plugin.id}`;return(0,d.jsx)(h,{className:(0,i.Z)(o,s),children:t})}},902:(e,t,n)=>{"use strict";n.d(t,{D9:()=>r,Qc:()=>d,Ql:()=>c,i6:()=>p,zX:()=>a});var o=n(67294),i=n(20469),s=n(85893);function a(e){const t=(0,o.useRef)(e);return(0,i.Z)((()=>{t.current=e}),[e]),(0,o.useCallback)((function(){return t.current(...arguments)}),[])}function r(e){const t=(0,o.useRef)();return(0,i.Z)((()=>{t.current=e})),t.current}class p extends Error{constructor(e,t){super(),this.name="ReactContextError",this.message=`Hook ${this.stack?.split("\n")[1]?.match(/at (?:\w+\.)?(?<name>\w+)/)?.groups.name??""} is called outside the <${e}>. ${t??""}`}}function c(e){const t=Object.entries(e);return t.sort(((e,t)=>e[0].localeCompare(t[0]))),(0,o.useMemo)((()=>e),t.flat())}function d(e){return t=>{let{children:n}=t;return(0,s.jsx)(s.Fragment,{children:e.reduceRight(((e,t)=>(0,s.jsx)(t,{children:e})),n)})}}},98022:(e,t,n)=>{"use strict";function o(e,t){return void 0!==e&&void 0!==t&&new RegExp(e,"gi").test(t)}n.d(t,{F:()=>o})},48596:(e,t,n)=>{"use strict";n.d(t,{Mg:()=>a,Ns:()=>r});var o=n(67294),i=n(723),s=n(52263);function a(e,t){const n=e=>(!e||e.endsWith("/")?e:`${e}/`)?.toLowerCase();return n(e)===n(t)}function r(){const{baseUrl:e}=(0,s.Z)().siteConfig;return(0,o.useMemo)((()=>function(e){let{baseUrl:t,routes:n}=e;function o(e){return e.path===t&&!0===e.exact}function i(e){return e.path===t&&!e.exact}return function e(t){if(0===t.length)return;return t.find(o)||e(t.filter(i).flatMap((e=>e.routes??[])))}(n)}({routes:i.Z,baseUrl:e})),[e])}},12466:(e,t,n)=>{"use strict";n.d(t,{Ct:()=>y,OC:()=>d,RF:()=>h,o5:()=>f});var o=n(67294),i=n(10412),s=n(72389),a=n(20469),r=n(902),p=n(85893);const c=o.createContext(void 0);function d(e){let{children:t}=e;const n=function(){const e=(0,o.useRef)(!0);return(0,o.useMemo)((()=>({scrollEventsEnabledRef:e,enableScrollEvents:()=>{e.current=!0},disableScrollEvents:()=>{e.current=!1}})),[])}();return(0,p.jsx)(c.Provider,{value:n,children:t})}function l(){const e=(0,o.useContext)(c);if(null==e)throw new r.i6("ScrollControllerProvider");return e}const u=()=>i.default.canUseDOM?{scrollX:window.pageXOffset,scrollY:window.pageYOffset}:null;function h(e,t){void 0===t&&(t=[]);const{scrollEventsEnabledRef:n}=l(),i=(0,o.useRef)(u()),s=(0,r.zX)(e);(0,o.useEffect)((()=>{const e=()=>{if(!n.current)return;const e=u();s(e,i.current),i.current=e},t={passive:!0};return e(),window.addEventListener("scroll",e,t),()=>window.removeEventListener("scroll",e,t)}),[s,n,...t])}function f(){const e=l(),t=function(){const e=(0,o.useRef)({elem:null,top:0}),t=(0,o.useCallback)((t=>{e.current={elem:t,top:t.getBoundingClientRect().top}}),[]),n=(0,o.useCallback)((()=>{const{current:{elem:t,top:n}}=e;if(!t)return{restored:!1};const o=t.getBoundingClientRect().top-n;return o&&window.scrollBy({left:0,top:o}),e.current={elem:null,top:0},{restored:0!==o}}),[]);return(0,o.useMemo)((()=>({save:t,restore:n})),[n,t])}(),n=(0,o.useRef)(void 0),i=(0,o.useCallback)((o=>{t.save(o),e.disableScrollEvents(),n.current=()=>{const{restored:o}=t.restore();if(n.current=void 0,o){const t=()=>{e.enableScrollEvents(),window.removeEventListener("scroll",t)};window.addEventListener("scroll",t)}else e.enableScrollEvents()}}),[e,t]);return(0,a.Z)((()=>{queueMicrotask((()=>n.current?.()))})),{blockElementScrollPositionUntilNextRender:i}}function y(){const e=(0,o.useRef)(null),t=(0,s.Z)()&&"smooth"===getComputedStyle(document.documentElement).scrollBehavior;return{startScroll:n=>{e.current=t?function(e){return window.scrollTo({top:e,behavior:"smooth"}),()=>{}}(n):function(e){let t=null;const n=document.documentElement.scrollTop>e;return function o(){const i=document.documentElement.scrollTop;(n&&i>e||!n&&i<e)&&(t=requestAnimationFrame(o),window.scrollTo(0,Math.floor(.85*(i-e))+e))}(),()=>t&&cancelAnimationFrame(t)}(n)},cancelScroll:()=>e.current?.()}}},43320:(e,t,n)=>{"use strict";n.d(t,{HX:()=>a,_q:()=>p,os:()=>r});var o=n(94104),i=n(52263),s=n(60373);const a="default";function r(e,t){return`docs-${e}-${t}`}function p(){const{i18n:e}=(0,i.Z)(),t=(0,o._r)(),n=(0,o.WS)(),p=(0,s.Oh)();const c=[a,...Object.keys(t).map((function(e){const o=n?.activePlugin.pluginId===e?n.activeVersion:void 0,i=p[e],s=t[e].versions.find((e=>e.isLast));return r(e,(o??i??s).name)}))];return{locale:e.currentLocale,tags:c}}},50012:(e,t,n)=>{"use strict";n.d(t,{Nk:()=>d,WA:()=>c});var o=n(67294);const i="localStorage";function s(e){let{key:t,oldValue:n,newValue:o,storage:i}=e;if(n===o)return;const s=document.createEvent("StorageEvent");s.initStorageEvent("storage",!1,!1,t,n,o,window.location.href,i),window.dispatchEvent(s)}function a(e){if(void 0===e&&(e=i),"undefined"==typeof window)throw new Error("Browser storage is not available on Node.js/Docusaurus SSR process.");if("none"===e)return null;try{return window[e]}catch(n){return t=n,r||(console.warn("Docusaurus browser storage is not available.\nPossible reasons: running Docusaurus in an iframe, in an incognito browser session, or using too strict browser privacy settings.",t),r=!0),null}var t}let r=!1;const p={get:()=>null,set:()=>{},del:()=>{},listen:()=>()=>{}};function c(e,t){if("undefined"==typeof window)return function(e){function t(){throw new Error(`Illegal storage API usage for storage key "${e}".\nDocusaurus storage APIs are not supposed to be called on the server-rendering process.\nPlease only call storage APIs in effects and event handlers.`)}return{get:t,set:t,del:t,listen:t}}(e);const n=a(t?.persistence);return null===n?p:{get:()=>{try{return n.getItem(e)}catch(t){return console.error(`Docusaurus storage error, can't get key=${e}`,t),null}},set:t=>{try{const o=n.getItem(e);n.setItem(e,t),s({key:e,oldValue:o,newValue:t,storage:n})}catch(o){console.error(`Docusaurus storage error, can't set ${e}=${t}`,o)}},del:()=>{try{const t=n.getItem(e);n.removeItem(e),s({key:e,oldValue:t,newValue:null,storage:n})}catch(t){console.error(`Docusaurus storage error, can't delete key=${e}`,t)}},listen:t=>{try{const o=o=>{o.storageArea===n&&o.key===e&&t(o)};return window.addEventListener("storage",o),()=>window.removeEventListener("storage",o)}catch(o){return console.error(`Docusaurus storage error, can't listen for changes of key=${e}`,o),()=>{}}}}}function d(e,t){const n=(0,o.useRef)((()=>null===e?p:c(e,t))).current(),i=(0,o.useCallback)((e=>"undefined"==typeof window?()=>{}:n.listen(e)),[n]);return[(0,o.useSyncExternalStore)(i,(()=>"undefined"==typeof window?null:n.get()),(()=>null)),n]}},94711:(e,t,n)=>{"use strict";n.d(t,{l:()=>a});var o=n(52263),i=n(16550),s=n(18780);function a(){const{siteConfig:{baseUrl:e,url:t,trailingSlash:n},i18n:{defaultLocale:a,currentLocale:r}}=(0,o.Z)(),{pathname:p}=(0,i.TH)(),c=(0,s.applyTrailingSlash)(p,{trailingSlash:n,baseUrl:e}),d=r===a?e:e.replace(`/${r}/`,"/"),l=c.replace(e,"");return{createUrl:function(e){let{locale:n,fullyQualified:o}=e;return`${o?t:""}${function(e){return e===a?`${d}`:`${d}${e}/`}(n)}${l}`}}}},85936:(e,t,n)=>{"use strict";n.d(t,{S:()=>a});var o=n(67294),i=n(16550),s=n(902);function a(e){const t=(0,i.TH)(),n=(0,s.D9)(t),a=(0,s.zX)(e);(0,o.useEffect)((()=>{n&&t!==n&&a({location:t,previousLocation:n})}),[a,t,n])}},86668:(e,t,n)=>{"use strict";n.d(t,{L:()=>i});var o=n(52263);function i(){return(0,o.Z)().siteConfig.themeConfig}},6278:(e,t,n)=>{"use strict";n.d(t,{L:()=>i});var o=n(52263);function i(){const{siteConfig:{themeConfig:e}}=(0,o.Z)();return e}},239:(e,t,n)=>{"use strict";n.d(t,{l:()=>r});var o=n(67294),i=n(98022),s=n(44996),a=n(6278);function r(){const{withBaseUrl:e}=(0,s.C)(),{algolia:{externalUrlRegex:t,replaceSearchResultPathname:n}}=(0,a.L)();return(0,o.useCallback)((o=>{const s=new URL(o);if((0,i.F)(t,s.href))return o;const a=`${s.pathname+s.hash}`;return e(function(e,t){return t?e.replaceAll(new RegExp(t.from,"g"),t.to):e}(a,n))}),[e,t,n])}},8802:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){const{trailingSlash:n,baseUrl:o}=t;if(e.startsWith("#"))return e;if(void 0===n)return e;const[i]=e.split(/[#?]/),s="/"===i||i===o?i:(a=i,n?function(e){return e.endsWith("/")?e:`${e}/`}(a):function(e){return e.endsWith("/")?e.slice(0,-1):e}(a));var a;return e.replace(i,s)}},54143:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getErrorCausalChain=void 0,t.getErrorCausalChain=function e(t){return t.cause?[t,...e(t.cause)]:[t]}},18780:function(e,t,n){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.getErrorCausalChain=t.applyTrailingSlash=t.blogPostContainerID=void 0,t.blogPostContainerID="__blog-post-container";var i=n(8802);Object.defineProperty(t,"applyTrailingSlash",{enumerable:!0,get:function(){return o(i).default}});var s=n(54143);Object.defineProperty(t,"getErrorCausalChain",{enumerable:!0,get:function(){return s.getErrorCausalChain}})},4750:function(e,t,n){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0});o(n(10412)).default.canUseDOM&&(window.Prism=window.Prism||{},window.Prism.manual=!0)},99318:(e,t,n)=>{"use strict";n.d(t,{lX:()=>T,q_:()=>k,ob:()=>h,PP:()=>S,Ep:()=>u});var o=n(83117);function i(e){return"/"===e.charAt(0)}function s(e,t){for(var n=t,o=n+1,i=e.length;o<i;n+=1,o+=1)e[n]=e[o];e.pop()}const a=function(e,t){void 0===t&&(t="");var n,o=e&&e.split("/")||[],a=t&&t.split("/")||[],r=e&&i(e),p=t&&i(t),c=r||p;if(e&&i(e)?a=o:o.length&&(a.pop(),a=a.concat(o)),!a.length)return"/";if(a.length){var d=a[a.length-1];n="."===d||".."===d||""===d}else n=!1;for(var l=0,u=a.length;u>=0;u--){var h=a[u];"."===h?s(a,u):".."===h?(s(a,u),l++):l&&(s(a,u),l--)}if(!c)for(;l--;l)a.unshift("..");!c||""===a[0]||a[0]&&i(a[0])||a.unshift("");var f=a.join("/");return n&&"/"!==f.substr(-1)&&(f+="/"),f};var r=n(38776);function p(e){return"/"===e.charAt(0)?e:"/"+e}function c(e){return"/"===e.charAt(0)?e.substr(1):e}function d(e,t){return function(e,t){return 0===e.toLowerCase().indexOf(t.toLowerCase())&&-1!=="/?#".indexOf(e.charAt(t.length))}(e,t)?e.substr(t.length):e}function l(e){return"/"===e.charAt(e.length-1)?e.slice(0,-1):e}function u(e){var t=e.pathname,n=e.search,o=e.hash,i=t||"/";return n&&"?"!==n&&(i+="?"===n.charAt(0)?n:"?"+n),o&&"#"!==o&&(i+="#"===o.charAt(0)?o:"#"+o),i}function h(e,t,n,i){var s;"string"==typeof e?(s=function(e){var t=e||"/",n="",o="",i=t.indexOf("#");-1!==i&&(o=t.substr(i),t=t.substr(0,i));var s=t.indexOf("?");return-1!==s&&(n=t.substr(s),t=t.substr(0,s)),{pathname:t,search:"?"===n?"":n,hash:"#"===o?"":o}}(e),s.state=t):(void 0===(s=(0,o.Z)({},e)).pathname&&(s.pathname=""),s.search?"?"!==s.search.charAt(0)&&(s.search="?"+s.search):s.search="",s.hash?"#"!==s.hash.charAt(0)&&(s.hash="#"+s.hash):s.hash="",void 0!==t&&void 0===s.state&&(s.state=t));try{s.pathname=decodeURI(s.pathname)}catch(r){throw r instanceof URIError?new URIError('Pathname "'+s.pathname+'" could not be decoded. This is likely caused by an invalid percent-encoding.'):r}return n&&(s.key=n),i?s.pathname?"/"!==s.pathname.charAt(0)&&(s.pathname=a(s.pathname,i.pathname)):s.pathname=i.pathname:s.pathname||(s.pathname="/"),s}function f(){var e=null;var t=[];return{setPrompt:function(t){return e=t,function(){e===t&&(e=null)}},confirmTransitionTo:function(t,n,o,i){if(null!=e){var s="function"==typeof e?e(t,n):e;"string"==typeof s?"function"==typeof o?o(s,i):i(!0):i(!1!==s)}else i(!0)},appendListener:function(e){var n=!0;function o(){n&&e.apply(void 0,arguments)}return t.push(o),function(){n=!1,t=t.filter((function(e){return e!==o}))}},notifyListeners:function(){for(var e=arguments.length,n=new Array(e),o=0;o<e;o++)n[o]=arguments[o];t.forEach((function(e){return e.apply(void 0,n)}))}}}var y=!("undefined"==typeof window||!window.document||!window.document.createElement);function m(e,t){t(window.confirm(e))}var g="popstate",_="hashchange";function b(){try{return window.history.state||{}}catch(e){return{}}}function T(e){void 0===e&&(e={}),y||(0,r.Z)(!1);var t,n=window.history,i=(-1===(t=window.navigator.userAgent).indexOf("Android 2.")&&-1===t.indexOf("Android 4.0")||-1===t.indexOf("Mobile Safari")||-1!==t.indexOf("Chrome")||-1!==t.indexOf("Windows Phone"))&&window.history&&"pushState"in window.history,s=!(-1===window.navigator.userAgent.indexOf("Trident")),a=e,c=a.forceRefresh,T=void 0!==c&&c,v=a.getUserConfirmation,P=void 0===v?m:v,E=a.keyLength,R=void 0===E?6:E,A=e.basename?l(p(e.basename)):"";function k(e){var t=e||{},n=t.key,o=t.state,i=window.location,s=i.pathname+i.search+i.hash;return A&&(s=d(s,A)),h(s,o,n)}function w(){return Math.random().toString(36).substr(2,R)}var S=f();function I(e){(0,o.Z)(M,e),M.length=n.length,S.notifyListeners(M.location,M.action)}function O(e){(function(e){return void 0===e.state&&-1===navigator.userAgent.indexOf("CriOS")})(e)||U(k(e.state))}function x(){U(k(b()))}var N=!1;function U(e){if(N)N=!1,I();else{S.confirmTransitionTo(e,"POP",P,(function(t){t?I({action:"POP",location:e}):function(e){var t=M.location,n=C.indexOf(t.key);-1===n&&(n=0);var o=C.indexOf(e.key);-1===o&&(o=0);var i=n-o;i&&(N=!0,D(i))}(e)}))}}var Y=k(b()),C=[Y.key];function L(e){return A+u(e)}function D(e){n.go(e)}var q=0;function F(e){1===(q+=e)&&1===e?(window.addEventListener(g,O),s&&window.addEventListener(_,x)):0===q&&(window.removeEventListener(g,O),s&&window.removeEventListener(_,x))}var j=!1;var M={length:n.length,action:"POP",location:Y,createHref:L,push:function(e,t){var o="PUSH",s=h(e,t,w(),M.location);S.confirmTransitionTo(s,o,P,(function(e){if(e){var t=L(s),a=s.key,r=s.state;if(i)if(n.pushState({key:a,state:r},null,t),T)window.location.href=t;else{var p=C.indexOf(M.location.key),c=C.slice(0,p+1);c.push(s.key),C=c,I({action:o,location:s})}else window.location.href=t}}))},replace:function(e,t){var o="REPLACE",s=h(e,t,w(),M.location);S.confirmTransitionTo(s,o,P,(function(e){if(e){var t=L(s),a=s.key,r=s.state;if(i)if(n.replaceState({key:a,state:r},null,t),T)window.location.replace(t);else{var p=C.indexOf(M.location.key);-1!==p&&(C[p]=s.key),I({action:o,location:s})}else window.location.replace(t)}}))},go:D,goBack:function(){D(-1)},goForward:function(){D(1)},block:function(e){void 0===e&&(e=!1);var t=S.setPrompt(e);return j||(F(1),j=!0),function(){return j&&(j=!1,F(-1)),t()}},listen:function(e){var t=S.appendListener(e);return F(1),function(){F(-1),t()}}};return M}var v="hashchange",P={hashbang:{encodePath:function(e){return"!"===e.charAt(0)?e:"!/"+c(e)},decodePath:function(e){return"!"===e.charAt(0)?e.substr(1):e}},noslash:{encodePath:c,decodePath:p},slash:{encodePath:p,decodePath:p}};function E(e){var t=e.indexOf("#");return-1===t?e:e.slice(0,t)}function R(){var e=window.location.href,t=e.indexOf("#");return-1===t?"":e.substring(t+1)}function A(e){window.location.replace(E(window.location.href)+"#"+e)}function k(e){void 0===e&&(e={}),y||(0,r.Z)(!1);var t=window.history,n=(window.navigator.userAgent.indexOf("Firefox"),e),i=n.getUserConfirmation,s=void 0===i?m:i,a=n.hashType,c=void 0===a?"slash":a,g=e.basename?l(p(e.basename)):"",_=P[c],b=_.encodePath,T=_.decodePath;function k(){var e=T(R());return g&&(e=d(e,g)),h(e)}var w=f();function S(e){(0,o.Z)(j,e),j.length=t.length,w.notifyListeners(j.location,j.action)}var I=!1,O=null;function x(){var e,t,n=R(),o=b(n);if(n!==o)A(o);else{var i=k(),a=j.location;if(!I&&(t=i,(e=a).pathname===t.pathname&&e.search===t.search&&e.hash===t.hash))return;if(O===u(i))return;O=null,function(e){if(I)I=!1,S();else{var t="POP";w.confirmTransitionTo(e,t,s,(function(n){n?S({action:t,location:e}):function(e){var t=j.location,n=C.lastIndexOf(u(t));-1===n&&(n=0);var o=C.lastIndexOf(u(e));-1===o&&(o=0);var i=n-o;i&&(I=!0,L(i))}(e)}))}}(i)}}var N=R(),U=b(N);N!==U&&A(U);var Y=k(),C=[u(Y)];function L(e){t.go(e)}var D=0;function q(e){1===(D+=e)&&1===e?window.addEventListener(v,x):0===D&&window.removeEventListener(v,x)}var F=!1;var j={length:t.length,action:"POP",location:Y,createHref:function(e){var t=document.querySelector("base"),n="";return t&&t.getAttribute("href")&&(n=E(window.location.href)),n+"#"+b(g+u(e))},push:function(e,t){var n="PUSH",o=h(e,void 0,void 0,j.location);w.confirmTransitionTo(o,n,s,(function(e){if(e){var t=u(o),i=b(g+t);if(R()!==i){O=t,function(e){window.location.hash=e}(i);var s=C.lastIndexOf(u(j.location)),a=C.slice(0,s+1);a.push(t),C=a,S({action:n,location:o})}else S()}}))},replace:function(e,t){var n="REPLACE",o=h(e,void 0,void 0,j.location);w.confirmTransitionTo(o,n,s,(function(e){if(e){var t=u(o),i=b(g+t);R()!==i&&(O=t,A(i));var s=C.indexOf(u(j.location));-1!==s&&(C[s]=t),S({action:n,location:o})}}))},go:L,goBack:function(){L(-1)},goForward:function(){L(1)},block:function(e){void 0===e&&(e=!1);var t=w.setPrompt(e);return F||(q(1),F=!0),function(){return F&&(F=!1,q(-1)),t()}},listen:function(e){var t=w.appendListener(e);return q(1),function(){q(-1),t()}}};return j}function w(e,t,n){return Math.min(Math.max(e,t),n)}function S(e){void 0===e&&(e={});var t=e,n=t.getUserConfirmation,i=t.initialEntries,s=void 0===i?["/"]:i,a=t.initialIndex,r=void 0===a?0:a,p=t.keyLength,c=void 0===p?6:p,d=f();function l(e){(0,o.Z)(T,e),T.length=T.entries.length,d.notifyListeners(T.location,T.action)}function y(){return Math.random().toString(36).substr(2,c)}var m=w(r,0,s.length-1),g=s.map((function(e){return h(e,void 0,"string"==typeof e?y():e.key||y())})),_=u;function b(e){var t=w(T.index+e,0,T.entries.length-1),o=T.entries[t];d.confirmTransitionTo(o,"POP",n,(function(e){e?l({action:"POP",location:o,index:t}):l()}))}var T={length:g.length,action:"POP",location:g[m],index:m,entries:g,createHref:_,push:function(e,t){var o="PUSH",i=h(e,t,y(),T.location);d.confirmTransitionTo(i,o,n,(function(e){if(e){var t=T.index+1,n=T.entries.slice(0);n.length>t?n.splice(t,n.length-t,i):n.push(i),l({action:o,location:i,index:t,entries:n})}}))},replace:function(e,t){var o="REPLACE",i=h(e,t,y(),T.location);d.confirmTransitionTo(i,o,n,(function(e){e&&(T.entries[T.index]=i,l({action:o,location:i}))}))},go:b,goBack:function(){b(-1)},goForward:function(){b(1)},canGo:function(e){var t=T.index+e;return t>=0&&t<T.entries.length},block:function(e){return void 0===e&&(e=!1),d.setPrompt(e)},listen:function(e){return d.appendListener(e)}};return T}},8679:(e,t,n)=>{"use strict";var o=n(59864),i={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},s={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},a={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},r={};function p(e){return o.isMemo(e)?a:r[e.$$typeof]||i}r[o.ForwardRef]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},r[o.Memo]=a;var c=Object.defineProperty,d=Object.getOwnPropertyNames,l=Object.getOwnPropertySymbols,u=Object.getOwnPropertyDescriptor,h=Object.getPrototypeOf,f=Object.prototype;e.exports=function e(t,n,o){if("string"!=typeof n){if(f){var i=h(n);i&&i!==f&&e(t,i,o)}var a=d(n);l&&(a=a.concat(l(n)));for(var r=p(t),y=p(n),m=0;m<a.length;++m){var g=a[m];if(!(s[g]||o&&o[g]||y&&y[g]||r&&r[g])){var _=u(n,g);try{c(t,g,_)}catch(b){}}}}return t}},41143:e=>{"use strict";e.exports=function(e,t,n,o,i,s,a,r){if(!e){var p;if(void 0===t)p=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var c=[n,o,i,s,a,r],d=0;(p=new Error(t.replace(/%s/g,(function(){return c[d++]})))).name="Invariant Violation"}throw p.framesToPop=1,p}}},5826:e=>{e.exports=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)}},41304:(e,t,n)=>{"use strict";n.r(t)},32497:(e,t,n)=>{"use strict";n.r(t)},52295:(e,t,n)=>{"use strict";n.r(t)},74865:function(e,t,n){var o,i;o=function(){var e,t,n={version:"0.2.0"},o=n.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(e,t,n){return e<t?t:e>n?n:e}function s(e){return 100*(-1+e)}function a(e,t,n){var i;return(i="translate3d"===o.positionUsing?{transform:"translate3d("+s(e)+"%,0,0)"}:"translate"===o.positionUsing?{transform:"translate("+s(e)+"%,0)"}:{"margin-left":s(e)+"%"}).transition="all "+t+"ms "+n,i}n.configure=function(e){var t,n;for(t in e)void 0!==(n=e[t])&&e.hasOwnProperty(t)&&(o[t]=n);return this},n.status=null,n.set=function(e){var t=n.isStarted();e=i(e,o.minimum,1),n.status=1===e?null:e;var s=n.render(!t),c=s.querySelector(o.barSelector),d=o.speed,l=o.easing;return s.offsetWidth,r((function(t){""===o.positionUsing&&(o.positionUsing=n.getPositioningCSS()),p(c,a(e,d,l)),1===e?(p(s,{transition:"none",opacity:1}),s.offsetWidth,setTimeout((function(){p(s,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){n.remove(),t()}),d)}),d)):setTimeout(t,d)})),this},n.isStarted=function(){return"number"==typeof n.status},n.start=function(){n.status||n.set(0);var e=function(){setTimeout((function(){n.status&&(n.trickle(),e())}),o.trickleSpeed)};return o.trickle&&e(),this},n.done=function(e){return e||n.status?n.inc(.3+.5*Math.random()).set(1):this},n.inc=function(e){var t=n.status;return t?("number"!=typeof e&&(e=(1-t)*i(Math.random()*t,.1,.95)),t=i(t+e,0,.994),n.set(t)):n.start()},n.trickle=function(){return n.inc(Math.random()*o.trickleRate)},e=0,t=0,n.promise=function(o){return o&&"resolved"!==o.state()?(0===t&&n.start(),e++,t++,o.always((function(){0==--t?(e=0,n.done()):n.set((e-t)/e)})),this):this},n.render=function(e){if(n.isRendered())return document.getElementById("nprogress");d(document.documentElement,"nprogress-busy");var t=document.createElement("div");t.id="nprogress",t.innerHTML=o.template;var i,a=t.querySelector(o.barSelector),r=e?"-100":s(n.status||0),c=document.querySelector(o.parent);return p(a,{transition:"all 0 linear",transform:"translate3d("+r+"%,0,0)"}),o.showSpinner||(i=t.querySelector(o.spinnerSelector))&&h(i),c!=document.body&&d(c,"nprogress-custom-parent"),c.appendChild(t),t},n.remove=function(){l(document.documentElement,"nprogress-busy"),l(document.querySelector(o.parent),"nprogress-custom-parent");var e=document.getElementById("nprogress");e&&h(e)},n.isRendered=function(){return!!document.getElementById("nprogress")},n.getPositioningCSS=function(){var e=document.body.style,t="WebkitTransform"in e?"Webkit":"MozTransform"in e?"Moz":"msTransform"in e?"ms":"OTransform"in e?"O":"";return t+"Perspective"in e?"translate3d":t+"Transform"in e?"translate":"margin"};var r=function(){var e=[];function t(){var n=e.shift();n&&n(t)}return function(n){e.push(n),1==e.length&&t()}}(),p=function(){var e=["Webkit","O","Moz","ms"],t={};function n(e){return e.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(e,t){return t.toUpperCase()}))}function o(t){var n=document.body.style;if(t in n)return t;for(var o,i=e.length,s=t.charAt(0).toUpperCase()+t.slice(1);i--;)if((o=e[i]+s)in n)return o;return t}function i(e){return e=n(e),t[e]||(t[e]=o(e))}function s(e,t,n){t=i(t),e.style[t]=n}return function(e,t){var n,o,i=arguments;if(2==i.length)for(n in t)void 0!==(o=t[n])&&t.hasOwnProperty(n)&&s(e,n,o);else s(e,i[1],i[2])}}();function c(e,t){return("string"==typeof e?e:u(e)).indexOf(" "+t+" ")>=0}function d(e,t){var n=u(e),o=n+t;c(n,t)||(e.className=o.substring(1))}function l(e,t){var n,o=u(e);c(e,t)&&(n=o.replace(" "+t+" "," "),e.className=n.substring(1,n.length-1))}function u(e){return(" "+(e.className||"")+" ").replace(/\s+/gi," ")}function h(e){e&&e.parentNode&&e.parentNode.removeChild(e)}return n},void 0===(i="function"==typeof o?o.call(t,n,t,e):o)||(e.exports=i)},57874:()=>{!function(e){var t="\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b",n={pattern:/(^(["']?)\w+\2)[ \t]+\S.*/,lookbehind:!0,alias:"punctuation",inside:null},o={bash:n,environment:{pattern:RegExp("\\$"+t),alias:"constant"},variable:[{pattern:/\$?\(\([\s\S]+?\)\)/,greedy:!0,inside:{variable:[{pattern:/(^\$\(\([\s\S]+)\)\)/,lookbehind:!0},/^\$\(\(/],number:/\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,operator:/--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,punctuation:/\(\(?|\)\)?|,|;/}},{pattern:/\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,greedy:!0,inside:{variable:/^\$\(|^`|\)$|`$/}},{pattern:/\$\{[^}]+\}/,greedy:!0,inside:{operator:/:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,punctuation:/[\[\]]/,environment:{pattern:RegExp("(\\{)"+t),lookbehind:!0,alias:"constant"}}},/\$(?:\w+|[#?*!@$])/],entity:/\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/};e.languages.bash={shebang:{pattern:/^#!\s*\/.*/,alias:"important"},comment:{pattern:/(^|[^"{\\$])#.*/,lookbehind:!0},"function-name":[{pattern:/(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,lookbehind:!0,alias:"function"},{pattern:/\b[\w-]+(?=\s*\(\s*\)\s*\{)/,alias:"function"}],"for-or-select":{pattern:/(\b(?:for|select)\s+)\w+(?=\s+in\s)/,alias:"variable",lookbehind:!0},"assign-left":{pattern:/(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,inside:{environment:{pattern:RegExp("(^|[\\s;|&]|[<>]\\()"+t),lookbehind:!0,alias:"constant"}},alias:"variable",lookbehind:!0},parameter:{pattern:/(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,alias:"variable",lookbehind:!0},string:[{pattern:/((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,lookbehind:!0,greedy:!0,inside:o},{pattern:/((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,lookbehind:!0,greedy:!0,inside:{bash:n}},{pattern:/(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,lookbehind:!0,greedy:!0,inside:o},{pattern:/(^|[^$\\])'[^']*'/,lookbehind:!0,greedy:!0},{pattern:/\$'(?:[^'\\]|\\[\s\S])*'/,greedy:!0,inside:{entity:o.entity}}],environment:{pattern:RegExp("\\$?"+t),alias:"constant"},variable:o.variable,function:{pattern:/(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,lookbehind:!0},keyword:{pattern:/(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,lookbehind:!0},builtin:{pattern:/(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,lookbehind:!0,alias:"class-name"},boolean:{pattern:/(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,lookbehind:!0},"file-descriptor":{pattern:/\B&\d\b/,alias:"important"},operator:{pattern:/\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,inside:{"file-descriptor":{pattern:/^\d/,alias:"important"}}},punctuation:/\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,number:{pattern:/(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,lookbehind:!0}},n.inside=e.languages.bash;for(var i=["comment","function-name","for-or-select","assign-left","parameter","string","environment","function","keyword","builtin","boolean","file-descriptor","operator","punctuation","number"],s=o.variable[1].inside,a=0;a<i.length;a++)s[i[a]]=e.languages.bash[i[a]];e.languages.sh=e.languages.bash,e.languages.shell=e.languages.bash}(Prism)},74277:()=>{Prism.languages.json={property:{pattern:/(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,lookbehind:!0,greedy:!0},string:{pattern:/(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,lookbehind:!0,greedy:!0},comment:{pattern:/\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,greedy:!0},number:/-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,punctuation:/[{}[\],]/,operator:/:/,boolean:/\b(?:false|true)\b/,null:{pattern:/\bnull\b/,alias:"keyword"}},Prism.languages.webmanifest=Prism.languages.json},32334:()=>{!function(e){e.languages.kotlin=e.languages.extend("clike",{keyword:{pattern:/(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,lookbehind:!0},function:[{pattern:/(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,greedy:!0},{pattern:/(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,lookbehind:!0,greedy:!0}],number:/\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,operator:/\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/}),delete e.languages.kotlin["class-name"];var t={"interpolation-punctuation":{pattern:/^\$\{?|\}$/,alias:"punctuation"},expression:{pattern:/[\s\S]+/,inside:e.languages.kotlin}};e.languages.insertBefore("kotlin","string",{"string-literal":[{pattern:/"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,alias:"multiline",inside:{interpolation:{pattern:/\$(?:[a-z_]\w*|\{[^{}]*\})/i,inside:t},string:/[\s\S]+/}},{pattern:/"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,alias:"singleline",inside:{interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,lookbehind:!0,inside:t},string:/[\s\S]+/}}],char:{pattern:/'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,greedy:!0}}),delete e.languages.kotlin.string,e.languages.insertBefore("kotlin","keyword",{annotation:{pattern:/\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,alias:"builtin"}}),e.languages.insertBefore("kotlin","function",{label:{pattern:/\b\w+@|@\w+\b/,alias:"symbol"}}),e.languages.kt=e.languages.kotlin,e.languages.kts=e.languages.kotlin}(Prism)},96854:()=>{!function(e){function t(e,t){return"___"+e.toUpperCase()+t+"___"}Object.defineProperties(e.languages["markup-templating"]={},{buildPlaceholders:{value:function(n,o,i,s){if(n.language===o){var a=n.tokenStack=[];n.code=n.code.replace(i,(function(e){if("function"==typeof s&&!s(e))return e;for(var i,r=a.length;-1!==n.code.indexOf(i=t(o,r));)++r;return a[r]=e,i})),n.grammar=e.languages.markup}}},tokenizePlaceholders:{value:function(n,o){if(n.language===o&&n.tokenStack){n.grammar=e.languages[o];var i=0,s=Object.keys(n.tokenStack);!function a(r){for(var p=0;p<r.length&&!(i>=s.length);p++){var c=r[p];if("string"==typeof c||c.content&&"string"==typeof c.content){var d=s[i],l=n.tokenStack[d],u="string"==typeof c?c:c.content,h=t(o,d),f=u.indexOf(h);if(f>-1){++i;var y=u.substring(0,f),m=new e.Token(o,e.tokenize(l,n.grammar),"language-"+o,l),g=u.substring(f+h.length),_=[];y&&_.push.apply(_,a([y])),_.push(m),g&&_.push.apply(_,a([g])),"string"==typeof c?r.splice.apply(r,[p,1].concat(_)):c.content=_}}else c.content&&a(c.content)}return r}(n.tokens)}}}})}(Prism)},37345:()=>{!function(e){var t=/\b(?:bool|bytes|double|s?fixed(?:32|64)|float|[su]?int(?:32|64)|string)\b/;e.languages.protobuf=e.languages.extend("clike",{"class-name":[{pattern:/(\b(?:enum|extend|message|service)\s+)[A-Za-z_]\w*(?=\s*\{)/,lookbehind:!0},{pattern:/(\b(?:rpc\s+\w+|returns)\s*\(\s*(?:stream\s+)?)\.?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*(?=\s*\))/,lookbehind:!0}],keyword:/\b(?:enum|extend|extensions|import|message|oneof|option|optional|package|public|repeated|required|reserved|returns|rpc(?=\s+\w)|service|stream|syntax|to)\b(?!\s*=\s*\d)/,function:/\b[a-z_]\w*(?=\s*\()/i}),e.languages.insertBefore("protobuf","operator",{map:{pattern:/\bmap<\s*[\w.]+\s*,\s*[\w.]+\s*>(?=\s+[a-z_]\w*\s*[=;])/i,alias:"class-name",inside:{punctuation:/[<>.,]/,builtin:t}},builtin:t,"positional-class-name":{pattern:/(?:\b|\B\.)[a-z_]\w*(?:\.[a-z_]\w*)*(?=\s+[a-z_]\w*\s*[=;])/i,alias:"class-name",inside:{punctuation:/\./}},annotation:{pattern:/(\[\s*)[a-z_]\w*(?=\s*=)/i,lookbehind:!0}})}(Prism)},30142:(e,t,n)=>{var o={"./prism-bash":57874,"./prism-json":74277,"./prism-kotlin":32334,"./prism-protobuf":37345};function i(e){var t=s(e);return n(t)}function s(e){if(!n.o(o,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return o[e]}i.keys=function(){return Object.keys(o)},i.resolve=s,e.exports=i,i.id=30142},92703:(e,t,n)=>{"use strict";var o=n(50414);function i(){}function s(){}s.resetWarningCache=i,e.exports=function(){function e(e,t,n,i,s,a){if(a!==o){var r=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw r.name="Invariant Violation",r}}function t(){return e}e.isRequired=e;var n={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:s,resetWarningCache:i};return n.PropTypes=n,n}},45697:(e,t,n)=>{e.exports=n(92703)()},50414:e=>{"use strict";e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},64448:(e,t,n)=>{"use strict";var o=n(67294),i=n(63840);function s(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var a=new Set,r={};function p(e,t){c(e,t),c(e+"Capture",t)}function c(e,t){for(r[e]=t,e=0;e<t.length;e++)a.add(t[e])}var d=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement),l=Object.prototype.hasOwnProperty,u=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,h={},f={};function y(e,t,n,o,i,s,a){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=o,this.attributeNamespace=i,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=s,this.removeEmptyString=a}var m={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){m[e]=new y(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];m[t]=new y(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){m[e]=new y(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){m[e]=new y(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){m[e]=new y(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){m[e]=new y(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){m[e]=new y(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){m[e]=new y(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){m[e]=new y(e,5,!1,e.toLowerCase(),null,!1,!1)}));var g=/[\-:]([a-z])/g;function _(e){return e[1].toUpperCase()}function b(e,t,n,o){var i=m.hasOwnProperty(t)?m[t]:null;(null!==i?0!==i.type:o||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,o){if(null==t||function(e,t,n,o){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!o&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,o))return!0;if(o)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,i,o)&&(n=null),o||null===i?function(e){return!!l.call(f,e)||!l.call(h,e)&&(u.test(e)?f[e]=!0:(h[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):i.mustUseProperty?e[i.propertyName]=null===n?3!==i.type&&"":n:(t=i.attributeName,o=i.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(i=i.type)||4===i&&!0===n?"":""+n,o?e.setAttributeNS(o,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(g,_);m[t]=new y(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(g,_);m[t]=new y(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(g,_);m[t]=new y(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){m[e]=new y(e,1,!1,e.toLowerCase(),null,!1,!1)})),m.xlinkHref=new y("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){m[e]=new y(e,1,!1,e.toLowerCase(),null,!0,!0)}));var T=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,v=Symbol.for("react.element"),P=Symbol.for("react.portal"),E=Symbol.for("react.fragment"),R=Symbol.for("react.strict_mode"),A=Symbol.for("react.profiler"),k=Symbol.for("react.provider"),w=Symbol.for("react.context"),S=Symbol.for("react.forward_ref"),I=Symbol.for("react.suspense"),O=Symbol.for("react.suspense_list"),x=Symbol.for("react.memo"),N=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var U=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var Y=Symbol.iterator;function C(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=Y&&e[Y]||e["@@iterator"])?e:null}var L,D=Object.assign;function q(e){if(void 0===L)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);L=t&&t[1]||""}return"\n"+L+e}var F=!1;function j(e,t){if(!e||F)return"";F=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"==typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(c){var o=c}Reflect.construct(e,[],t)}else{try{t.call()}catch(c){o=c}e.call(t.prototype)}else{try{throw Error()}catch(c){o=c}e()}}catch(c){if(c&&o&&"string"==typeof c.stack){for(var i=c.stack.split("\n"),s=o.stack.split("\n"),a=i.length-1,r=s.length-1;1<=a&&0<=r&&i[a]!==s[r];)r--;for(;1<=a&&0<=r;a--,r--)if(i[a]!==s[r]){if(1!==a||1!==r)do{if(a--,0>--r||i[a]!==s[r]){var p="\n"+i[a].replace(" at new "," at ");return e.displayName&&p.includes("<anonymous>")&&(p=p.replace("<anonymous>",e.displayName)),p}}while(1<=a&&0<=r);break}}}finally{F=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?q(e):""}function M(e){switch(e.tag){case 5:return q(e.type);case 16:return q("Lazy");case 13:return q("Suspense");case 19:return q("SuspenseList");case 0:case 2:case 15:return e=j(e.type,!1);case 11:return e=j(e.type.render,!1);case 1:return e=j(e.type,!0);default:return""}}function z(e){if(null==e)return null;if("function"==typeof e)return e.displayName||e.name||null;if("string"==typeof e)return e;switch(e){case E:return"Fragment";case P:return"Portal";case A:return"Profiler";case R:return"StrictMode";case I:return"Suspense";case O:return"SuspenseList"}if("object"==typeof e)switch(e.$$typeof){case w:return(e.displayName||"Context")+".Consumer";case k:return(e._context.displayName||"Context")+".Provider";case S:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case x:return null!==(t=e.displayName||null)?t:z(e.type)||"Memo";case N:t=e._payload,e=e._init;try{return z(e(t))}catch(n){}}return null}function V(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return z(t);case 8:return t===R?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"==typeof t)return t.displayName||t.name||null;if("string"==typeof t)return t}return null}function G(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function B(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function J(e){e._valueTracker||(e._valueTracker=function(e){var t=B(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),o=""+e[t];if(!e.hasOwnProperty(t)&&void 0!==n&&"function"==typeof n.get&&"function"==typeof n.set){var i=n.get,s=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return i.call(this)},set:function(e){o=""+e,s.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return o},setValue:function(e){o=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function Q(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),o="";return e&&(o=B(e)?e.checked?"true":"false":e.value),(e=o)!==n&&(t.setValue(e),!0)}function H(e){if(void 0===(e=e||("undefined"!=typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function W(e,t){var n=t.checked;return D({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function K(e,t){var n=null==t.defaultValue?"":t.defaultValue,o=null!=t.checked?t.checked:t.defaultChecked;n=G(null!=t.value?t.value:n),e._wrapperState={initialChecked:o,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function $(e,t){null!=(t=t.checked)&&b(e,"checked",t,!1)}function Z(e,t){$(e,t);var n=G(t.value),o=t.type;if(null!=n)"number"===o?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===o||"reset"===o)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,G(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function X(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var o=t.type;if(!("submit"!==o&&"reset"!==o||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&H(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,o){if(e=e.options,t){t={};for(var i=0;i<n.length;i++)t["$"+n[i]]=!0;for(n=0;n<e.length;n++)i=t.hasOwnProperty("$"+e[n].value),e[n].selected!==i&&(e[n].selected=i),i&&o&&(e[n].defaultSelected=!0)}else{for(n=""+G(n),t=null,i=0;i<e.length;i++){if(e[i].value===n)return e[i].selected=!0,void(o&&(e[i].defaultSelected=!0));null!==t||e[i].disabled||(t=e[i])}null!==t&&(t.selected=!0)}}function oe(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(s(91));return D({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function ie(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(s(92));if(te(n)){if(1<n.length)throw Error(s(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:G(n)}}function se(e,t){var n=G(t.value),o=G(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=o&&(e.defaultValue=""+o)}function ae(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function re(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function pe(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?re(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var ce,de,le=(de=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((ce=ce||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ce.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!=typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,o){MSApp.execUnsafeLocalFunction((function(){return de(e,t)}))}:de);function ue(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var he={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function ye(e,t,n){return null==t||"boolean"==typeof t||""===t?"":n||"number"!=typeof t||0===t||he.hasOwnProperty(e)&&he[e]?(""+t).trim():t+"px"}function me(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var o=0===n.indexOf("--"),i=ye(n,t[n],o);"float"===n&&(n="cssFloat"),o?e.setProperty(n,i):e[n]=i}}Object.keys(he).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),he[t]=he[e]}))}));var ge=D({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function _e(e,t){if(t){if(ge[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(s(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(s(60));if("object"!=typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(s(61))}if(null!=t.style&&"object"!=typeof t.style)throw Error(s(62))}}function be(e,t){if(-1===e.indexOf("-"))return"string"==typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Te=null;function ve(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var Pe=null,Ee=null,Re=null;function Ae(e){if(e=Ti(e)){if("function"!=typeof Pe)throw Error(s(280));var t=e.stateNode;t&&(t=Pi(t),Pe(e.stateNode,e.type,t))}}function ke(e){Ee?Re?Re.push(e):Re=[e]:Ee=e}function we(){if(Ee){var e=Ee,t=Re;if(Re=Ee=null,Ae(e),t)for(e=0;e<t.length;e++)Ae(t[e])}}function Se(e,t){return e(t)}function Ie(){}var Oe=!1;function xe(e,t,n){if(Oe)return e(t,n);Oe=!0;try{return Se(e,t,n)}finally{Oe=!1,(null!==Ee||null!==Re)&&(Ie(),we())}}function Ne(e,t){var n=e.stateNode;if(null===n)return null;var o=Pi(n);if(null===o)return null;n=o[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(o=!o.disabled)||(o=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!o;break e;default:e=!1}if(e)return null;if(n&&"function"!=typeof n)throw Error(s(231,t,typeof n));return n}var Ue=!1;if(d)try{var Ye={};Object.defineProperty(Ye,"passive",{get:function(){Ue=!0}}),window.addEventListener("test",Ye,Ye),window.removeEventListener("test",Ye,Ye)}catch(de){Ue=!1}function Ce(e,t,n,o,i,s,a,r,p){var c=Array.prototype.slice.call(arguments,3);try{t.apply(n,c)}catch(d){this.onError(d)}}var Le=!1,De=null,qe=!1,Fe=null,je={onError:function(e){Le=!0,De=e}};function Me(e,t,n,o,i,s,a,r,p){Le=!1,De=null,Ce.apply(je,arguments)}function ze(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!=(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ve(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function Ge(e){if(ze(e)!==e)throw Error(s(188))}function Be(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=ze(e)))throw Error(s(188));return t!==e?null:e}for(var n=e,o=t;;){var i=n.return;if(null===i)break;var a=i.alternate;if(null===a){if(null!==(o=i.return)){n=o;continue}break}if(i.child===a.child){for(a=i.child;a;){if(a===n)return Ge(i),e;if(a===o)return Ge(i),t;a=a.sibling}throw Error(s(188))}if(n.return!==o.return)n=i,o=a;else{for(var r=!1,p=i.child;p;){if(p===n){r=!0,n=i,o=a;break}if(p===o){r=!0,o=i,n=a;break}p=p.sibling}if(!r){for(p=a.child;p;){if(p===n){r=!0,n=a,o=i;break}if(p===o){r=!0,o=a,n=i;break}p=p.sibling}if(!r)throw Error(s(189))}}if(n.alternate!==o)throw Error(s(190))}if(3!==n.tag)throw Error(s(188));return n.stateNode.current===n?e:t}(e))?Je(e):null}function Je(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=Je(e);if(null!==t)return t;e=e.sibling}return null}var Qe=i.unstable_scheduleCallback,He=i.unstable_cancelCallback,We=i.unstable_shouldYield,Ke=i.unstable_requestPaint,$e=i.unstable_now,Ze=i.unstable_getCurrentPriorityLevel,Xe=i.unstable_ImmediatePriority,et=i.unstable_UserBlockingPriority,tt=i.unstable_NormalPriority,nt=i.unstable_LowPriority,ot=i.unstable_IdlePriority,it=null,st=null;var at=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(rt(e)/pt|0)|0},rt=Math.log,pt=Math.LN2;var ct=64,dt=4194304;function lt(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function ut(e,t){var n=e.pendingLanes;if(0===n)return 0;var o=0,i=e.suspendedLanes,s=e.pingedLanes,a=268435455&n;if(0!==a){var r=a&~i;0!==r?o=lt(r):0!==(s&=a)&&(o=lt(s))}else 0!==(a=n&~i)?o=lt(a):0!==s&&(o=lt(s));if(0===o)return 0;if(0!==t&&t!==o&&0==(t&i)&&((i=o&-o)>=(s=t&-t)||16===i&&0!=(4194240&s)))return t;if(0!=(4&o)&&(o|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=o;0<t;)i=1<<(n=31-at(t)),o|=e[n],t&=~i;return o}function ht(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function yt(){var e=ct;return 0==(4194240&(ct<<=1))&&(ct=64),e}function mt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function gt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-at(t)]=n}function _t(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var o=31-at(n),i=1<<o;i&t|e[o]&t&&(e[o]|=t),n&=~i}}var bt=0;function Tt(e){return 1<(e&=-e)?4<e?0!=(268435455&e)?16:536870912:4:1}var vt,Pt,Et,Rt,At,kt=!1,wt=[],St=null,It=null,Ot=null,xt=new Map,Nt=new Map,Ut=[],Yt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Ct(e,t){switch(e){case"focusin":case"focusout":St=null;break;case"dragenter":case"dragleave":It=null;break;case"mouseover":case"mouseout":Ot=null;break;case"pointerover":case"pointerout":xt.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Nt.delete(t.pointerId)}}function Lt(e,t,n,o,i,s){return null===e||e.nativeEvent!==s?(e={blockedOn:t,domEventName:n,eventSystemFlags:o,nativeEvent:s,targetContainers:[i]},null!==t&&(null!==(t=Ti(t))&&Pt(t)),e):(e.eventSystemFlags|=o,t=e.targetContainers,null!==i&&-1===t.indexOf(i)&&t.push(i),e)}function Dt(e){var t=bi(e.target);if(null!==t){var n=ze(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ve(n)))return e.blockedOn=t,void At(e.priority,(function(){Et(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function qt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Wt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=Ti(n))&&Pt(t),e.blockedOn=n,!1;var o=new(n=e.nativeEvent).constructor(n.type,n);Te=o,n.target.dispatchEvent(o),Te=null,t.shift()}return!0}function Ft(e,t,n){qt(e)&&n.delete(t)}function jt(){kt=!1,null!==St&&qt(St)&&(St=null),null!==It&&qt(It)&&(It=null),null!==Ot&&qt(Ot)&&(Ot=null),xt.forEach(Ft),Nt.forEach(Ft)}function Mt(e,t){e.blockedOn===t&&(e.blockedOn=null,kt||(kt=!0,i.unstable_scheduleCallback(i.unstable_NormalPriority,jt)))}function zt(e){function t(t){return Mt(t,e)}if(0<wt.length){Mt(wt[0],e);for(var n=1;n<wt.length;n++){var o=wt[n];o.blockedOn===e&&(o.blockedOn=null)}}for(null!==St&&Mt(St,e),null!==It&&Mt(It,e),null!==Ot&&Mt(Ot,e),xt.forEach(t),Nt.forEach(t),n=0;n<Ut.length;n++)(o=Ut[n]).blockedOn===e&&(o.blockedOn=null);for(;0<Ut.length&&null===(n=Ut[0]).blockedOn;)Dt(n),null===n.blockedOn&&Ut.shift()}var Vt=T.ReactCurrentBatchConfig,Gt=!0;function Bt(e,t,n,o){var i=bt,s=Vt.transition;Vt.transition=null;try{bt=1,Qt(e,t,n,o)}finally{bt=i,Vt.transition=s}}function Jt(e,t,n,o){var i=bt,s=Vt.transition;Vt.transition=null;try{bt=4,Qt(e,t,n,o)}finally{bt=i,Vt.transition=s}}function Qt(e,t,n,o){if(Gt){var i=Wt(e,t,n,o);if(null===i)Bo(e,t,o,Ht,n),Ct(e,o);else if(function(e,t,n,o,i){switch(t){case"focusin":return St=Lt(St,e,t,n,o,i),!0;case"dragenter":return It=Lt(It,e,t,n,o,i),!0;case"mouseover":return Ot=Lt(Ot,e,t,n,o,i),!0;case"pointerover":var s=i.pointerId;return xt.set(s,Lt(xt.get(s)||null,e,t,n,o,i)),!0;case"gotpointercapture":return s=i.pointerId,Nt.set(s,Lt(Nt.get(s)||null,e,t,n,o,i)),!0}return!1}(i,e,t,n,o))o.stopPropagation();else if(Ct(e,o),4&t&&-1<Yt.indexOf(e)){for(;null!==i;){var s=Ti(i);if(null!==s&&vt(s),null===(s=Wt(e,t,n,o))&&Bo(e,t,o,Ht,n),s===i)break;i=s}null!==i&&o.stopPropagation()}else Bo(e,t,o,null,n)}}var Ht=null;function Wt(e,t,n,o){if(Ht=null,null!==(e=bi(e=ve(o))))if(null===(t=ze(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=Ve(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Ht=e,null}function Kt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Ze()){case Xe:return 1;case et:return 4;case tt:case nt:return 16;case ot:return 536870912;default:return 16}default:return 16}}var $t=null,Zt=null,Xt=null;function en(){if(Xt)return Xt;var e,t,n=Zt,o=n.length,i="value"in $t?$t.value:$t.textContent,s=i.length;for(e=0;e<o&&n[e]===i[e];e++);var a=o-e;for(t=1;t<=a&&n[o-t]===i[s-t];t++);return Xt=i.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function on(){return!1}function sn(e){function t(t,n,o,i,s){for(var a in this._reactName=t,this._targetInst=o,this.type=n,this.nativeEvent=i,this.target=s,this.currentTarget=null,e)e.hasOwnProperty(a)&&(t=e[a],this[a]=t?t(i):i[a]);return this.isDefaultPrevented=(null!=i.defaultPrevented?i.defaultPrevented:!1===i.returnValue)?nn:on,this.isPropagationStopped=on,this}return D(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!=typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!=typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var an,rn,pn,cn={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},dn=sn(cn),ln=D({},cn,{view:0,detail:0}),un=sn(ln),hn=D({},ln,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:An,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==pn&&(pn&&"mousemove"===e.type?(an=e.screenX-pn.screenX,rn=e.screenY-pn.screenY):rn=an=0,pn=e),an)},movementY:function(e){return"movementY"in e?e.movementY:rn}}),fn=sn(hn),yn=sn(D({},hn,{dataTransfer:0})),mn=sn(D({},ln,{relatedTarget:0})),gn=sn(D({},cn,{animationName:0,elapsedTime:0,pseudoElement:0})),_n=D({},cn,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),bn=sn(_n),Tn=sn(D({},cn,{data:0})),vn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Pn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},En={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Rn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=En[e])&&!!t[e]}function An(){return Rn}var kn=D({},ln,{key:function(e){if(e.key){var t=vn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?Pn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:An,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),wn=sn(kn),Sn=sn(D({},hn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),In=sn(D({},ln,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:An})),On=sn(D({},cn,{propertyName:0,elapsedTime:0,pseudoElement:0})),xn=D({},hn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Nn=sn(xn),Un=[9,13,27,32],Yn=d&&"CompositionEvent"in window,Cn=null;d&&"documentMode"in document&&(Cn=document.documentMode);var Ln=d&&"TextEvent"in window&&!Cn,Dn=d&&(!Yn||Cn&&8<Cn&&11>=Cn),qn=String.fromCharCode(32),Fn=!1;function jn(e,t){switch(e){case"keyup":return-1!==Un.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Mn(e){return"object"==typeof(e=e.detail)&&"data"in e?e.data:null}var zn=!1;var Vn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Gn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Vn[e.type]:"textarea"===t}function Bn(e,t,n,o){ke(o),0<(t=Qo(t,"onChange")).length&&(n=new dn("onChange","change",null,n,o),e.push({event:n,listeners:t}))}var Jn=null,Qn=null;function Hn(e){Fo(e,0)}function Wn(e){if(Q(vi(e)))return e}function Kn(e,t){if("change"===e)return t}var $n=!1;if(d){var Zn;if(d){var Xn="oninput"in document;if(!Xn){var eo=document.createElement("div");eo.setAttribute("oninput","return;"),Xn="function"==typeof eo.oninput}Zn=Xn}else Zn=!1;$n=Zn&&(!document.documentMode||9<document.documentMode)}function to(){Jn&&(Jn.detachEvent("onpropertychange",no),Qn=Jn=null)}function no(e){if("value"===e.propertyName&&Wn(Qn)){var t=[];Bn(t,Qn,e,ve(e)),xe(Hn,t)}}function oo(e,t,n){"focusin"===e?(to(),Qn=n,(Jn=t).attachEvent("onpropertychange",no)):"focusout"===e&&to()}function io(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Wn(Qn)}function so(e,t){if("click"===e)return Wn(t)}function ao(e,t){if("input"===e||"change"===e)return Wn(t)}var ro="function"==typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e==1/t)||e!=e&&t!=t};function po(e,t){if(ro(e,t))return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;var n=Object.keys(e),o=Object.keys(t);if(n.length!==o.length)return!1;for(o=0;o<n.length;o++){var i=n[o];if(!l.call(t,i)||!ro(e[i],t[i]))return!1}return!0}function co(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function lo(e,t){var n,o=co(e);for(e=0;o;){if(3===o.nodeType){if(n=e+o.textContent.length,e<=t&&n>=t)return{node:o,offset:t-e};e=n}e:{for(;o;){if(o.nextSibling){o=o.nextSibling;break e}o=o.parentNode}o=void 0}o=co(o)}}function uo(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?uo(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function ho(){for(var e=window,t=H();t instanceof e.HTMLIFrameElement;){try{var n="string"==typeof t.contentWindow.location.href}catch(o){n=!1}if(!n)break;t=H((e=t.contentWindow).document)}return t}function fo(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function yo(e){var t=ho(),n=e.focusedElem,o=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&uo(n.ownerDocument.documentElement,n)){if(null!==o&&fo(n))if(t=o.start,void 0===(e=o.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var i=n.textContent.length,s=Math.min(o.start,i);o=void 0===o.end?s:Math.min(o.end,i),!e.extend&&s>o&&(i=o,o=s,s=i),i=lo(n,s);var a=lo(n,o);i&&a&&(1!==e.rangeCount||e.anchorNode!==i.node||e.anchorOffset!==i.offset||e.focusNode!==a.node||e.focusOffset!==a.offset)&&((t=t.createRange()).setStart(i.node,i.offset),e.removeAllRanges(),s>o?(e.addRange(t),e.extend(a.node,a.offset)):(t.setEnd(a.node,a.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"==typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var mo=d&&"documentMode"in document&&11>=document.documentMode,go=null,_o=null,bo=null,To=!1;function vo(e,t,n){var o=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;To||null==go||go!==H(o)||("selectionStart"in(o=go)&&fo(o)?o={start:o.selectionStart,end:o.selectionEnd}:o={anchorNode:(o=(o.ownerDocument&&o.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:o.anchorOffset,focusNode:o.focusNode,focusOffset:o.focusOffset},bo&&po(bo,o)||(bo=o,0<(o=Qo(_o,"onSelect")).length&&(t=new dn("onSelect","select",null,t,n),e.push({event:t,listeners:o}),t.target=go)))}function Po(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var Eo={animationend:Po("Animation","AnimationEnd"),animationiteration:Po("Animation","AnimationIteration"),animationstart:Po("Animation","AnimationStart"),transitionend:Po("Transition","TransitionEnd")},Ro={},Ao={};function ko(e){if(Ro[e])return Ro[e];if(!Eo[e])return e;var t,n=Eo[e];for(t in n)if(n.hasOwnProperty(t)&&t in Ao)return Ro[e]=n[t];return e}d&&(Ao=document.createElement("div").style,"AnimationEvent"in window||(delete Eo.animationend.animation,delete Eo.animationiteration.animation,delete Eo.animationstart.animation),"TransitionEvent"in window||delete Eo.transitionend.transition);var wo=ko("animationend"),So=ko("animationiteration"),Io=ko("animationstart"),Oo=ko("transitionend"),xo=new Map,No="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Uo(e,t){xo.set(e,t),p(t,[e])}for(var Yo=0;Yo<No.length;Yo++){var Co=No[Yo];Uo(Co.toLowerCase(),"on"+(Co[0].toUpperCase()+Co.slice(1)))}Uo(wo,"onAnimationEnd"),Uo(So,"onAnimationIteration"),Uo(Io,"onAnimationStart"),Uo("dblclick","onDoubleClick"),Uo("focusin","onFocus"),Uo("focusout","onBlur"),Uo(Oo,"onTransitionEnd"),c("onMouseEnter",["mouseout","mouseover"]),c("onMouseLeave",["mouseout","mouseover"]),c("onPointerEnter",["pointerout","pointerover"]),c("onPointerLeave",["pointerout","pointerover"]),p("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),p("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),p("onBeforeInput",["compositionend","keypress","textInput","paste"]),p("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),p("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),p("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Lo="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Do=new Set("cancel close invalid load scroll toggle".split(" ").concat(Lo));function qo(e,t,n){var o=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,o,i,a,r,p,c){if(Me.apply(this,arguments),Le){if(!Le)throw Error(s(198));var d=De;Le=!1,De=null,qe||(qe=!0,Fe=d)}}(o,t,void 0,e),e.currentTarget=null}function Fo(e,t){t=0!=(4&t);for(var n=0;n<e.length;n++){var o=e[n],i=o.event;o=o.listeners;e:{var s=void 0;if(t)for(var a=o.length-1;0<=a;a--){var r=o[a],p=r.instance,c=r.currentTarget;if(r=r.listener,p!==s&&i.isPropagationStopped())break e;qo(i,r,c),s=p}else for(a=0;a<o.length;a++){if(p=(r=o[a]).instance,c=r.currentTarget,r=r.listener,p!==s&&i.isPropagationStopped())break e;qo(i,r,c),s=p}}}if(qe)throw e=Fe,qe=!1,Fe=null,e}function jo(e,t){var n=t[mi];void 0===n&&(n=t[mi]=new Set);var o=e+"__bubble";n.has(o)||(Go(t,e,2,!1),n.add(o))}function Mo(e,t,n){var o=0;t&&(o|=4),Go(n,e,o,t)}var zo="_reactListening"+Math.random().toString(36).slice(2);function Vo(e){if(!e[zo]){e[zo]=!0,a.forEach((function(t){"selectionchange"!==t&&(Do.has(t)||Mo(t,!1,e),Mo(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[zo]||(t[zo]=!0,Mo("selectionchange",!1,t))}}function Go(e,t,n,o){switch(Kt(t)){case 1:var i=Bt;break;case 4:i=Jt;break;default:i=Qt}n=i.bind(null,t,n,e),i=void 0,!Ue||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(i=!0),o?void 0!==i?e.addEventListener(t,n,{capture:!0,passive:i}):e.addEventListener(t,n,!0):void 0!==i?e.addEventListener(t,n,{passive:i}):e.addEventListener(t,n,!1)}function Bo(e,t,n,o,i){var s=o;if(0==(1&t)&&0==(2&t)&&null!==o)e:for(;;){if(null===o)return;var a=o.tag;if(3===a||4===a){var r=o.stateNode.containerInfo;if(r===i||8===r.nodeType&&r.parentNode===i)break;if(4===a)for(a=o.return;null!==a;){var p=a.tag;if((3===p||4===p)&&((p=a.stateNode.containerInfo)===i||8===p.nodeType&&p.parentNode===i))return;a=a.return}for(;null!==r;){if(null===(a=bi(r)))return;if(5===(p=a.tag)||6===p){o=s=a;continue e}r=r.parentNode}}o=o.return}xe((function(){var o=s,i=ve(n),a=[];e:{var r=xo.get(e);if(void 0!==r){var p=dn,c=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":p=wn;break;case"focusin":c="focus",p=mn;break;case"focusout":c="blur",p=mn;break;case"beforeblur":case"afterblur":p=mn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":p=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":p=yn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":p=In;break;case wo:case So:case Io:p=gn;break;case Oo:p=On;break;case"scroll":p=un;break;case"wheel":p=Nn;break;case"copy":case"cut":case"paste":p=bn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":p=Sn}var d=0!=(4&t),l=!d&&"scroll"===e,u=d?null!==r?r+"Capture":null:r;d=[];for(var h,f=o;null!==f;){var y=(h=f).stateNode;if(5===h.tag&&null!==y&&(h=y,null!==u&&(null!=(y=Ne(f,u))&&d.push(Jo(f,y,h)))),l)break;f=f.return}0<d.length&&(r=new p(r,c,null,n,i),a.push({event:r,listeners:d}))}}if(0==(7&t)){if(p="mouseout"===e||"pointerout"===e,(!(r="mouseover"===e||"pointerover"===e)||n===Te||!(c=n.relatedTarget||n.fromElement)||!bi(c)&&!c[yi])&&(p||r)&&(r=i.window===i?i:(r=i.ownerDocument)?r.defaultView||r.parentWindow:window,p?(p=o,null!==(c=(c=n.relatedTarget||n.toElement)?bi(c):null)&&(c!==(l=ze(c))||5!==c.tag&&6!==c.tag)&&(c=null)):(p=null,c=o),p!==c)){if(d=fn,y="onMouseLeave",u="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(d=Sn,y="onPointerLeave",u="onPointerEnter",f="pointer"),l=null==p?r:vi(p),h=null==c?r:vi(c),(r=new d(y,f+"leave",p,n,i)).target=l,r.relatedTarget=h,y=null,bi(i)===o&&((d=new d(u,f+"enter",c,n,i)).target=h,d.relatedTarget=l,y=d),l=y,p&&c)e:{for(u=c,f=0,h=d=p;h;h=Ho(h))f++;for(h=0,y=u;y;y=Ho(y))h++;for(;0<f-h;)d=Ho(d),f--;for(;0<h-f;)u=Ho(u),h--;for(;f--;){if(d===u||null!==u&&d===u.alternate)break e;d=Ho(d),u=Ho(u)}d=null}else d=null;null!==p&&Wo(a,r,p,d,!1),null!==c&&null!==l&&Wo(a,l,c,d,!0)}if("select"===(p=(r=o?vi(o):window).nodeName&&r.nodeName.toLowerCase())||"input"===p&&"file"===r.type)var m=Kn;else if(Gn(r))if($n)m=ao;else{m=io;var g=oo}else(p=r.nodeName)&&"input"===p.toLowerCase()&&("checkbox"===r.type||"radio"===r.type)&&(m=so);switch(m&&(m=m(e,o))?Bn(a,m,n,i):(g&&g(e,r,o),"focusout"===e&&(g=r._wrapperState)&&g.controlled&&"number"===r.type&&ee(r,"number",r.value)),g=o?vi(o):window,e){case"focusin":(Gn(g)||"true"===g.contentEditable)&&(go=g,_o=o,bo=null);break;case"focusout":bo=_o=go=null;break;case"mousedown":To=!0;break;case"contextmenu":case"mouseup":case"dragend":To=!1,vo(a,n,i);break;case"selectionchange":if(mo)break;case"keydown":case"keyup":vo(a,n,i)}var _;if(Yn)e:{switch(e){case"compositionstart":var b="onCompositionStart";break e;case"compositionend":b="onCompositionEnd";break e;case"compositionupdate":b="onCompositionUpdate";break e}b=void 0}else zn?jn(e,n)&&(b="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(b="onCompositionStart");b&&(Dn&&"ko"!==n.locale&&(zn||"onCompositionStart"!==b?"onCompositionEnd"===b&&zn&&(_=en()):(Zt="value"in($t=i)?$t.value:$t.textContent,zn=!0)),0<(g=Qo(o,b)).length&&(b=new Tn(b,e,null,n,i),a.push({event:b,listeners:g}),_?b.data=_:null!==(_=Mn(n))&&(b.data=_))),(_=Ln?function(e,t){switch(e){case"compositionend":return Mn(t);case"keypress":return 32!==t.which?null:(Fn=!0,qn);case"textInput":return(e=t.data)===qn&&Fn?null:e;default:return null}}(e,n):function(e,t){if(zn)return"compositionend"===e||!Yn&&jn(e,t)?(e=en(),Xt=Zt=$t=null,zn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Dn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(o=Qo(o,"onBeforeInput")).length&&(i=new Tn("onBeforeInput","beforeinput",null,n,i),a.push({event:i,listeners:o}),i.data=_))}Fo(a,t)}))}function Jo(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Qo(e,t){for(var n=t+"Capture",o=[];null!==e;){var i=e,s=i.stateNode;5===i.tag&&null!==s&&(i=s,null!=(s=Ne(e,n))&&o.unshift(Jo(e,s,i)),null!=(s=Ne(e,t))&&o.push(Jo(e,s,i))),e=e.return}return o}function Ho(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Wo(e,t,n,o,i){for(var s=t._reactName,a=[];null!==n&&n!==o;){var r=n,p=r.alternate,c=r.stateNode;if(null!==p&&p===o)break;5===r.tag&&null!==c&&(r=c,i?null!=(p=Ne(n,s))&&a.unshift(Jo(n,p,r)):i||null!=(p=Ne(n,s))&&a.push(Jo(n,p,r))),n=n.return}0!==a.length&&e.push({event:t,listeners:a})}var Ko=/\r\n?/g,$o=/\u0000|\uFFFD/g;function Zo(e){return("string"==typeof e?e:""+e).replace(Ko,"\n").replace($o,"")}function Xo(e,t,n){if(t=Zo(t),Zo(e)!==t&&n)throw Error(s(425))}function ei(){}var ti=null,ni=null;function oi(e,t){return"textarea"===e||"noscript"===e||"string"==typeof t.children||"number"==typeof t.children||"object"==typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var ii="function"==typeof setTimeout?setTimeout:void 0,si="function"==typeof clearTimeout?clearTimeout:void 0,ai="function"==typeof Promise?Promise:void 0,ri="function"==typeof queueMicrotask?queueMicrotask:void 0!==ai?function(e){return ai.resolve(null).then(e).catch(pi)}:ii;function pi(e){setTimeout((function(){throw e}))}function ci(e,t){var n=t,o=0;do{var i=n.nextSibling;if(e.removeChild(n),i&&8===i.nodeType)if("/$"===(n=i.data)){if(0===o)return e.removeChild(i),void zt(t);o--}else"$"!==n&&"$?"!==n&&"$!"!==n||o++;n=i}while(n);zt(t)}function di(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function li(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var ui=Math.random().toString(36).slice(2),hi="__reactFiber$"+ui,fi="__reactProps$"+ui,yi="__reactContainer$"+ui,mi="__reactEvents$"+ui,gi="__reactListeners$"+ui,_i="__reactHandles$"+ui;function bi(e){var t=e[hi];if(t)return t;for(var n=e.parentNode;n;){if(t=n[yi]||n[hi]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=li(e);null!==e;){if(n=e[hi])return n;e=li(e)}return t}n=(e=n).parentNode}return null}function Ti(e){return!(e=e[hi]||e[yi])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function vi(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(s(33))}function Pi(e){return e[fi]||null}var Ei=[],Ri=-1;function Ai(e){return{current:e}}function ki(e){0>Ri||(e.current=Ei[Ri],Ei[Ri]=null,Ri--)}function wi(e,t){Ri++,Ei[Ri]=e.current,e.current=t}var Si={},Ii=Ai(Si),Oi=Ai(!1),xi=Si;function Ni(e,t){var n=e.type.contextTypes;if(!n)return Si;var o=e.stateNode;if(o&&o.__reactInternalMemoizedUnmaskedChildContext===t)return o.__reactInternalMemoizedMaskedChildContext;var i,s={};for(i in n)s[i]=t[i];return o&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=s),s}function Ui(e){return null!=(e=e.childContextTypes)}function Yi(){ki(Oi),ki(Ii)}function Ci(e,t,n){if(Ii.current!==Si)throw Error(s(168));wi(Ii,t),wi(Oi,n)}function Li(e,t,n){var o=e.stateNode;if(t=t.childContextTypes,"function"!=typeof o.getChildContext)return n;for(var i in o=o.getChildContext())if(!(i in t))throw Error(s(108,V(e)||"Unknown",i));return D({},n,o)}function Di(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Si,xi=Ii.current,wi(Ii,e),wi(Oi,Oi.current),!0}function qi(e,t,n){var o=e.stateNode;if(!o)throw Error(s(169));n?(e=Li(e,t,xi),o.__reactInternalMemoizedMergedChildContext=e,ki(Oi),ki(Ii),wi(Ii,e)):ki(Oi),wi(Oi,n)}var Fi=null,ji=!1,Mi=!1;function zi(e){null===Fi?Fi=[e]:Fi.push(e)}function Vi(){if(!Mi&&null!==Fi){Mi=!0;var e=0,t=bt;try{var n=Fi;for(bt=1;e<n.length;e++){var o=n[e];do{o=o(!0)}while(null!==o)}Fi=null,ji=!1}catch(i){throw null!==Fi&&(Fi=Fi.slice(e+1)),Qe(Xe,Vi),i}finally{bt=t,Mi=!1}}return null}var Gi=[],Bi=0,Ji=null,Qi=0,Hi=[],Wi=0,Ki=null,$i=1,Zi="";function Xi(e,t){Gi[Bi++]=Qi,Gi[Bi++]=Ji,Ji=e,Qi=t}function es(e,t,n){Hi[Wi++]=$i,Hi[Wi++]=Zi,Hi[Wi++]=Ki,Ki=e;var o=$i;e=Zi;var i=32-at(o)-1;o&=~(1<<i),n+=1;var s=32-at(t)+i;if(30<s){var a=i-i%5;s=(o&(1<<a)-1).toString(32),o>>=a,i-=a,$i=1<<32-at(t)+i|n<<i|o,Zi=s+e}else $i=1<<s|n<<i|o,Zi=e}function ts(e){null!==e.return&&(Xi(e,1),es(e,1,0))}function ns(e){for(;e===Ji;)Ji=Gi[--Bi],Gi[Bi]=null,Qi=Gi[--Bi],Gi[Bi]=null;for(;e===Ki;)Ki=Hi[--Wi],Hi[Wi]=null,Zi=Hi[--Wi],Hi[Wi]=null,$i=Hi[--Wi],Hi[Wi]=null}var os=null,is=null,ss=!1,as=null;function rs(e,t){var n=Nc(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function ps(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,os=e,is=di(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,os=e,is=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Ki?{id:$i,overflow:Zi}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=Nc(18,null,null,0)).stateNode=t,n.return=e,e.child=n,os=e,is=null,!0);default:return!1}}function cs(e){return 0!=(1&e.mode)&&0==(128&e.flags)}function ds(e){if(ss){var t=is;if(t){var n=t;if(!ps(e,t)){if(cs(e))throw Error(s(418));t=di(n.nextSibling);var o=os;t&&ps(e,t)?rs(o,n):(e.flags=-4097&e.flags|2,ss=!1,os=e)}}else{if(cs(e))throw Error(s(418));e.flags=-4097&e.flags|2,ss=!1,os=e}}}function ls(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;os=e}function us(e){if(e!==os)return!1;if(!ss)return ls(e),ss=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!oi(e.type,e.memoizedProps)),t&&(t=is)){if(cs(e))throw hs(),Error(s(418));for(;t;)rs(e,t),t=di(t.nextSibling)}if(ls(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(s(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){is=di(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}is=null}}else is=os?di(e.stateNode.nextSibling):null;return!0}function hs(){for(var e=is;e;)e=di(e.nextSibling)}function fs(){is=os=null,ss=!1}function ys(e){null===as?as=[e]:as.push(e)}var ms=T.ReactCurrentBatchConfig;function gs(e,t){if(e&&e.defaultProps){for(var n in t=D({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}var _s=Ai(null),bs=null,Ts=null,vs=null;function Ps(){vs=Ts=bs=null}function Es(e){var t=_s.current;ki(_s),e._currentValue=t}function Rs(e,t,n){for(;null!==e;){var o=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==o&&(o.childLanes|=t)):null!==o&&(o.childLanes&t)!==t&&(o.childLanes|=t),e===n)break;e=e.return}}function As(e,t){bs=e,vs=Ts=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!=(e.lanes&t)&&(Tr=!0),e.firstContext=null)}function ks(e){var t=e._currentValue;if(vs!==e)if(e={context:e,memoizedValue:t,next:null},null===Ts){if(null===bs)throw Error(s(308));Ts=e,bs.dependencies={lanes:0,firstContext:e}}else Ts=Ts.next=e;return t}var ws=null;function Ss(e){null===ws?ws=[e]:ws.push(e)}function Is(e,t,n,o){var i=t.interleaved;return null===i?(n.next=n,Ss(t)):(n.next=i.next,i.next=n),t.interleaved=n,Os(e,o)}function Os(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var xs=!1;function Ns(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Us(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Ys(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Cs(e,t,n){var o=e.updateQueue;if(null===o)return null;if(o=o.shared,0!=(2&Ip)){var i=o.pending;return null===i?t.next=t:(t.next=i.next,i.next=t),o.pending=t,Os(e,n)}return null===(i=o.interleaved)?(t.next=t,Ss(o)):(t.next=i.next,i.next=t),o.interleaved=t,Os(e,n)}function Ls(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!=(4194240&n))){var o=t.lanes;n|=o&=e.pendingLanes,t.lanes=n,_t(e,n)}}function Ds(e,t){var n=e.updateQueue,o=e.alternate;if(null!==o&&n===(o=o.updateQueue)){var i=null,s=null;if(null!==(n=n.firstBaseUpdate)){do{var a={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===s?i=s=a:s=s.next=a,n=n.next}while(null!==n);null===s?i=s=t:s=s.next=t}else i=s=t;return n={baseState:o.baseState,firstBaseUpdate:i,lastBaseUpdate:s,shared:o.shared,effects:o.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function qs(e,t,n,o){var i=e.updateQueue;xs=!1;var s=i.firstBaseUpdate,a=i.lastBaseUpdate,r=i.shared.pending;if(null!==r){i.shared.pending=null;var p=r,c=p.next;p.next=null,null===a?s=c:a.next=c,a=p;var d=e.alternate;null!==d&&((r=(d=d.updateQueue).lastBaseUpdate)!==a&&(null===r?d.firstBaseUpdate=c:r.next=c,d.lastBaseUpdate=p))}if(null!==s){var l=i.baseState;for(a=0,d=c=p=null,r=s;;){var u=r.lane,h=r.eventTime;if((o&u)===u){null!==d&&(d=d.next={eventTime:h,lane:0,tag:r.tag,payload:r.payload,callback:r.callback,next:null});e:{var f=e,y=r;switch(u=t,h=n,y.tag){case 1:if("function"==typeof(f=y.payload)){l=f.call(h,l,u);break e}l=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null==(u="function"==typeof(f=y.payload)?f.call(h,l,u):f))break e;l=D({},l,u);break e;case 2:xs=!0}}null!==r.callback&&0!==r.lane&&(e.flags|=64,null===(u=i.effects)?i.effects=[r]:u.push(r))}else h={eventTime:h,lane:u,tag:r.tag,payload:r.payload,callback:r.callback,next:null},null===d?(c=d=h,p=l):d=d.next=h,a|=u;if(null===(r=r.next)){if(null===(r=i.shared.pending))break;r=(u=r).next,u.next=null,i.lastBaseUpdate=u,i.shared.pending=null}}if(null===d&&(p=l),i.baseState=p,i.firstBaseUpdate=c,i.lastBaseUpdate=d,null!==(t=i.shared.interleaved)){i=t;do{a|=i.lane,i=i.next}while(i!==t)}else null===s&&(i.shared.lanes=0);Dp|=a,e.lanes=a,e.memoizedState=l}}function Fs(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var o=e[t],i=o.callback;if(null!==i){if(o.callback=null,o=n,"function"!=typeof i)throw Error(s(191,i));i.call(o)}}}var js=(new o.Component).refs;function Ms(e,t,n,o){n=null==(n=n(o,t=e.memoizedState))?t:D({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var zs={isMounted:function(e){return!!(e=e._reactInternals)&&ze(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var o=tc(),i=nc(e),s=Ys(o,i);s.payload=t,null!=n&&(s.callback=n),null!==(t=Cs(e,s,i))&&(oc(t,e,i,o),Ls(t,e,i))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var o=tc(),i=nc(e),s=Ys(o,i);s.tag=1,s.payload=t,null!=n&&(s.callback=n),null!==(t=Cs(e,s,i))&&(oc(t,e,i,o),Ls(t,e,i))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=tc(),o=nc(e),i=Ys(n,o);i.tag=2,null!=t&&(i.callback=t),null!==(t=Cs(e,i,o))&&(oc(t,e,o,n),Ls(t,e,o))}};function Vs(e,t,n,o,i,s,a){return"function"==typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(o,s,a):!t.prototype||!t.prototype.isPureReactComponent||(!po(n,o)||!po(i,s))}function Gs(e,t,n){var o=!1,i=Si,s=t.contextType;return"object"==typeof s&&null!==s?s=ks(s):(i=Ui(t)?xi:Ii.current,s=(o=null!=(o=t.contextTypes))?Ni(e,i):Si),t=new t(n,s),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=zs,e.stateNode=t,t._reactInternals=e,o&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=i,e.__reactInternalMemoizedMaskedChildContext=s),t}function Bs(e,t,n,o){e=t.state,"function"==typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,o),"function"==typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,o),t.state!==e&&zs.enqueueReplaceState(t,t.state,null)}function Js(e,t,n,o){var i=e.stateNode;i.props=n,i.state=e.memoizedState,i.refs=js,Ns(e);var s=t.contextType;"object"==typeof s&&null!==s?i.context=ks(s):(s=Ui(t)?xi:Ii.current,i.context=Ni(e,s)),i.state=e.memoizedState,"function"==typeof(s=t.getDerivedStateFromProps)&&(Ms(e,t,s,n),i.state=e.memoizedState),"function"==typeof t.getDerivedStateFromProps||"function"==typeof i.getSnapshotBeforeUpdate||"function"!=typeof i.UNSAFE_componentWillMount&&"function"!=typeof i.componentWillMount||(t=i.state,"function"==typeof i.componentWillMount&&i.componentWillMount(),"function"==typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount(),t!==i.state&&zs.enqueueReplaceState(i,i.state,null),qs(e,n,i,o),i.state=e.memoizedState),"function"==typeof i.componentDidMount&&(e.flags|=4194308)}function Qs(e,t,n){if(null!==(e=n.ref)&&"function"!=typeof e&&"object"!=typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(s(309));var o=n.stateNode}if(!o)throw Error(s(147,e));var i=o,a=""+e;return null!==t&&null!==t.ref&&"function"==typeof t.ref&&t.ref._stringRef===a?t.ref:(t=function(e){var t=i.refs;t===js&&(t=i.refs={}),null===e?delete t[a]:t[a]=e},t._stringRef=a,t)}if("string"!=typeof e)throw Error(s(284));if(!n._owner)throw Error(s(290,e))}return e}function Hs(e,t){throw e=Object.prototype.toString.call(t),Error(s(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function Ws(e){return(0,e._init)(e._payload)}function Ks(e){function t(t,n){if(e){var o=t.deletions;null===o?(t.deletions=[n],t.flags|=16):o.push(n)}}function n(n,o){if(!e)return null;for(;null!==o;)t(n,o),o=o.sibling;return null}function o(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function i(e,t){return(e=Yc(e,t)).index=0,e.sibling=null,e}function a(t,n,o){return t.index=o,e?null!==(o=t.alternate)?(o=o.index)<n?(t.flags|=2,n):o:(t.flags|=2,n):(t.flags|=1048576,n)}function r(t){return e&&null===t.alternate&&(t.flags|=2),t}function p(e,t,n,o){return null===t||6!==t.tag?((t=qc(n,e.mode,o)).return=e,t):((t=i(t,n)).return=e,t)}function c(e,t,n,o){var s=n.type;return s===E?l(e,t,n.props.children,o,n.key):null!==t&&(t.elementType===s||"object"==typeof s&&null!==s&&s.$$typeof===N&&Ws(s)===t.type)?((o=i(t,n.props)).ref=Qs(e,t,n),o.return=e,o):((o=Cc(n.type,n.key,n.props,null,e.mode,o)).ref=Qs(e,t,n),o.return=e,o)}function d(e,t,n,o){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Fc(n,e.mode,o)).return=e,t):((t=i(t,n.children||[])).return=e,t)}function l(e,t,n,o,s){return null===t||7!==t.tag?((t=Lc(n,e.mode,o,s)).return=e,t):((t=i(t,n)).return=e,t)}function u(e,t,n){if("string"==typeof t&&""!==t||"number"==typeof t)return(t=qc(""+t,e.mode,n)).return=e,t;if("object"==typeof t&&null!==t){switch(t.$$typeof){case v:return(n=Cc(t.type,t.key,t.props,null,e.mode,n)).ref=Qs(e,null,t),n.return=e,n;case P:return(t=Fc(t,e.mode,n)).return=e,t;case N:return u(e,(0,t._init)(t._payload),n)}if(te(t)||C(t))return(t=Lc(t,e.mode,n,null)).return=e,t;Hs(e,t)}return null}function h(e,t,n,o){var i=null!==t?t.key:null;if("string"==typeof n&&""!==n||"number"==typeof n)return null!==i?null:p(e,t,""+n,o);if("object"==typeof n&&null!==n){switch(n.$$typeof){case v:return n.key===i?c(e,t,n,o):null;case P:return n.key===i?d(e,t,n,o):null;case N:return h(e,t,(i=n._init)(n._payload),o)}if(te(n)||C(n))return null!==i?null:l(e,t,n,o,null);Hs(e,n)}return null}function f(e,t,n,o,i){if("string"==typeof o&&""!==o||"number"==typeof o)return p(t,e=e.get(n)||null,""+o,i);if("object"==typeof o&&null!==o){switch(o.$$typeof){case v:return c(t,e=e.get(null===o.key?n:o.key)||null,o,i);case P:return d(t,e=e.get(null===o.key?n:o.key)||null,o,i);case N:return f(e,t,n,(0,o._init)(o._payload),i)}if(te(o)||C(o))return l(t,e=e.get(n)||null,o,i,null);Hs(t,o)}return null}function y(i,s,r,p){for(var c=null,d=null,l=s,y=s=0,m=null;null!==l&&y<r.length;y++){l.index>y?(m=l,l=null):m=l.sibling;var g=h(i,l,r[y],p);if(null===g){null===l&&(l=m);break}e&&l&&null===g.alternate&&t(i,l),s=a(g,s,y),null===d?c=g:d.sibling=g,d=g,l=m}if(y===r.length)return n(i,l),ss&&Xi(i,y),c;if(null===l){for(;y<r.length;y++)null!==(l=u(i,r[y],p))&&(s=a(l,s,y),null===d?c=l:d.sibling=l,d=l);return ss&&Xi(i,y),c}for(l=o(i,l);y<r.length;y++)null!==(m=f(l,i,y,r[y],p))&&(e&&null!==m.alternate&&l.delete(null===m.key?y:m.key),s=a(m,s,y),null===d?c=m:d.sibling=m,d=m);return e&&l.forEach((function(e){return t(i,e)})),ss&&Xi(i,y),c}function m(i,r,p,c){var d=C(p);if("function"!=typeof d)throw Error(s(150));if(null==(p=d.call(p)))throw Error(s(151));for(var l=d=null,y=r,m=r=0,g=null,_=p.next();null!==y&&!_.done;m++,_=p.next()){y.index>m?(g=y,y=null):g=y.sibling;var b=h(i,y,_.value,c);if(null===b){null===y&&(y=g);break}e&&y&&null===b.alternate&&t(i,y),r=a(b,r,m),null===l?d=b:l.sibling=b,l=b,y=g}if(_.done)return n(i,y),ss&&Xi(i,m),d;if(null===y){for(;!_.done;m++,_=p.next())null!==(_=u(i,_.value,c))&&(r=a(_,r,m),null===l?d=_:l.sibling=_,l=_);return ss&&Xi(i,m),d}for(y=o(i,y);!_.done;m++,_=p.next())null!==(_=f(y,i,m,_.value,c))&&(e&&null!==_.alternate&&y.delete(null===_.key?m:_.key),r=a(_,r,m),null===l?d=_:l.sibling=_,l=_);return e&&y.forEach((function(e){return t(i,e)})),ss&&Xi(i,m),d}return function e(o,s,a,p){if("object"==typeof a&&null!==a&&a.type===E&&null===a.key&&(a=a.props.children),"object"==typeof a&&null!==a){switch(a.$$typeof){case v:e:{for(var c=a.key,d=s;null!==d;){if(d.key===c){if((c=a.type)===E){if(7===d.tag){n(o,d.sibling),(s=i(d,a.props.children)).return=o,o=s;break e}}else if(d.elementType===c||"object"==typeof c&&null!==c&&c.$$typeof===N&&Ws(c)===d.type){n(o,d.sibling),(s=i(d,a.props)).ref=Qs(o,d,a),s.return=o,o=s;break e}n(o,d);break}t(o,d),d=d.sibling}a.type===E?((s=Lc(a.props.children,o.mode,p,a.key)).return=o,o=s):((p=Cc(a.type,a.key,a.props,null,o.mode,p)).ref=Qs(o,s,a),p.return=o,o=p)}return r(o);case P:e:{for(d=a.key;null!==s;){if(s.key===d){if(4===s.tag&&s.stateNode.containerInfo===a.containerInfo&&s.stateNode.implementation===a.implementation){n(o,s.sibling),(s=i(s,a.children||[])).return=o,o=s;break e}n(o,s);break}t(o,s),s=s.sibling}(s=Fc(a,o.mode,p)).return=o,o=s}return r(o);case N:return e(o,s,(d=a._init)(a._payload),p)}if(te(a))return y(o,s,a,p);if(C(a))return m(o,s,a,p);Hs(o,a)}return"string"==typeof a&&""!==a||"number"==typeof a?(a=""+a,null!==s&&6===s.tag?(n(o,s.sibling),(s=i(s,a)).return=o,o=s):(n(o,s),(s=qc(a,o.mode,p)).return=o,o=s),r(o)):n(o,s)}}var $s=Ks(!0),Zs=Ks(!1),Xs={},ea=Ai(Xs),ta=Ai(Xs),na=Ai(Xs);function oa(e){if(e===Xs)throw Error(s(174));return e}function ia(e,t){switch(wi(na,t),wi(ta,e),wi(ea,Xs),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:pe(null,"");break;default:t=pe(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}ki(ea),wi(ea,t)}function sa(){ki(ea),ki(ta),ki(na)}function aa(e){oa(na.current);var t=oa(ea.current),n=pe(t,e.type);t!==n&&(wi(ta,e),wi(ea,n))}function ra(e){ta.current===e&&(ki(ea),ki(ta))}var pa=Ai(0);function ca(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!=(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var da=[];function la(){for(var e=0;e<da.length;e++)da[e]._workInProgressVersionPrimary=null;da.length=0}var ua=T.ReactCurrentDispatcher,ha=T.ReactCurrentBatchConfig,fa=0,ya=null,ma=null,ga=null,_a=!1,ba=!1,Ta=0,va=0;function Pa(){throw Error(s(321))}function Ea(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!ro(e[n],t[n]))return!1;return!0}function Ra(e,t,n,o,i,a){if(fa=a,ya=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,ua.current=null===e||null===e.memoizedState?rr:pr,e=n(o,i),ba){a=0;do{if(ba=!1,Ta=0,25<=a)throw Error(s(301));a+=1,ga=ma=null,t.updateQueue=null,ua.current=cr,e=n(o,i)}while(ba)}if(ua.current=ar,t=null!==ma&&null!==ma.next,fa=0,ga=ma=ya=null,_a=!1,t)throw Error(s(300));return e}function Aa(){var e=0!==Ta;return Ta=0,e}function ka(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===ga?ya.memoizedState=ga=e:ga=ga.next=e,ga}function wa(){if(null===ma){var e=ya.alternate;e=null!==e?e.memoizedState:null}else e=ma.next;var t=null===ga?ya.memoizedState:ga.next;if(null!==t)ga=t,ma=e;else{if(null===e)throw Error(s(310));e={memoizedState:(ma=e).memoizedState,baseState:ma.baseState,baseQueue:ma.baseQueue,queue:ma.queue,next:null},null===ga?ya.memoizedState=ga=e:ga=ga.next=e}return ga}function Sa(e,t){return"function"==typeof t?t(e):t}function Ia(e){var t=wa(),n=t.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=e;var o=ma,i=o.baseQueue,a=n.pending;if(null!==a){if(null!==i){var r=i.next;i.next=a.next,a.next=r}o.baseQueue=i=a,n.pending=null}if(null!==i){a=i.next,o=o.baseState;var p=r=null,c=null,d=a;do{var l=d.lane;if((fa&l)===l)null!==c&&(c=c.next={lane:0,action:d.action,hasEagerState:d.hasEagerState,eagerState:d.eagerState,next:null}),o=d.hasEagerState?d.eagerState:e(o,d.action);else{var u={lane:l,action:d.action,hasEagerState:d.hasEagerState,eagerState:d.eagerState,next:null};null===c?(p=c=u,r=o):c=c.next=u,ya.lanes|=l,Dp|=l}d=d.next}while(null!==d&&d!==a);null===c?r=o:c.next=p,ro(o,t.memoizedState)||(Tr=!0),t.memoizedState=o,t.baseState=r,t.baseQueue=c,n.lastRenderedState=o}if(null!==(e=n.interleaved)){i=e;do{a=i.lane,ya.lanes|=a,Dp|=a,i=i.next}while(i!==e)}else null===i&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function Oa(e){var t=wa(),n=t.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=e;var o=n.dispatch,i=n.pending,a=t.memoizedState;if(null!==i){n.pending=null;var r=i=i.next;do{a=e(a,r.action),r=r.next}while(r!==i);ro(a,t.memoizedState)||(Tr=!0),t.memoizedState=a,null===t.baseQueue&&(t.baseState=a),n.lastRenderedState=a}return[a,o]}function xa(){}function Na(e,t){var n=ya,o=wa(),i=t(),a=!ro(o.memoizedState,i);if(a&&(o.memoizedState=i,Tr=!0),o=o.queue,Ga(Ca.bind(null,n,o,e),[e]),o.getSnapshot!==t||a||null!==ga&&1&ga.memoizedState.tag){if(n.flags|=2048,Fa(9,Ya.bind(null,n,o,i,t),void 0,null),null===Op)throw Error(s(349));0!=(30&fa)||Ua(n,t,i)}return i}function Ua(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=ya.updateQueue)?(t={lastEffect:null,stores:null},ya.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Ya(e,t,n,o){t.value=n,t.getSnapshot=o,La(t)&&Da(e)}function Ca(e,t,n){return n((function(){La(t)&&Da(e)}))}function La(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!ro(e,n)}catch(o){return!0}}function Da(e){var t=Os(e,1);null!==t&&oc(t,e,1,-1)}function qa(e){var t=ka();return"function"==typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Sa,lastRenderedState:e},t.queue=e,e=e.dispatch=nr.bind(null,ya,e),[t.memoizedState,e]}function Fa(e,t,n,o){return e={tag:e,create:t,destroy:n,deps:o,next:null},null===(t=ya.updateQueue)?(t={lastEffect:null,stores:null},ya.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(o=n.next,n.next=e,e.next=o,t.lastEffect=e),e}function ja(){return wa().memoizedState}function Ma(e,t,n,o){var i=ka();ya.flags|=e,i.memoizedState=Fa(1|t,n,void 0,void 0===o?null:o)}function za(e,t,n,o){var i=wa();o=void 0===o?null:o;var s=void 0;if(null!==ma){var a=ma.memoizedState;if(s=a.destroy,null!==o&&Ea(o,a.deps))return void(i.memoizedState=Fa(t,n,s,o))}ya.flags|=e,i.memoizedState=Fa(1|t,n,s,o)}function Va(e,t){return Ma(8390656,8,e,t)}function Ga(e,t){return za(2048,8,e,t)}function Ba(e,t){return za(4,2,e,t)}function Ja(e,t){return za(4,4,e,t)}function Qa(e,t){return"function"==typeof t?(e=e(),t(e),function(){t(null)}):null!=t?(e=e(),t.current=e,function(){t.current=null}):void 0}function Ha(e,t,n){return n=null!=n?n.concat([e]):null,za(4,4,Qa.bind(null,t,e),n)}function Wa(){}function Ka(e,t){var n=wa();t=void 0===t?null:t;var o=n.memoizedState;return null!==o&&null!==t&&Ea(t,o[1])?o[0]:(n.memoizedState=[e,t],e)}function $a(e,t){var n=wa();t=void 0===t?null:t;var o=n.memoizedState;return null!==o&&null!==t&&Ea(t,o[1])?o[0]:(e=e(),n.memoizedState=[e,t],e)}function Za(e,t,n){return 0==(21&fa)?(e.baseState&&(e.baseState=!1,Tr=!0),e.memoizedState=n):(ro(n,t)||(n=yt(),ya.lanes|=n,Dp|=n,e.baseState=!0),t)}function Xa(e,t){var n=bt;bt=0!==n&&4>n?n:4,e(!0);var o=ha.transition;ha.transition={};try{e(!1),t()}finally{bt=n,ha.transition=o}}function er(){return wa().memoizedState}function tr(e,t,n){var o=nc(e);if(n={lane:o,action:n,hasEagerState:!1,eagerState:null,next:null},or(e))ir(t,n);else if(null!==(n=Is(e,t,n,o))){oc(n,e,o,tc()),sr(n,t,o)}}function nr(e,t,n){var o=nc(e),i={lane:o,action:n,hasEagerState:!1,eagerState:null,next:null};if(or(e))ir(t,i);else{var s=e.alternate;if(0===e.lanes&&(null===s||0===s.lanes)&&null!==(s=t.lastRenderedReducer))try{var a=t.lastRenderedState,r=s(a,n);if(i.hasEagerState=!0,i.eagerState=r,ro(r,a)){var p=t.interleaved;return null===p?(i.next=i,Ss(t)):(i.next=p.next,p.next=i),void(t.interleaved=i)}}catch(c){}null!==(n=Is(e,t,i,o))&&(oc(n,e,o,i=tc()),sr(n,t,o))}}function or(e){var t=e.alternate;return e===ya||null!==t&&t===ya}function ir(e,t){ba=_a=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function sr(e,t,n){if(0!=(4194240&n)){var o=t.lanes;n|=o&=e.pendingLanes,t.lanes=n,_t(e,n)}}var ar={readContext:ks,useCallback:Pa,useContext:Pa,useEffect:Pa,useImperativeHandle:Pa,useInsertionEffect:Pa,useLayoutEffect:Pa,useMemo:Pa,useReducer:Pa,useRef:Pa,useState:Pa,useDebugValue:Pa,useDeferredValue:Pa,useTransition:Pa,useMutableSource:Pa,useSyncExternalStore:Pa,useId:Pa,unstable_isNewReconciler:!1},rr={readContext:ks,useCallback:function(e,t){return ka().memoizedState=[e,void 0===t?null:t],e},useContext:ks,useEffect:Va,useImperativeHandle:function(e,t,n){return n=null!=n?n.concat([e]):null,Ma(4194308,4,Qa.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Ma(4194308,4,e,t)},useInsertionEffect:function(e,t){return Ma(4,2,e,t)},useMemo:function(e,t){var n=ka();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var o=ka();return t=void 0!==n?n(t):t,o.memoizedState=o.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},o.queue=e,e=e.dispatch=tr.bind(null,ya,e),[o.memoizedState,e]},useRef:function(e){return e={current:e},ka().memoizedState=e},useState:qa,useDebugValue:Wa,useDeferredValue:function(e){return ka().memoizedState=e},useTransition:function(){var e=qa(!1),t=e[0];return e=Xa.bind(null,e[1]),ka().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var o=ya,i=ka();if(ss){if(void 0===n)throw Error(s(407));n=n()}else{if(n=t(),null===Op)throw Error(s(349));0!=(30&fa)||Ua(o,t,n)}i.memoizedState=n;var a={value:n,getSnapshot:t};return i.queue=a,Va(Ca.bind(null,o,a,e),[e]),o.flags|=2048,Fa(9,Ya.bind(null,o,a,n,t),void 0,null),n},useId:function(){var e=ka(),t=Op.identifierPrefix;if(ss){var n=Zi;t=":"+t+"R"+(n=($i&~(1<<32-at($i)-1)).toString(32)+n),0<(n=Ta++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=va++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},pr={readContext:ks,useCallback:Ka,useContext:ks,useEffect:Ga,useImperativeHandle:Ha,useInsertionEffect:Ba,useLayoutEffect:Ja,useMemo:$a,useReducer:Ia,useRef:ja,useState:function(){return Ia(Sa)},useDebugValue:Wa,useDeferredValue:function(e){return Za(wa(),ma.memoizedState,e)},useTransition:function(){return[Ia(Sa)[0],wa().memoizedState]},useMutableSource:xa,useSyncExternalStore:Na,useId:er,unstable_isNewReconciler:!1},cr={readContext:ks,useCallback:Ka,useContext:ks,useEffect:Ga,useImperativeHandle:Ha,useInsertionEffect:Ba,useLayoutEffect:Ja,useMemo:$a,useReducer:Oa,useRef:ja,useState:function(){return Oa(Sa)},useDebugValue:Wa,useDeferredValue:function(e){var t=wa();return null===ma?t.memoizedState=e:Za(t,ma.memoizedState,e)},useTransition:function(){return[Oa(Sa)[0],wa().memoizedState]},useMutableSource:xa,useSyncExternalStore:Na,useId:er,unstable_isNewReconciler:!1};function dr(e,t){try{var n="",o=t;do{n+=M(o),o=o.return}while(o);var i=n}catch(s){i="\nError generating stack: "+s.message+"\n"+s.stack}return{value:e,source:t,stack:i,digest:null}}function lr(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function ur(e,t){try{console.error(t.value)}catch(n){setTimeout((function(){throw n}))}}var hr="function"==typeof WeakMap?WeakMap:Map;function fr(e,t,n){(n=Ys(-1,n)).tag=3,n.payload={element:null};var o=t.value;return n.callback=function(){Bp||(Bp=!0,Jp=o),ur(0,t)},n}function yr(e,t,n){(n=Ys(-1,n)).tag=3;var o=e.type.getDerivedStateFromError;if("function"==typeof o){var i=t.value;n.payload=function(){return o(i)},n.callback=function(){ur(0,t)}}var s=e.stateNode;return null!==s&&"function"==typeof s.componentDidCatch&&(n.callback=function(){ur(0,t),"function"!=typeof o&&(null===Qp?Qp=new Set([this]):Qp.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function mr(e,t,n){var o=e.pingCache;if(null===o){o=e.pingCache=new hr;var i=new Set;o.set(t,i)}else void 0===(i=o.get(t))&&(i=new Set,o.set(t,i));i.has(n)||(i.add(n),e=kc.bind(null,e,t,n),t.then(e,e))}function gr(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function _r(e,t,n,o,i){return 0==(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Ys(-1,1)).tag=2,Cs(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=i,e)}var br=T.ReactCurrentOwner,Tr=!1;function vr(e,t,n,o){t.child=null===e?Zs(t,null,n,o):$s(t,e.child,n,o)}function Pr(e,t,n,o,i){n=n.render;var s=t.ref;return As(t,i),o=Ra(e,t,n,o,s,i),n=Aa(),null===e||Tr?(ss&&n&&ts(t),t.flags|=1,vr(e,t,o,i),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~i,Br(e,t,i))}function Er(e,t,n,o,i){if(null===e){var s=n.type;return"function"!=typeof s||Uc(s)||void 0!==s.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Cc(n.type,null,o,t,t.mode,i)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=s,Rr(e,t,s,o,i))}if(s=e.child,0==(e.lanes&i)){var a=s.memoizedProps;if((n=null!==(n=n.compare)?n:po)(a,o)&&e.ref===t.ref)return Br(e,t,i)}return t.flags|=1,(e=Yc(s,o)).ref=t.ref,e.return=t,t.child=e}function Rr(e,t,n,o,i){if(null!==e){var s=e.memoizedProps;if(po(s,o)&&e.ref===t.ref){if(Tr=!1,t.pendingProps=o=s,0==(e.lanes&i))return t.lanes=e.lanes,Br(e,t,i);0!=(131072&e.flags)&&(Tr=!0)}}return wr(e,t,n,o,i)}function Ar(e,t,n){var o=t.pendingProps,i=o.children,s=null!==e?e.memoizedState:null;if("hidden"===o.mode)if(0==(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},wi(Yp,Up),Up|=n;else{if(0==(1073741824&n))return e=null!==s?s.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,wi(Yp,Up),Up|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},o=null!==s?s.baseLanes:n,wi(Yp,Up),Up|=o}else null!==s?(o=s.baseLanes|n,t.memoizedState=null):o=n,wi(Yp,Up),Up|=o;return vr(e,t,i,n),t.child}function kr(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function wr(e,t,n,o,i){var s=Ui(n)?xi:Ii.current;return s=Ni(t,s),As(t,i),n=Ra(e,t,n,o,s,i),o=Aa(),null===e||Tr?(ss&&o&&ts(t),t.flags|=1,vr(e,t,n,i),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~i,Br(e,t,i))}function Sr(e,t,n,o,i){if(Ui(n)){var s=!0;Di(t)}else s=!1;if(As(t,i),null===t.stateNode)Gr(e,t),Gs(t,n,o),Js(t,n,o,i),o=!0;else if(null===e){var a=t.stateNode,r=t.memoizedProps;a.props=r;var p=a.context,c=n.contextType;"object"==typeof c&&null!==c?c=ks(c):c=Ni(t,c=Ui(n)?xi:Ii.current);var d=n.getDerivedStateFromProps,l="function"==typeof d||"function"==typeof a.getSnapshotBeforeUpdate;l||"function"!=typeof a.UNSAFE_componentWillReceiveProps&&"function"!=typeof a.componentWillReceiveProps||(r!==o||p!==c)&&Bs(t,a,o,c),xs=!1;var u=t.memoizedState;a.state=u,qs(t,o,a,i),p=t.memoizedState,r!==o||u!==p||Oi.current||xs?("function"==typeof d&&(Ms(t,n,d,o),p=t.memoizedState),(r=xs||Vs(t,n,r,o,u,p,c))?(l||"function"!=typeof a.UNSAFE_componentWillMount&&"function"!=typeof a.componentWillMount||("function"==typeof a.componentWillMount&&a.componentWillMount(),"function"==typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount()),"function"==typeof a.componentDidMount&&(t.flags|=4194308)):("function"==typeof a.componentDidMount&&(t.flags|=4194308),t.memoizedProps=o,t.memoizedState=p),a.props=o,a.state=p,a.context=c,o=r):("function"==typeof a.componentDidMount&&(t.flags|=4194308),o=!1)}else{a=t.stateNode,Us(e,t),r=t.memoizedProps,c=t.type===t.elementType?r:gs(t.type,r),a.props=c,l=t.pendingProps,u=a.context,"object"==typeof(p=n.contextType)&&null!==p?p=ks(p):p=Ni(t,p=Ui(n)?xi:Ii.current);var h=n.getDerivedStateFromProps;(d="function"==typeof h||"function"==typeof a.getSnapshotBeforeUpdate)||"function"!=typeof a.UNSAFE_componentWillReceiveProps&&"function"!=typeof a.componentWillReceiveProps||(r!==l||u!==p)&&Bs(t,a,o,p),xs=!1,u=t.memoizedState,a.state=u,qs(t,o,a,i);var f=t.memoizedState;r!==l||u!==f||Oi.current||xs?("function"==typeof h&&(Ms(t,n,h,o),f=t.memoizedState),(c=xs||Vs(t,n,c,o,u,f,p)||!1)?(d||"function"!=typeof a.UNSAFE_componentWillUpdate&&"function"!=typeof a.componentWillUpdate||("function"==typeof a.componentWillUpdate&&a.componentWillUpdate(o,f,p),"function"==typeof a.UNSAFE_componentWillUpdate&&a.UNSAFE_componentWillUpdate(o,f,p)),"function"==typeof a.componentDidUpdate&&(t.flags|=4),"function"==typeof a.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!=typeof a.componentDidUpdate||r===e.memoizedProps&&u===e.memoizedState||(t.flags|=4),"function"!=typeof a.getSnapshotBeforeUpdate||r===e.memoizedProps&&u===e.memoizedState||(t.flags|=1024),t.memoizedProps=o,t.memoizedState=f),a.props=o,a.state=f,a.context=p,o=c):("function"!=typeof a.componentDidUpdate||r===e.memoizedProps&&u===e.memoizedState||(t.flags|=4),"function"!=typeof a.getSnapshotBeforeUpdate||r===e.memoizedProps&&u===e.memoizedState||(t.flags|=1024),o=!1)}return Ir(e,t,n,o,s,i)}function Ir(e,t,n,o,i,s){kr(e,t);var a=0!=(128&t.flags);if(!o&&!a)return i&&qi(t,n,!1),Br(e,t,s);o=t.stateNode,br.current=t;var r=a&&"function"!=typeof n.getDerivedStateFromError?null:o.render();return t.flags|=1,null!==e&&a?(t.child=$s(t,e.child,null,s),t.child=$s(t,null,r,s)):vr(e,t,r,s),t.memoizedState=o.state,i&&qi(t,n,!0),t.child}function Or(e){var t=e.stateNode;t.pendingContext?Ci(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Ci(0,t.context,!1),ia(e,t.containerInfo)}function xr(e,t,n,o,i){return fs(),ys(i),t.flags|=256,vr(e,t,n,o),t.child}var Nr,Ur,Yr,Cr,Lr={dehydrated:null,treeContext:null,retryLane:0};function Dr(e){return{baseLanes:e,cachePool:null,transitions:null}}function qr(e,t,n){var o,i=t.pendingProps,a=pa.current,r=!1,p=0!=(128&t.flags);if((o=p)||(o=(null===e||null!==e.memoizedState)&&0!=(2&a)),o?(r=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(a|=1),wi(pa,1&a),null===e)return ds(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0==(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(p=i.children,e=i.fallback,r?(i=t.mode,r=t.child,p={mode:"hidden",children:p},0==(1&i)&&null!==r?(r.childLanes=0,r.pendingProps=p):r=Dc(p,i,0,null),e=Lc(e,i,n,null),r.return=t,e.return=t,r.sibling=e,t.child=r,t.child.memoizedState=Dr(n),t.memoizedState=Lr,e):Fr(t,p));if(null!==(a=e.memoizedState)&&null!==(o=a.dehydrated))return function(e,t,n,o,i,a,r){if(n)return 256&t.flags?(t.flags&=-257,jr(e,t,r,o=lr(Error(s(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(a=o.fallback,i=t.mode,o=Dc({mode:"visible",children:o.children},i,0,null),(a=Lc(a,i,r,null)).flags|=2,o.return=t,a.return=t,o.sibling=a,t.child=o,0!=(1&t.mode)&&$s(t,e.child,null,r),t.child.memoizedState=Dr(r),t.memoizedState=Lr,a);if(0==(1&t.mode))return jr(e,t,r,null);if("$!"===i.data){if(o=i.nextSibling&&i.nextSibling.dataset)var p=o.dgst;return o=p,jr(e,t,r,o=lr(a=Error(s(419)),o,void 0))}if(p=0!=(r&e.childLanes),Tr||p){if(null!==(o=Op)){switch(r&-r){case 4:i=2;break;case 16:i=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:i=32;break;case 536870912:i=268435456;break;default:i=0}0!==(i=0!=(i&(o.suspendedLanes|r))?0:i)&&i!==a.retryLane&&(a.retryLane=i,Os(e,i),oc(o,e,i,-1))}return mc(),jr(e,t,r,o=lr(Error(s(421))))}return"$?"===i.data?(t.flags|=128,t.child=e.child,t=Sc.bind(null,e),i._reactRetry=t,null):(e=a.treeContext,is=di(i.nextSibling),os=t,ss=!0,as=null,null!==e&&(Hi[Wi++]=$i,Hi[Wi++]=Zi,Hi[Wi++]=Ki,$i=e.id,Zi=e.overflow,Ki=t),t=Fr(t,o.children),t.flags|=4096,t)}(e,t,p,i,o,a,n);if(r){r=i.fallback,p=t.mode,o=(a=e.child).sibling;var c={mode:"hidden",children:i.children};return 0==(1&p)&&t.child!==a?((i=t.child).childLanes=0,i.pendingProps=c,t.deletions=null):(i=Yc(a,c)).subtreeFlags=14680064&a.subtreeFlags,null!==o?r=Yc(o,r):(r=Lc(r,p,n,null)).flags|=2,r.return=t,i.return=t,i.sibling=r,t.child=i,i=r,r=t.child,p=null===(p=e.child.memoizedState)?Dr(n):{baseLanes:p.baseLanes|n,cachePool:null,transitions:p.transitions},r.memoizedState=p,r.childLanes=e.childLanes&~n,t.memoizedState=Lr,i}return e=(r=e.child).sibling,i=Yc(r,{mode:"visible",children:i.children}),0==(1&t.mode)&&(i.lanes=n),i.return=t,i.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=i,t.memoizedState=null,i}function Fr(e,t){return(t=Dc({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function jr(e,t,n,o){return null!==o&&ys(o),$s(t,e.child,null,n),(e=Fr(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Mr(e,t,n){e.lanes|=t;var o=e.alternate;null!==o&&(o.lanes|=t),Rs(e.return,t,n)}function zr(e,t,n,o,i){var s=e.memoizedState;null===s?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:o,tail:n,tailMode:i}:(s.isBackwards=t,s.rendering=null,s.renderingStartTime=0,s.last=o,s.tail=n,s.tailMode=i)}function Vr(e,t,n){var o=t.pendingProps,i=o.revealOrder,s=o.tail;if(vr(e,t,o.children,n),0!=(2&(o=pa.current)))o=1&o|2,t.flags|=128;else{if(null!==e&&0!=(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Mr(e,n,t);else if(19===e.tag)Mr(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}o&=1}if(wi(pa,o),0==(1&t.mode))t.memoizedState=null;else switch(i){case"forwards":for(n=t.child,i=null;null!==n;)null!==(e=n.alternate)&&null===ca(e)&&(i=n),n=n.sibling;null===(n=i)?(i=t.child,t.child=null):(i=n.sibling,n.sibling=null),zr(t,!1,i,n,s);break;case"backwards":for(n=null,i=t.child,t.child=null;null!==i;){if(null!==(e=i.alternate)&&null===ca(e)){t.child=i;break}e=i.sibling,i.sibling=n,n=i,i=e}zr(t,!0,n,null,s);break;case"together":zr(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Gr(e,t){0==(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Br(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Dp|=t.lanes,0==(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(s(153));if(null!==t.child){for(n=Yc(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Yc(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Jr(e,t){if(!ss)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var o=null;null!==n;)null!==n.alternate&&(o=n),n=n.sibling;null===o?t||null===e.tail?e.tail=null:e.tail.sibling=null:o.sibling=null}}function Qr(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,o=0;if(t)for(var i=e.child;null!==i;)n|=i.lanes|i.childLanes,o|=14680064&i.subtreeFlags,o|=14680064&i.flags,i.return=e,i=i.sibling;else for(i=e.child;null!==i;)n|=i.lanes|i.childLanes,o|=i.subtreeFlags,o|=i.flags,i.return=e,i=i.sibling;return e.subtreeFlags|=o,e.childLanes=n,t}function Hr(e,t,n){var o=t.pendingProps;switch(ns(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Qr(t),null;case 1:case 17:return Ui(t.type)&&Yi(),Qr(t),null;case 3:return o=t.stateNode,sa(),ki(Oi),ki(Ii),la(),o.pendingContext&&(o.context=o.pendingContext,o.pendingContext=null),null!==e&&null!==e.child||(us(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0==(256&t.flags)||(t.flags|=1024,null!==as&&(rc(as),as=null))),Ur(e,t),Qr(t),null;case 5:ra(t);var i=oa(na.current);if(n=t.type,null!==e&&null!=t.stateNode)Yr(e,t,n,o,i),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!o){if(null===t.stateNode)throw Error(s(166));return Qr(t),null}if(e=oa(ea.current),us(t)){o=t.stateNode,n=t.type;var a=t.memoizedProps;switch(o[hi]=t,o[fi]=a,e=0!=(1&t.mode),n){case"dialog":jo("cancel",o),jo("close",o);break;case"iframe":case"object":case"embed":jo("load",o);break;case"video":case"audio":for(i=0;i<Lo.length;i++)jo(Lo[i],o);break;case"source":jo("error",o);break;case"img":case"image":case"link":jo("error",o),jo("load",o);break;case"details":jo("toggle",o);break;case"input":K(o,a),jo("invalid",o);break;case"select":o._wrapperState={wasMultiple:!!a.multiple},jo("invalid",o);break;case"textarea":ie(o,a),jo("invalid",o)}for(var p in _e(n,a),i=null,a)if(a.hasOwnProperty(p)){var c=a[p];"children"===p?"string"==typeof c?o.textContent!==c&&(!0!==a.suppressHydrationWarning&&Xo(o.textContent,c,e),i=["children",c]):"number"==typeof c&&o.textContent!==""+c&&(!0!==a.suppressHydrationWarning&&Xo(o.textContent,c,e),i=["children",""+c]):r.hasOwnProperty(p)&&null!=c&&"onScroll"===p&&jo("scroll",o)}switch(n){case"input":J(o),X(o,a,!0);break;case"textarea":J(o),ae(o);break;case"select":case"option":break;default:"function"==typeof a.onClick&&(o.onclick=ei)}o=i,t.updateQueue=o,null!==o&&(t.flags|=4)}else{p=9===i.nodeType?i:i.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=re(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=p.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"==typeof o.is?e=p.createElement(n,{is:o.is}):(e=p.createElement(n),"select"===n&&(p=e,o.multiple?p.multiple=!0:o.size&&(p.size=o.size))):e=p.createElementNS(e,n),e[hi]=t,e[fi]=o,Nr(e,t,!1,!1),t.stateNode=e;e:{switch(p=be(n,o),n){case"dialog":jo("cancel",e),jo("close",e),i=o;break;case"iframe":case"object":case"embed":jo("load",e),i=o;break;case"video":case"audio":for(i=0;i<Lo.length;i++)jo(Lo[i],e);i=o;break;case"source":jo("error",e),i=o;break;case"img":case"image":case"link":jo("error",e),jo("load",e),i=o;break;case"details":jo("toggle",e),i=o;break;case"input":K(e,o),i=W(e,o),jo("invalid",e);break;case"option":default:i=o;break;case"select":e._wrapperState={wasMultiple:!!o.multiple},i=D({},o,{value:void 0}),jo("invalid",e);break;case"textarea":ie(e,o),i=oe(e,o),jo("invalid",e)}for(a in _e(n,i),c=i)if(c.hasOwnProperty(a)){var d=c[a];"style"===a?me(e,d):"dangerouslySetInnerHTML"===a?null!=(d=d?d.__html:void 0)&&le(e,d):"children"===a?"string"==typeof d?("textarea"!==n||""!==d)&&ue(e,d):"number"==typeof d&&ue(e,""+d):"suppressContentEditableWarning"!==a&&"suppressHydrationWarning"!==a&&"autoFocus"!==a&&(r.hasOwnProperty(a)?null!=d&&"onScroll"===a&&jo("scroll",e):null!=d&&b(e,a,d,p))}switch(n){case"input":J(e),X(e,o,!1);break;case"textarea":J(e),ae(e);break;case"option":null!=o.value&&e.setAttribute("value",""+G(o.value));break;case"select":e.multiple=!!o.multiple,null!=(a=o.value)?ne(e,!!o.multiple,a,!1):null!=o.defaultValue&&ne(e,!!o.multiple,o.defaultValue,!0);break;default:"function"==typeof i.onClick&&(e.onclick=ei)}switch(n){case"button":case"input":case"select":case"textarea":o=!!o.autoFocus;break e;case"img":o=!0;break e;default:o=!1}}o&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return Qr(t),null;case 6:if(e&&null!=t.stateNode)Cr(e,t,e.memoizedProps,o);else{if("string"!=typeof o&&null===t.stateNode)throw Error(s(166));if(n=oa(na.current),oa(ea.current),us(t)){if(o=t.stateNode,n=t.memoizedProps,o[hi]=t,(a=o.nodeValue!==n)&&null!==(e=os))switch(e.tag){case 3:Xo(o.nodeValue,n,0!=(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Xo(o.nodeValue,n,0!=(1&e.mode))}a&&(t.flags|=4)}else(o=(9===n.nodeType?n:n.ownerDocument).createTextNode(o))[hi]=t,t.stateNode=o}return Qr(t),null;case 13:if(ki(pa),o=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(ss&&null!==is&&0!=(1&t.mode)&&0==(128&t.flags))hs(),fs(),t.flags|=98560,a=!1;else if(a=us(t),null!==o&&null!==o.dehydrated){if(null===e){if(!a)throw Error(s(318));if(!(a=null!==(a=t.memoizedState)?a.dehydrated:null))throw Error(s(317));a[hi]=t}else fs(),0==(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Qr(t),a=!1}else null!==as&&(rc(as),as=null),a=!0;if(!a)return 65536&t.flags?t:null}return 0!=(128&t.flags)?(t.lanes=n,t):((o=null!==o)!==(null!==e&&null!==e.memoizedState)&&o&&(t.child.flags|=8192,0!=(1&t.mode)&&(null===e||0!=(1&pa.current)?0===Cp&&(Cp=3):mc())),null!==t.updateQueue&&(t.flags|=4),Qr(t),null);case 4:return sa(),Ur(e,t),null===e&&Vo(t.stateNode.containerInfo),Qr(t),null;case 10:return Es(t.type._context),Qr(t),null;case 19:if(ki(pa),null===(a=t.memoizedState))return Qr(t),null;if(o=0!=(128&t.flags),null===(p=a.rendering))if(o)Jr(a,!1);else{if(0!==Cp||null!==e&&0!=(128&e.flags))for(e=t.child;null!==e;){if(null!==(p=ca(e))){for(t.flags|=128,Jr(a,!1),null!==(o=p.updateQueue)&&(t.updateQueue=o,t.flags|=4),t.subtreeFlags=0,o=n,n=t.child;null!==n;)e=o,(a=n).flags&=14680066,null===(p=a.alternate)?(a.childLanes=0,a.lanes=e,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=p.childLanes,a.lanes=p.lanes,a.child=p.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=p.memoizedProps,a.memoizedState=p.memoizedState,a.updateQueue=p.updateQueue,a.type=p.type,e=p.dependencies,a.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return wi(pa,1&pa.current|2),t.child}e=e.sibling}null!==a.tail&&$e()>Vp&&(t.flags|=128,o=!0,Jr(a,!1),t.lanes=4194304)}else{if(!o)if(null!==(e=ca(p))){if(t.flags|=128,o=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Jr(a,!0),null===a.tail&&"hidden"===a.tailMode&&!p.alternate&&!ss)return Qr(t),null}else 2*$e()-a.renderingStartTime>Vp&&1073741824!==n&&(t.flags|=128,o=!0,Jr(a,!1),t.lanes=4194304);a.isBackwards?(p.sibling=t.child,t.child=p):(null!==(n=a.last)?n.sibling=p:t.child=p,a.last=p)}return null!==a.tail?(t=a.tail,a.rendering=t,a.tail=t.sibling,a.renderingStartTime=$e(),t.sibling=null,n=pa.current,wi(pa,o?1&n|2:1&n),t):(Qr(t),null);case 22:case 23:return uc(),o=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==o&&(t.flags|=8192),o&&0!=(1&t.mode)?0!=(1073741824&Up)&&(Qr(t),6&t.subtreeFlags&&(t.flags|=8192)):Qr(t),null;case 24:case 25:return null}throw Error(s(156,t.tag))}function Wr(e,t){switch(ns(t),t.tag){case 1:return Ui(t.type)&&Yi(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return sa(),ki(Oi),ki(Ii),la(),0!=(65536&(e=t.flags))&&0==(128&e)?(t.flags=-65537&e|128,t):null;case 5:return ra(t),null;case 13:if(ki(pa),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(s(340));fs()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return ki(pa),null;case 4:return sa(),null;case 10:return Es(t.type._context),null;case 22:case 23:return uc(),null;default:return null}}Nr=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Ur=function(){},Yr=function(e,t,n,o){var i=e.memoizedProps;if(i!==o){e=t.stateNode,oa(ea.current);var s,a=null;switch(n){case"input":i=W(e,i),o=W(e,o),a=[];break;case"select":i=D({},i,{value:void 0}),o=D({},o,{value:void 0}),a=[];break;case"textarea":i=oe(e,i),o=oe(e,o),a=[];break;default:"function"!=typeof i.onClick&&"function"==typeof o.onClick&&(e.onclick=ei)}for(d in _e(n,o),n=null,i)if(!o.hasOwnProperty(d)&&i.hasOwnProperty(d)&&null!=i[d])if("style"===d){var p=i[d];for(s in p)p.hasOwnProperty(s)&&(n||(n={}),n[s]="")}else"dangerouslySetInnerHTML"!==d&&"children"!==d&&"suppressContentEditableWarning"!==d&&"suppressHydrationWarning"!==d&&"autoFocus"!==d&&(r.hasOwnProperty(d)?a||(a=[]):(a=a||[]).push(d,null));for(d in o){var c=o[d];if(p=null!=i?i[d]:void 0,o.hasOwnProperty(d)&&c!==p&&(null!=c||null!=p))if("style"===d)if(p){for(s in p)!p.hasOwnProperty(s)||c&&c.hasOwnProperty(s)||(n||(n={}),n[s]="");for(s in c)c.hasOwnProperty(s)&&p[s]!==c[s]&&(n||(n={}),n[s]=c[s])}else n||(a||(a=[]),a.push(d,n)),n=c;else"dangerouslySetInnerHTML"===d?(c=c?c.__html:void 0,p=p?p.__html:void 0,null!=c&&p!==c&&(a=a||[]).push(d,c)):"children"===d?"string"!=typeof c&&"number"!=typeof c||(a=a||[]).push(d,""+c):"suppressContentEditableWarning"!==d&&"suppressHydrationWarning"!==d&&(r.hasOwnProperty(d)?(null!=c&&"onScroll"===d&&jo("scroll",e),a||p===c||(a=[])):(a=a||[]).push(d,c))}n&&(a=a||[]).push("style",n);var d=a;(t.updateQueue=d)&&(t.flags|=4)}},Cr=function(e,t,n,o){n!==o&&(t.flags|=4)};var Kr=!1,$r=!1,Zr="function"==typeof WeakSet?WeakSet:Set,Xr=null;function ep(e,t){var n=e.ref;if(null!==n)if("function"==typeof n)try{n(null)}catch(o){Ac(e,t,o)}else n.current=null}function tp(e,t,n){try{n()}catch(o){Ac(e,t,o)}}var np=!1;function op(e,t,n){var o=t.updateQueue;if(null!==(o=null!==o?o.lastEffect:null)){var i=o=o.next;do{if((i.tag&e)===e){var s=i.destroy;i.destroy=void 0,void 0!==s&&tp(t,n,s)}i=i.next}while(i!==o)}}function ip(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var o=n.create;n.destroy=o()}n=n.next}while(n!==t)}}function sp(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"==typeof t?t(e):t.current=e}}function ap(e){var t=e.alternate;null!==t&&(e.alternate=null,ap(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[hi],delete t[fi],delete t[mi],delete t[gi],delete t[_i])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function rp(e){return 5===e.tag||3===e.tag||4===e.tag}function pp(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||rp(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function cp(e,t,n){var o=e.tag;if(5===o||6===o)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!=(n=n._reactRootContainer)||null!==t.onclick||(t.onclick=ei));else if(4!==o&&null!==(e=e.child))for(cp(e,t,n),e=e.sibling;null!==e;)cp(e,t,n),e=e.sibling}function dp(e,t,n){var o=e.tag;if(5===o||6===o)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==o&&null!==(e=e.child))for(dp(e,t,n),e=e.sibling;null!==e;)dp(e,t,n),e=e.sibling}var lp=null,up=!1;function hp(e,t,n){for(n=n.child;null!==n;)fp(e,t,n),n=n.sibling}function fp(e,t,n){if(st&&"function"==typeof st.onCommitFiberUnmount)try{st.onCommitFiberUnmount(it,n)}catch(r){}switch(n.tag){case 5:$r||ep(n,t);case 6:var o=lp,i=up;lp=null,hp(e,t,n),up=i,null!==(lp=o)&&(up?(e=lp,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):lp.removeChild(n.stateNode));break;case 18:null!==lp&&(up?(e=lp,n=n.stateNode,8===e.nodeType?ci(e.parentNode,n):1===e.nodeType&&ci(e,n),zt(e)):ci(lp,n.stateNode));break;case 4:o=lp,i=up,lp=n.stateNode.containerInfo,up=!0,hp(e,t,n),lp=o,up=i;break;case 0:case 11:case 14:case 15:if(!$r&&(null!==(o=n.updateQueue)&&null!==(o=o.lastEffect))){i=o=o.next;do{var s=i,a=s.destroy;s=s.tag,void 0!==a&&(0!=(2&s)||0!=(4&s))&&tp(n,t,a),i=i.next}while(i!==o)}hp(e,t,n);break;case 1:if(!$r&&(ep(n,t),"function"==typeof(o=n.stateNode).componentWillUnmount))try{o.props=n.memoizedProps,o.state=n.memoizedState,o.componentWillUnmount()}catch(r){Ac(n,t,r)}hp(e,t,n);break;case 21:hp(e,t,n);break;case 22:1&n.mode?($r=(o=$r)||null!==n.memoizedState,hp(e,t,n),$r=o):hp(e,t,n);break;default:hp(e,t,n)}}function yp(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Zr),t.forEach((function(t){var o=Ic.bind(null,e,t);n.has(t)||(n.add(t),t.then(o,o))}))}}function mp(e,t){var n=t.deletions;if(null!==n)for(var o=0;o<n.length;o++){var i=n[o];try{var a=e,r=t,p=r;e:for(;null!==p;){switch(p.tag){case 5:lp=p.stateNode,up=!1;break e;case 3:case 4:lp=p.stateNode.containerInfo,up=!0;break e}p=p.return}if(null===lp)throw Error(s(160));fp(a,r,i),lp=null,up=!1;var c=i.alternate;null!==c&&(c.return=null),i.return=null}catch(d){Ac(i,t,d)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)gp(t,e),t=t.sibling}function gp(e,t){var n=e.alternate,o=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(mp(t,e),_p(e),4&o){try{op(3,e,e.return),ip(3,e)}catch(m){Ac(e,e.return,m)}try{op(5,e,e.return)}catch(m){Ac(e,e.return,m)}}break;case 1:mp(t,e),_p(e),512&o&&null!==n&&ep(n,n.return);break;case 5:if(mp(t,e),_p(e),512&o&&null!==n&&ep(n,n.return),32&e.flags){var i=e.stateNode;try{ue(i,"")}catch(m){Ac(e,e.return,m)}}if(4&o&&null!=(i=e.stateNode)){var a=e.memoizedProps,r=null!==n?n.memoizedProps:a,p=e.type,c=e.updateQueue;if(e.updateQueue=null,null!==c)try{"input"===p&&"radio"===a.type&&null!=a.name&&$(i,a),be(p,r);var d=be(p,a);for(r=0;r<c.length;r+=2){var l=c[r],u=c[r+1];"style"===l?me(i,u):"dangerouslySetInnerHTML"===l?le(i,u):"children"===l?ue(i,u):b(i,l,u,d)}switch(p){case"input":Z(i,a);break;case"textarea":se(i,a);break;case"select":var h=i._wrapperState.wasMultiple;i._wrapperState.wasMultiple=!!a.multiple;var f=a.value;null!=f?ne(i,!!a.multiple,f,!1):h!==!!a.multiple&&(null!=a.defaultValue?ne(i,!!a.multiple,a.defaultValue,!0):ne(i,!!a.multiple,a.multiple?[]:"",!1))}i[fi]=a}catch(m){Ac(e,e.return,m)}}break;case 6:if(mp(t,e),_p(e),4&o){if(null===e.stateNode)throw Error(s(162));i=e.stateNode,a=e.memoizedProps;try{i.nodeValue=a}catch(m){Ac(e,e.return,m)}}break;case 3:if(mp(t,e),_p(e),4&o&&null!==n&&n.memoizedState.isDehydrated)try{zt(t.containerInfo)}catch(m){Ac(e,e.return,m)}break;case 4:default:mp(t,e),_p(e);break;case 13:mp(t,e),_p(e),8192&(i=e.child).flags&&(a=null!==i.memoizedState,i.stateNode.isHidden=a,!a||null!==i.alternate&&null!==i.alternate.memoizedState||(zp=$e())),4&o&&yp(e);break;case 22:if(l=null!==n&&null!==n.memoizedState,1&e.mode?($r=(d=$r)||l,mp(t,e),$r=d):mp(t,e),_p(e),8192&o){if(d=null!==e.memoizedState,(e.stateNode.isHidden=d)&&!l&&0!=(1&e.mode))for(Xr=e,l=e.child;null!==l;){for(u=Xr=l;null!==Xr;){switch(f=(h=Xr).child,h.tag){case 0:case 11:case 14:case 15:op(4,h,h.return);break;case 1:ep(h,h.return);var y=h.stateNode;if("function"==typeof y.componentWillUnmount){o=h,n=h.return;try{t=o,y.props=t.memoizedProps,y.state=t.memoizedState,y.componentWillUnmount()}catch(m){Ac(o,n,m)}}break;case 5:ep(h,h.return);break;case 22:if(null!==h.memoizedState){Pp(u);continue}}null!==f?(f.return=h,Xr=f):Pp(u)}l=l.sibling}e:for(l=null,u=e;;){if(5===u.tag){if(null===l){l=u;try{i=u.stateNode,d?"function"==typeof(a=i.style).setProperty?a.setProperty("display","none","important"):a.display="none":(p=u.stateNode,r=null!=(c=u.memoizedProps.style)&&c.hasOwnProperty("display")?c.display:null,p.style.display=ye("display",r))}catch(m){Ac(e,e.return,m)}}}else if(6===u.tag){if(null===l)try{u.stateNode.nodeValue=d?"":u.memoizedProps}catch(m){Ac(e,e.return,m)}}else if((22!==u.tag&&23!==u.tag||null===u.memoizedState||u===e)&&null!==u.child){u.child.return=u,u=u.child;continue}if(u===e)break e;for(;null===u.sibling;){if(null===u.return||u.return===e)break e;l===u&&(l=null),u=u.return}l===u&&(l=null),u.sibling.return=u.return,u=u.sibling}}break;case 19:mp(t,e),_p(e),4&o&&yp(e);case 21:}}function _p(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(rp(n)){var o=n;break e}n=n.return}throw Error(s(160))}switch(o.tag){case 5:var i=o.stateNode;32&o.flags&&(ue(i,""),o.flags&=-33),dp(e,pp(e),i);break;case 3:case 4:var a=o.stateNode.containerInfo;cp(e,pp(e),a);break;default:throw Error(s(161))}}catch(r){Ac(e,e.return,r)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function bp(e,t,n){Xr=e,Tp(e,t,n)}function Tp(e,t,n){for(var o=0!=(1&e.mode);null!==Xr;){var i=Xr,s=i.child;if(22===i.tag&&o){var a=null!==i.memoizedState||Kr;if(!a){var r=i.alternate,p=null!==r&&null!==r.memoizedState||$r;r=Kr;var c=$r;if(Kr=a,($r=p)&&!c)for(Xr=i;null!==Xr;)p=(a=Xr).child,22===a.tag&&null!==a.memoizedState?Ep(i):null!==p?(p.return=a,Xr=p):Ep(i);for(;null!==s;)Xr=s,Tp(s,t,n),s=s.sibling;Xr=i,Kr=r,$r=c}vp(e)}else 0!=(8772&i.subtreeFlags)&&null!==s?(s.return=i,Xr=s):vp(e)}}function vp(e){for(;null!==Xr;){var t=Xr;if(0!=(8772&t.flags)){var n=t.alternate;try{if(0!=(8772&t.flags))switch(t.tag){case 0:case 11:case 15:$r||ip(5,t);break;case 1:var o=t.stateNode;if(4&t.flags&&!$r)if(null===n)o.componentDidMount();else{var i=t.elementType===t.type?n.memoizedProps:gs(t.type,n.memoizedProps);o.componentDidUpdate(i,n.memoizedState,o.__reactInternalSnapshotBeforeUpdate)}var a=t.updateQueue;null!==a&&Fs(t,a,o);break;case 3:var r=t.updateQueue;if(null!==r){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Fs(t,r,n)}break;case 5:var p=t.stateNode;if(null===n&&4&t.flags){n=p;var c=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":c.autoFocus&&n.focus();break;case"img":c.src&&(n.src=c.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var d=t.alternate;if(null!==d){var l=d.memoizedState;if(null!==l){var u=l.dehydrated;null!==u&&zt(u)}}}break;default:throw Error(s(163))}$r||512&t.flags&&sp(t)}catch(h){Ac(t,t.return,h)}}if(t===e){Xr=null;break}if(null!==(n=t.sibling)){n.return=t.return,Xr=n;break}Xr=t.return}}function Pp(e){for(;null!==Xr;){var t=Xr;if(t===e){Xr=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Xr=n;break}Xr=t.return}}function Ep(e){for(;null!==Xr;){var t=Xr;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{ip(4,t)}catch(p){Ac(t,n,p)}break;case 1:var o=t.stateNode;if("function"==typeof o.componentDidMount){var i=t.return;try{o.componentDidMount()}catch(p){Ac(t,i,p)}}var s=t.return;try{sp(t)}catch(p){Ac(t,s,p)}break;case 5:var a=t.return;try{sp(t)}catch(p){Ac(t,a,p)}}}catch(p){Ac(t,t.return,p)}if(t===e){Xr=null;break}var r=t.sibling;if(null!==r){r.return=t.return,Xr=r;break}Xr=t.return}}var Rp,Ap=Math.ceil,kp=T.ReactCurrentDispatcher,wp=T.ReactCurrentOwner,Sp=T.ReactCurrentBatchConfig,Ip=0,Op=null,xp=null,Np=0,Up=0,Yp=Ai(0),Cp=0,Lp=null,Dp=0,qp=0,Fp=0,jp=null,Mp=null,zp=0,Vp=1/0,Gp=null,Bp=!1,Jp=null,Qp=null,Hp=!1,Wp=null,Kp=0,$p=0,Zp=null,Xp=-1,ec=0;function tc(){return 0!=(6&Ip)?$e():-1!==Xp?Xp:Xp=$e()}function nc(e){return 0==(1&e.mode)?1:0!=(2&Ip)&&0!==Np?Np&-Np:null!==ms.transition?(0===ec&&(ec=yt()),ec):0!==(e=bt)?e:e=void 0===(e=window.event)?16:Kt(e.type)}function oc(e,t,n,o){if(50<$p)throw $p=0,Zp=null,Error(s(185));gt(e,n,o),0!=(2&Ip)&&e===Op||(e===Op&&(0==(2&Ip)&&(qp|=n),4===Cp&&pc(e,Np)),ic(e,o),1===n&&0===Ip&&0==(1&t.mode)&&(Vp=$e()+500,ji&&Vi()))}function ic(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,o=e.pingedLanes,i=e.expirationTimes,s=e.pendingLanes;0<s;){var a=31-at(s),r=1<<a,p=i[a];-1===p?0!=(r&n)&&0==(r&o)||(i[a]=ht(r,t)):p<=t&&(e.expiredLanes|=r),s&=~r}}(e,t);var o=ut(e,e===Op?Np:0);if(0===o)null!==n&&He(n),e.callbackNode=null,e.callbackPriority=0;else if(t=o&-o,e.callbackPriority!==t){if(null!=n&&He(n),1===t)0===e.tag?function(e){ji=!0,zi(e)}(cc.bind(null,e)):zi(cc.bind(null,e)),ri((function(){0==(6&Ip)&&Vi()})),n=null;else{switch(Tt(o)){case 1:n=Xe;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=ot}n=Oc(n,sc.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function sc(e,t){if(Xp=-1,ec=0,0!=(6&Ip))throw Error(s(327));var n=e.callbackNode;if(Ec()&&e.callbackNode!==n)return null;var o=ut(e,e===Op?Np:0);if(0===o)return null;if(0!=(30&o)||0!=(o&e.expiredLanes)||t)t=gc(e,o);else{t=o;var i=Ip;Ip|=2;var a=yc();for(Op===e&&Np===t||(Gp=null,Vp=$e()+500,hc(e,t));;)try{bc();break}catch(p){fc(e,p)}Ps(),kp.current=a,Ip=i,null!==xp?t=0:(Op=null,Np=0,t=Cp)}if(0!==t){if(2===t&&(0!==(i=ft(e))&&(o=i,t=ac(e,i))),1===t)throw n=Lp,hc(e,0),pc(e,o),ic(e,$e()),n;if(6===t)pc(e,o);else{if(i=e.current.alternate,0==(30&o)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var o=0;o<n.length;o++){var i=n[o],s=i.getSnapshot;i=i.value;try{if(!ro(s(),i))return!1}catch(r){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(i)&&(2===(t=gc(e,o))&&(0!==(a=ft(e))&&(o=a,t=ac(e,a))),1===t))throw n=Lp,hc(e,0),pc(e,o),ic(e,$e()),n;switch(e.finishedWork=i,e.finishedLanes=o,t){case 0:case 1:throw Error(s(345));case 2:case 5:Pc(e,Mp,Gp);break;case 3:if(pc(e,o),(130023424&o)===o&&10<(t=zp+500-$e())){if(0!==ut(e,0))break;if(((i=e.suspendedLanes)&o)!==o){tc(),e.pingedLanes|=e.suspendedLanes&i;break}e.timeoutHandle=ii(Pc.bind(null,e,Mp,Gp),t);break}Pc(e,Mp,Gp);break;case 4:if(pc(e,o),(4194240&o)===o)break;for(t=e.eventTimes,i=-1;0<o;){var r=31-at(o);a=1<<r,(r=t[r])>i&&(i=r),o&=~a}if(o=i,10<(o=(120>(o=$e()-o)?120:480>o?480:1080>o?1080:1920>o?1920:3e3>o?3e3:4320>o?4320:1960*Ap(o/1960))-o)){e.timeoutHandle=ii(Pc.bind(null,e,Mp,Gp),o);break}Pc(e,Mp,Gp);break;default:throw Error(s(329))}}}return ic(e,$e()),e.callbackNode===n?sc.bind(null,e):null}function ac(e,t){var n=jp;return e.current.memoizedState.isDehydrated&&(hc(e,t).flags|=256),2!==(e=gc(e,t))&&(t=Mp,Mp=n,null!==t&&rc(t)),e}function rc(e){null===Mp?Mp=e:Mp.push.apply(Mp,e)}function pc(e,t){for(t&=~Fp,t&=~qp,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-at(t),o=1<<n;e[n]=-1,t&=~o}}function cc(e){if(0!=(6&Ip))throw Error(s(327));Ec();var t=ut(e,0);if(0==(1&t))return ic(e,$e()),null;var n=gc(e,t);if(0!==e.tag&&2===n){var o=ft(e);0!==o&&(t=o,n=ac(e,o))}if(1===n)throw n=Lp,hc(e,0),pc(e,t),ic(e,$e()),n;if(6===n)throw Error(s(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,Pc(e,Mp,Gp),ic(e,$e()),null}function dc(e,t){var n=Ip;Ip|=1;try{return e(t)}finally{0===(Ip=n)&&(Vp=$e()+500,ji&&Vi())}}function lc(e){null!==Wp&&0===Wp.tag&&0==(6&Ip)&&Ec();var t=Ip;Ip|=1;var n=Sp.transition,o=bt;try{if(Sp.transition=null,bt=1,e)return e()}finally{bt=o,Sp.transition=n,0==(6&(Ip=t))&&Vi()}}function uc(){Up=Yp.current,ki(Yp)}function hc(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,si(n)),null!==xp)for(n=xp.return;null!==n;){var o=n;switch(ns(o),o.tag){case 1:null!=(o=o.type.childContextTypes)&&Yi();break;case 3:sa(),ki(Oi),ki(Ii),la();break;case 5:ra(o);break;case 4:sa();break;case 13:case 19:ki(pa);break;case 10:Es(o.type._context);break;case 22:case 23:uc()}n=n.return}if(Op=e,xp=e=Yc(e.current,null),Np=Up=t,Cp=0,Lp=null,Fp=qp=Dp=0,Mp=jp=null,null!==ws){for(t=0;t<ws.length;t++)if(null!==(o=(n=ws[t]).interleaved)){n.interleaved=null;var i=o.next,s=n.pending;if(null!==s){var a=s.next;s.next=i,o.next=a}n.pending=o}ws=null}return e}function fc(e,t){for(;;){var n=xp;try{if(Ps(),ua.current=ar,_a){for(var o=ya.memoizedState;null!==o;){var i=o.queue;null!==i&&(i.pending=null),o=o.next}_a=!1}if(fa=0,ga=ma=ya=null,ba=!1,Ta=0,wp.current=null,null===n||null===n.return){Cp=1,Lp=t,xp=null;break}e:{var a=e,r=n.return,p=n,c=t;if(t=Np,p.flags|=32768,null!==c&&"object"==typeof c&&"function"==typeof c.then){var d=c,l=p,u=l.tag;if(0==(1&l.mode)&&(0===u||11===u||15===u)){var h=l.alternate;h?(l.updateQueue=h.updateQueue,l.memoizedState=h.memoizedState,l.lanes=h.lanes):(l.updateQueue=null,l.memoizedState=null)}var f=gr(r);if(null!==f){f.flags&=-257,_r(f,r,p,0,t),1&f.mode&&mr(a,d,t),c=d;var y=(t=f).updateQueue;if(null===y){var m=new Set;m.add(c),t.updateQueue=m}else y.add(c);break e}if(0==(1&t)){mr(a,d,t),mc();break e}c=Error(s(426))}else if(ss&&1&p.mode){var g=gr(r);if(null!==g){0==(65536&g.flags)&&(g.flags|=256),_r(g,r,p,0,t),ys(dr(c,p));break e}}a=c=dr(c,p),4!==Cp&&(Cp=2),null===jp?jp=[a]:jp.push(a),a=r;do{switch(a.tag){case 3:a.flags|=65536,t&=-t,a.lanes|=t,Ds(a,fr(0,c,t));break e;case 1:p=c;var _=a.type,b=a.stateNode;if(0==(128&a.flags)&&("function"==typeof _.getDerivedStateFromError||null!==b&&"function"==typeof b.componentDidCatch&&(null===Qp||!Qp.has(b)))){a.flags|=65536,t&=-t,a.lanes|=t,Ds(a,yr(a,p,t));break e}}a=a.return}while(null!==a)}vc(n)}catch(T){t=T,xp===n&&null!==n&&(xp=n=n.return);continue}break}}function yc(){var e=kp.current;return kp.current=ar,null===e?ar:e}function mc(){0!==Cp&&3!==Cp&&2!==Cp||(Cp=4),null===Op||0==(268435455&Dp)&&0==(268435455&qp)||pc(Op,Np)}function gc(e,t){var n=Ip;Ip|=2;var o=yc();for(Op===e&&Np===t||(Gp=null,hc(e,t));;)try{_c();break}catch(i){fc(e,i)}if(Ps(),Ip=n,kp.current=o,null!==xp)throw Error(s(261));return Op=null,Np=0,Cp}function _c(){for(;null!==xp;)Tc(xp)}function bc(){for(;null!==xp&&!We();)Tc(xp)}function Tc(e){var t=Rp(e.alternate,e,Up);e.memoizedProps=e.pendingProps,null===t?vc(e):xp=t,wp.current=null}function vc(e){var t=e;do{var n=t.alternate;if(e=t.return,0==(32768&t.flags)){if(null!==(n=Hr(n,t,Up)))return void(xp=n)}else{if(null!==(n=Wr(n,t)))return n.flags&=32767,void(xp=n);if(null===e)return Cp=6,void(xp=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(xp=t);xp=t=e}while(null!==t);0===Cp&&(Cp=5)}function Pc(e,t,n){var o=bt,i=Sp.transition;try{Sp.transition=null,bt=1,function(e,t,n,o){do{Ec()}while(null!==Wp);if(0!=(6&Ip))throw Error(s(327));n=e.finishedWork;var i=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(s(177));e.callbackNode=null,e.callbackPriority=0;var a=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var o=e.eventTimes;for(e=e.expirationTimes;0<n;){var i=31-at(n),s=1<<i;t[i]=0,o[i]=-1,e[i]=-1,n&=~s}}(e,a),e===Op&&(xp=Op=null,Np=0),0==(2064&n.subtreeFlags)&&0==(2064&n.flags)||Hp||(Hp=!0,Oc(tt,(function(){return Ec(),null}))),a=0!=(15990&n.flags),0!=(15990&n.subtreeFlags)||a){a=Sp.transition,Sp.transition=null;var r=bt;bt=1;var p=Ip;Ip|=4,wp.current=null,function(e,t){if(ti=Gt,fo(e=ho())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var o=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(o&&0!==o.rangeCount){n=o.anchorNode;var i=o.anchorOffset,a=o.focusNode;o=o.focusOffset;try{n.nodeType,a.nodeType}catch(v){n=null;break e}var r=0,p=-1,c=-1,d=0,l=0,u=e,h=null;t:for(;;){for(var f;u!==n||0!==i&&3!==u.nodeType||(p=r+i),u!==a||0!==o&&3!==u.nodeType||(c=r+o),3===u.nodeType&&(r+=u.nodeValue.length),null!==(f=u.firstChild);)h=u,u=f;for(;;){if(u===e)break t;if(h===n&&++d===i&&(p=r),h===a&&++l===o&&(c=r),null!==(f=u.nextSibling))break;h=(u=h).parentNode}u=f}n=-1===p||-1===c?null:{start:p,end:c}}else n=null}n=n||{start:0,end:0}}else n=null;for(ni={focusedElem:e,selectionRange:n},Gt=!1,Xr=t;null!==Xr;)if(e=(t=Xr).child,0!=(1028&t.subtreeFlags)&&null!==e)e.return=t,Xr=e;else for(;null!==Xr;){t=Xr;try{var y=t.alternate;if(0!=(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==y){var m=y.memoizedProps,g=y.memoizedState,_=t.stateNode,b=_.getSnapshotBeforeUpdate(t.elementType===t.type?m:gs(t.type,m),g);_.__reactInternalSnapshotBeforeUpdate=b}break;case 3:var T=t.stateNode.containerInfo;1===T.nodeType?T.textContent="":9===T.nodeType&&T.documentElement&&T.removeChild(T.documentElement);break;default:throw Error(s(163))}}catch(v){Ac(t,t.return,v)}if(null!==(e=t.sibling)){e.return=t.return,Xr=e;break}Xr=t.return}y=np,np=!1}(e,n),gp(n,e),yo(ni),Gt=!!ti,ni=ti=null,e.current=n,bp(n,e,i),Ke(),Ip=p,bt=r,Sp.transition=a}else e.current=n;if(Hp&&(Hp=!1,Wp=e,Kp=i),a=e.pendingLanes,0===a&&(Qp=null),function(e){if(st&&"function"==typeof st.onCommitFiberRoot)try{st.onCommitFiberRoot(it,e,void 0,128==(128&e.current.flags))}catch(t){}}(n.stateNode),ic(e,$e()),null!==t)for(o=e.onRecoverableError,n=0;n<t.length;n++)i=t[n],o(i.value,{componentStack:i.stack,digest:i.digest});if(Bp)throw Bp=!1,e=Jp,Jp=null,e;0!=(1&Kp)&&0!==e.tag&&Ec(),a=e.pendingLanes,0!=(1&a)?e===Zp?$p++:($p=0,Zp=e):$p=0,Vi()}(e,t,n,o)}finally{Sp.transition=i,bt=o}return null}function Ec(){if(null!==Wp){var e=Tt(Kp),t=Sp.transition,n=bt;try{if(Sp.transition=null,bt=16>e?16:e,null===Wp)var o=!1;else{if(e=Wp,Wp=null,Kp=0,0!=(6&Ip))throw Error(s(331));var i=Ip;for(Ip|=4,Xr=e.current;null!==Xr;){var a=Xr,r=a.child;if(0!=(16&Xr.flags)){var p=a.deletions;if(null!==p){for(var c=0;c<p.length;c++){var d=p[c];for(Xr=d;null!==Xr;){var l=Xr;switch(l.tag){case 0:case 11:case 15:op(8,l,a)}var u=l.child;if(null!==u)u.return=l,Xr=u;else for(;null!==Xr;){var h=(l=Xr).sibling,f=l.return;if(ap(l),l===d){Xr=null;break}if(null!==h){h.return=f,Xr=h;break}Xr=f}}}var y=a.alternate;if(null!==y){var m=y.child;if(null!==m){y.child=null;do{var g=m.sibling;m.sibling=null,m=g}while(null!==m)}}Xr=a}}if(0!=(2064&a.subtreeFlags)&&null!==r)r.return=a,Xr=r;else e:for(;null!==Xr;){if(0!=(2048&(a=Xr).flags))switch(a.tag){case 0:case 11:case 15:op(9,a,a.return)}var _=a.sibling;if(null!==_){_.return=a.return,Xr=_;break e}Xr=a.return}}var b=e.current;for(Xr=b;null!==Xr;){var T=(r=Xr).child;if(0!=(2064&r.subtreeFlags)&&null!==T)T.return=r,Xr=T;else e:for(r=b;null!==Xr;){if(0!=(2048&(p=Xr).flags))try{switch(p.tag){case 0:case 11:case 15:ip(9,p)}}catch(P){Ac(p,p.return,P)}if(p===r){Xr=null;break e}var v=p.sibling;if(null!==v){v.return=p.return,Xr=v;break e}Xr=p.return}}if(Ip=i,Vi(),st&&"function"==typeof st.onPostCommitFiberRoot)try{st.onPostCommitFiberRoot(it,e)}catch(P){}o=!0}return o}finally{bt=n,Sp.transition=t}}return!1}function Rc(e,t,n){e=Cs(e,t=fr(0,t=dr(n,t),1),1),t=tc(),null!==e&&(gt(e,1,t),ic(e,t))}function Ac(e,t,n){if(3===e.tag)Rc(e,e,n);else for(;null!==t;){if(3===t.tag){Rc(t,e,n);break}if(1===t.tag){var o=t.stateNode;if("function"==typeof t.type.getDerivedStateFromError||"function"==typeof o.componentDidCatch&&(null===Qp||!Qp.has(o))){t=Cs(t,e=yr(t,e=dr(n,e),1),1),e=tc(),null!==t&&(gt(t,1,e),ic(t,e));break}}t=t.return}}function kc(e,t,n){var o=e.pingCache;null!==o&&o.delete(t),t=tc(),e.pingedLanes|=e.suspendedLanes&n,Op===e&&(Np&n)===n&&(4===Cp||3===Cp&&(130023424&Np)===Np&&500>$e()-zp?hc(e,0):Fp|=n),ic(e,t)}function wc(e,t){0===t&&(0==(1&e.mode)?t=1:(t=dt,0==(130023424&(dt<<=1))&&(dt=4194304)));var n=tc();null!==(e=Os(e,t))&&(gt(e,t,n),ic(e,n))}function Sc(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),wc(e,n)}function Ic(e,t){var n=0;switch(e.tag){case 13:var o=e.stateNode,i=e.memoizedState;null!==i&&(n=i.retryLane);break;case 19:o=e.stateNode;break;default:throw Error(s(314))}null!==o&&o.delete(t),wc(e,n)}function Oc(e,t){return Qe(e,t)}function xc(e,t,n,o){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=o,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Nc(e,t,n,o){return new xc(e,t,n,o)}function Uc(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Yc(e,t){var n=e.alternate;return null===n?((n=Nc(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Cc(e,t,n,o,i,a){var r=2;if(o=e,"function"==typeof e)Uc(e)&&(r=1);else if("string"==typeof e)r=5;else e:switch(e){case E:return Lc(n.children,i,a,t);case R:r=8,i|=8;break;case A:return(e=Nc(12,n,t,2|i)).elementType=A,e.lanes=a,e;case I:return(e=Nc(13,n,t,i)).elementType=I,e.lanes=a,e;case O:return(e=Nc(19,n,t,i)).elementType=O,e.lanes=a,e;case U:return Dc(n,i,a,t);default:if("object"==typeof e&&null!==e)switch(e.$$typeof){case k:r=10;break e;case w:r=9;break e;case S:r=11;break e;case x:r=14;break e;case N:r=16,o=null;break e}throw Error(s(130,null==e?e:typeof e,""))}return(t=Nc(r,n,t,i)).elementType=e,t.type=o,t.lanes=a,t}function Lc(e,t,n,o){return(e=Nc(7,e,o,t)).lanes=n,e}function Dc(e,t,n,o){return(e=Nc(22,e,o,t)).elementType=U,e.lanes=n,e.stateNode={isHidden:!1},e}function qc(e,t,n){return(e=Nc(6,e,null,t)).lanes=n,e}function Fc(e,t,n){return(t=Nc(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function jc(e,t,n,o,i){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=mt(0),this.expirationTimes=mt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=mt(0),this.identifierPrefix=o,this.onRecoverableError=i,this.mutableSourceEagerHydrationData=null}function Mc(e,t,n,o,i,s,a,r,p){return e=new jc(e,t,n,r,p),1===t?(t=1,!0===s&&(t|=8)):t=0,s=Nc(3,null,null,t),e.current=s,s.stateNode=e,s.memoizedState={element:o,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Ns(s),e}function zc(e){if(!e)return Si;e:{if(ze(e=e._reactInternals)!==e||1!==e.tag)throw Error(s(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Ui(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(s(171))}if(1===e.tag){var n=e.type;if(Ui(n))return Li(e,n,t)}return t}function Vc(e,t,n,o,i,s,a,r,p){return(e=Mc(n,o,!0,e,0,s,0,r,p)).context=zc(null),n=e.current,(s=Ys(o=tc(),i=nc(n))).callback=null!=t?t:null,Cs(n,s,i),e.current.lanes=i,gt(e,i,o),ic(e,o),e}function Gc(e,t,n,o){var i=t.current,s=tc(),a=nc(i);return n=zc(n),null===t.context?t.context=n:t.pendingContext=n,(t=Ys(s,a)).payload={element:e},null!==(o=void 0===o?null:o)&&(t.callback=o),null!==(e=Cs(i,t,a))&&(oc(e,i,a,s),Ls(e,i,a)),a}function Bc(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Jc(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Qc(e,t){Jc(e,t),(e=e.alternate)&&Jc(e,t)}Rp=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Oi.current)Tr=!0;else{if(0==(e.lanes&n)&&0==(128&t.flags))return Tr=!1,function(e,t,n){switch(t.tag){case 3:Or(t),fs();break;case 5:aa(t);break;case 1:Ui(t.type)&&Di(t);break;case 4:ia(t,t.stateNode.containerInfo);break;case 10:var o=t.type._context,i=t.memoizedProps.value;wi(_s,o._currentValue),o._currentValue=i;break;case 13:if(null!==(o=t.memoizedState))return null!==o.dehydrated?(wi(pa,1&pa.current),t.flags|=128,null):0!=(n&t.child.childLanes)?qr(e,t,n):(wi(pa,1&pa.current),null!==(e=Br(e,t,n))?e.sibling:null);wi(pa,1&pa.current);break;case 19:if(o=0!=(n&t.childLanes),0!=(128&e.flags)){if(o)return Vr(e,t,n);t.flags|=128}if(null!==(i=t.memoizedState)&&(i.rendering=null,i.tail=null,i.lastEffect=null),wi(pa,pa.current),o)break;return null;case 22:case 23:return t.lanes=0,Ar(e,t,n)}return Br(e,t,n)}(e,t,n);Tr=0!=(131072&e.flags)}else Tr=!1,ss&&0!=(1048576&t.flags)&&es(t,Qi,t.index);switch(t.lanes=0,t.tag){case 2:var o=t.type;Gr(e,t),e=t.pendingProps;var i=Ni(t,Ii.current);As(t,n),i=Ra(null,t,o,e,i,n);var a=Aa();return t.flags|=1,"object"==typeof i&&null!==i&&"function"==typeof i.render&&void 0===i.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Ui(o)?(a=!0,Di(t)):a=!1,t.memoizedState=null!==i.state&&void 0!==i.state?i.state:null,Ns(t),i.updater=zs,t.stateNode=i,i._reactInternals=t,Js(t,o,e,n),t=Ir(null,t,o,!0,a,n)):(t.tag=0,ss&&a&&ts(t),vr(null,t,i,n),t=t.child),t;case 16:o=t.elementType;e:{switch(Gr(e,t),e=t.pendingProps,o=(i=o._init)(o._payload),t.type=o,i=t.tag=function(e){if("function"==typeof e)return Uc(e)?1:0;if(null!=e){if((e=e.$$typeof)===S)return 11;if(e===x)return 14}return 2}(o),e=gs(o,e),i){case 0:t=wr(null,t,o,e,n);break e;case 1:t=Sr(null,t,o,e,n);break e;case 11:t=Pr(null,t,o,e,n);break e;case 14:t=Er(null,t,o,gs(o.type,e),n);break e}throw Error(s(306,o,""))}return t;case 0:return o=t.type,i=t.pendingProps,wr(e,t,o,i=t.elementType===o?i:gs(o,i),n);case 1:return o=t.type,i=t.pendingProps,Sr(e,t,o,i=t.elementType===o?i:gs(o,i),n);case 3:e:{if(Or(t),null===e)throw Error(s(387));o=t.pendingProps,i=(a=t.memoizedState).element,Us(e,t),qs(t,o,null,n);var r=t.memoizedState;if(o=r.element,a.isDehydrated){if(a={element:o,isDehydrated:!1,cache:r.cache,pendingSuspenseBoundaries:r.pendingSuspenseBoundaries,transitions:r.transitions},t.updateQueue.baseState=a,t.memoizedState=a,256&t.flags){t=xr(e,t,o,n,i=dr(Error(s(423)),t));break e}if(o!==i){t=xr(e,t,o,n,i=dr(Error(s(424)),t));break e}for(is=di(t.stateNode.containerInfo.firstChild),os=t,ss=!0,as=null,n=Zs(t,null,o,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(fs(),o===i){t=Br(e,t,n);break e}vr(e,t,o,n)}t=t.child}return t;case 5:return aa(t),null===e&&ds(t),o=t.type,i=t.pendingProps,a=null!==e?e.memoizedProps:null,r=i.children,oi(o,i)?r=null:null!==a&&oi(o,a)&&(t.flags|=32),kr(e,t),vr(e,t,r,n),t.child;case 6:return null===e&&ds(t),null;case 13:return qr(e,t,n);case 4:return ia(t,t.stateNode.containerInfo),o=t.pendingProps,null===e?t.child=$s(t,null,o,n):vr(e,t,o,n),t.child;case 11:return o=t.type,i=t.pendingProps,Pr(e,t,o,i=t.elementType===o?i:gs(o,i),n);case 7:return vr(e,t,t.pendingProps,n),t.child;case 8:case 12:return vr(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(o=t.type._context,i=t.pendingProps,a=t.memoizedProps,r=i.value,wi(_s,o._currentValue),o._currentValue=r,null!==a)if(ro(a.value,r)){if(a.children===i.children&&!Oi.current){t=Br(e,t,n);break e}}else for(null!==(a=t.child)&&(a.return=t);null!==a;){var p=a.dependencies;if(null!==p){r=a.child;for(var c=p.firstContext;null!==c;){if(c.context===o){if(1===a.tag){(c=Ys(-1,n&-n)).tag=2;var d=a.updateQueue;if(null!==d){var l=(d=d.shared).pending;null===l?c.next=c:(c.next=l.next,l.next=c),d.pending=c}}a.lanes|=n,null!==(c=a.alternate)&&(c.lanes|=n),Rs(a.return,n,t),p.lanes|=n;break}c=c.next}}else if(10===a.tag)r=a.type===t.type?null:a.child;else if(18===a.tag){if(null===(r=a.return))throw Error(s(341));r.lanes|=n,null!==(p=r.alternate)&&(p.lanes|=n),Rs(r,n,t),r=a.sibling}else r=a.child;if(null!==r)r.return=a;else for(r=a;null!==r;){if(r===t){r=null;break}if(null!==(a=r.sibling)){a.return=r.return,r=a;break}r=r.return}a=r}vr(e,t,i.children,n),t=t.child}return t;case 9:return i=t.type,o=t.pendingProps.children,As(t,n),o=o(i=ks(i)),t.flags|=1,vr(e,t,o,n),t.child;case 14:return i=gs(o=t.type,t.pendingProps),Er(e,t,o,i=gs(o.type,i),n);case 15:return Rr(e,t,t.type,t.pendingProps,n);case 17:return o=t.type,i=t.pendingProps,i=t.elementType===o?i:gs(o,i),Gr(e,t),t.tag=1,Ui(o)?(e=!0,Di(t)):e=!1,As(t,n),Gs(t,o,i),Js(t,o,i,n),Ir(null,t,o,!0,e,n);case 19:return Vr(e,t,n);case 22:return Ar(e,t,n)}throw Error(s(156,t.tag))};var Hc="function"==typeof reportError?reportError:function(e){console.error(e)};function Wc(e){this._internalRoot=e}function Kc(e){this._internalRoot=e}function $c(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Zc(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Xc(){}function ed(e,t,n,o,i){var s=n._reactRootContainer;if(s){var a=s;if("function"==typeof i){var r=i;i=function(){var e=Bc(a);r.call(e)}}Gc(t,a,e,i)}else a=function(e,t,n,o,i){if(i){if("function"==typeof o){var s=o;o=function(){var e=Bc(a);s.call(e)}}var a=Vc(t,o,e,0,null,!1,0,"",Xc);return e._reactRootContainer=a,e[yi]=a.current,Vo(8===e.nodeType?e.parentNode:e),lc(),a}for(;i=e.lastChild;)e.removeChild(i);if("function"==typeof o){var r=o;o=function(){var e=Bc(p);r.call(e)}}var p=Mc(e,0,!1,null,0,!1,0,"",Xc);return e._reactRootContainer=p,e[yi]=p.current,Vo(8===e.nodeType?e.parentNode:e),lc((function(){Gc(t,p,n,o)})),p}(n,t,e,i,o);return Bc(a)}Kc.prototype.render=Wc.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(s(409));Gc(e,t,null,null)},Kc.prototype.unmount=Wc.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;lc((function(){Gc(null,e,null,null)})),t[yi]=null}},Kc.prototype.unstable_scheduleHydration=function(e){if(e){var t=Rt();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Ut.length&&0!==t&&t<Ut[n].priority;n++);Ut.splice(n,0,e),0===n&&Dt(e)}},vt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=lt(t.pendingLanes);0!==n&&(_t(t,1|n),ic(t,$e()),0==(6&Ip)&&(Vp=$e()+500,Vi()))}break;case 13:lc((function(){var t=Os(e,1);if(null!==t){var n=tc();oc(t,e,1,n)}})),Qc(e,1)}},Pt=function(e){if(13===e.tag){var t=Os(e,134217728);if(null!==t)oc(t,e,134217728,tc());Qc(e,134217728)}},Et=function(e){if(13===e.tag){var t=nc(e),n=Os(e,t);if(null!==n)oc(n,e,t,tc());Qc(e,t)}},Rt=function(){return bt},At=function(e,t){var n=bt;try{return bt=e,t()}finally{bt=n}},Pe=function(e,t,n){switch(t){case"input":if(Z(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var o=n[t];if(o!==e&&o.form===e.form){var i=Pi(o);if(!i)throw Error(s(90));Q(o),Z(o,i)}}}break;case"textarea":se(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Se=dc,Ie=lc;var td={usingClientEntryPoint:!1,Events:[Ti,vi,Pi,ke,we,dc]},nd={findFiberByHostInstance:bi,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},od={bundleType:nd.bundleType,version:nd.version,rendererPackageName:nd.rendererPackageName,rendererConfig:nd.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:T.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Be(e))?null:e.stateNode},findFiberByHostInstance:nd.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var id=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!id.isDisabled&&id.supportsFiber)try{it=id.inject(od),st=id}catch(de){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=td,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!$c(t))throw Error(s(200));return function(e,t,n){var o=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:P,key:null==o?null:""+o,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!$c(e))throw Error(s(299));var n=!1,o="",i=Hc;return null!=t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(o=t.identifierPrefix),void 0!==t.onRecoverableError&&(i=t.onRecoverableError)),t=Mc(e,1,!1,null,0,n,0,o,i),e[yi]=t.current,Vo(8===e.nodeType?e.parentNode:e),new Wc(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"==typeof e.render)throw Error(s(188));throw e=Object.keys(e).join(","),Error(s(268,e))}return e=null===(e=Be(t))?null:e.stateNode},t.flushSync=function(e){return lc(e)},t.hydrate=function(e,t,n){if(!Zc(t))throw Error(s(200));return ed(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!$c(e))throw Error(s(405));var o=null!=n&&n.hydratedSources||null,i=!1,a="",r=Hc;if(null!=n&&(!0===n.unstable_strictMode&&(i=!0),void 0!==n.identifierPrefix&&(a=n.identifierPrefix),void 0!==n.onRecoverableError&&(r=n.onRecoverableError)),t=Vc(t,null,e,1,null!=n?n:null,i,0,a,r),e[yi]=t.current,Vo(e),o)for(e=0;e<o.length;e++)i=(i=(n=o[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,i]:t.mutableSourceEagerHydrationData.push(n,i);return new Kc(t)},t.render=function(e,t,n){if(!Zc(t))throw Error(s(200));return ed(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Zc(e))throw Error(s(40));return!!e._reactRootContainer&&(lc((function(){ed(null,null,e,!1,(function(){e._reactRootContainer=null,e[yi]=null}))})),!0)},t.unstable_batchedUpdates=dc,t.unstable_renderSubtreeIntoContainer=function(e,t,n,o){if(!Zc(n))throw Error(s(200));if(null==e||void 0===e._reactInternals)throw Error(s(38));return ed(e,t,n,!1,o)},t.version="18.2.0-next-9e3b772b8-20220608"},20745:(e,t,n)=>{"use strict";var o=n(73935);t.createRoot=o.createRoot,t.hydrateRoot=o.hydrateRoot},73935:(e,t,n)=>{"use strict";!function e(){if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(64448)},69590:e=>{var t="undefined"!=typeof Element,n="function"==typeof Map,o="function"==typeof Set,i="function"==typeof ArrayBuffer&&!!ArrayBuffer.isView;function s(e,a){if(e===a)return!0;if(e&&a&&"object"==typeof e&&"object"==typeof a){if(e.constructor!==a.constructor)return!1;var r,p,c,d;if(Array.isArray(e)){if((r=e.length)!=a.length)return!1;for(p=r;0!=p--;)if(!s(e[p],a[p]))return!1;return!0}if(n&&e instanceof Map&&a instanceof Map){if(e.size!==a.size)return!1;for(d=e.entries();!(p=d.next()).done;)if(!a.has(p.value[0]))return!1;for(d=e.entries();!(p=d.next()).done;)if(!s(p.value[1],a.get(p.value[0])))return!1;return!0}if(o&&e instanceof Set&&a instanceof Set){if(e.size!==a.size)return!1;for(d=e.entries();!(p=d.next()).done;)if(!a.has(p.value[0]))return!1;return!0}if(i&&ArrayBuffer.isView(e)&&ArrayBuffer.isView(a)){if((r=e.length)!=a.length)return!1;for(p=r;0!=p--;)if(e[p]!==a[p])return!1;return!0}if(e.constructor===RegExp)return e.source===a.source&&e.flags===a.flags;if(e.valueOf!==Object.prototype.valueOf&&"function"==typeof e.valueOf&&"function"==typeof a.valueOf)return e.valueOf()===a.valueOf();if(e.toString!==Object.prototype.toString&&"function"==typeof e.toString&&"function"==typeof a.toString)return e.toString()===a.toString();if((r=(c=Object.keys(e)).length)!==Object.keys(a).length)return!1;for(p=r;0!=p--;)if(!Object.prototype.hasOwnProperty.call(a,c[p]))return!1;if(t&&e instanceof Element)return!1;for(p=r;0!=p--;)if(("_owner"!==c[p]&&"__v"!==c[p]&&"__o"!==c[p]||!e.$$typeof)&&!s(e[c[p]],a[c[p]]))return!1;return!0}return e!=e&&a!=a}e.exports=function(e,t){try{return s(e,t)}catch(n){if((n.message||"").match(/stack|recursion/i))return console.warn("react-fast-compare cannot handle circular refs"),!1;throw n}}},70405:(e,t,n)=>{"use strict";n.d(t,{B6:()=>B,ql:()=>X});var o=n(67294),i=n(45697),s=n.n(i),a=n(69590),r=n.n(a),p=n(41143),c=n.n(p),d=n(96774),l=n.n(d);function u(){return u=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},u.apply(this,arguments)}function h(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,f(e,t)}function f(e,t){return f=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},f(e,t)}function y(e,t){if(null==e)return{};var n,o,i={},s=Object.keys(e);for(o=0;o<s.length;o++)t.indexOf(n=s[o])>=0||(i[n]=e[n]);return i}var m={BASE:"base",BODY:"body",HEAD:"head",HTML:"html",LINK:"link",META:"meta",NOSCRIPT:"noscript",SCRIPT:"script",STYLE:"style",TITLE:"title",FRAGMENT:"Symbol(react.fragment)"},g={rel:["amphtml","canonical","alternate"]},_={type:["application/ld+json"]},b={charset:"",name:["robots","description"],property:["og:type","og:title","og:url","og:image","og:image:alt","og:description","twitter:url","twitter:title","twitter:description","twitter:image","twitter:image:alt","twitter:card","twitter:site"]},T=Object.keys(m).map((function(e){return m[e]})),v={accesskey:"accessKey",charset:"charSet",class:"className",contenteditable:"contentEditable",contextmenu:"contextMenu","http-equiv":"httpEquiv",itemprop:"itemProp",tabindex:"tabIndex"},P=Object.keys(v).reduce((function(e,t){return e[v[t]]=t,e}),{}),E=function(e,t){for(var n=e.length-1;n>=0;n-=1){var o=e[n];if(Object.prototype.hasOwnProperty.call(o,t))return o[t]}return null},R=function(e){var t=E(e,m.TITLE),n=E(e,"titleTemplate");if(Array.isArray(t)&&(t=t.join("")),n&&t)return n.replace(/%s/g,(function(){return t}));var o=E(e,"defaultTitle");return t||o||void 0},A=function(e){return E(e,"onChangeClientState")||function(){}},k=function(e,t){return t.filter((function(t){return void 0!==t[e]})).map((function(t){return t[e]})).reduce((function(e,t){return u({},e,t)}),{})},w=function(e,t){return t.filter((function(e){return void 0!==e[m.BASE]})).map((function(e){return e[m.BASE]})).reverse().reduce((function(t,n){if(!t.length)for(var o=Object.keys(n),i=0;i<o.length;i+=1){var s=o[i].toLowerCase();if(-1!==e.indexOf(s)&&n[s])return t.concat(n)}return t}),[])},S=function(e,t,n){var o={};return n.filter((function(t){return!!Array.isArray(t[e])||(void 0!==t[e]&&console&&"function"==typeof console.warn&&console.warn("Helmet: "+e+' should be of type "Array". Instead found type "'+typeof t[e]+'"'),!1)})).map((function(t){return t[e]})).reverse().reduce((function(e,n){var i={};n.filter((function(e){for(var n,s=Object.keys(e),a=0;a<s.length;a+=1){var r=s[a],p=r.toLowerCase();-1===t.indexOf(p)||"rel"===n&&"canonical"===e[n].toLowerCase()||"rel"===p&&"stylesheet"===e[p].toLowerCase()||(n=p),-1===t.indexOf(r)||"innerHTML"!==r&&"cssText"!==r&&"itemprop"!==r||(n=r)}if(!n||!e[n])return!1;var c=e[n].toLowerCase();return o[n]||(o[n]={}),i[n]||(i[n]={}),!o[n][c]&&(i[n][c]=!0,!0)})).reverse().forEach((function(t){return e.push(t)}));for(var s=Object.keys(i),a=0;a<s.length;a+=1){var r=s[a],p=u({},o[r],i[r]);o[r]=p}return e}),[]).reverse()},I=function(e,t){if(Array.isArray(e)&&e.length)for(var n=0;n<e.length;n+=1)if(e[n][t])return!0;return!1},O=function(e){return Array.isArray(e)?e.join(""):e},x=function(e,t){return Array.isArray(e)?e.reduce((function(e,n){return function(e,t){for(var n=Object.keys(e),o=0;o<n.length;o+=1)if(t[n[o]]&&t[n[o]].includes(e[n[o]]))return!0;return!1}(n,t)?e.priority.push(n):e.default.push(n),e}),{priority:[],default:[]}):{default:e}},N=function(e,t){var n;return u({},e,((n={})[t]=void 0,n))},U=[m.NOSCRIPT,m.SCRIPT,m.STYLE],Y=function(e,t){return void 0===t&&(t=!0),!1===t?String(e):String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")},C=function(e){return Object.keys(e).reduce((function(t,n){var o=void 0!==e[n]?n+'="'+e[n]+'"':""+n;return t?t+" "+o:o}),"")},L=function(e,t){return void 0===t&&(t={}),Object.keys(e).reduce((function(t,n){return t[v[n]||n]=e[n],t}),t)},D=function(e,t){return t.map((function(t,n){var i,s=((i={key:n})["data-rh"]=!0,i);return Object.keys(t).forEach((function(e){var n=v[e]||e;"innerHTML"===n||"cssText"===n?s.dangerouslySetInnerHTML={__html:t.innerHTML||t.cssText}:s[n]=t[e]})),o.createElement(e,s)}))},q=function(e,t,n){switch(e){case m.TITLE:return{toComponent:function(){return n=t.titleAttributes,(i={key:e=t.title})["data-rh"]=!0,s=L(n,i),[o.createElement(m.TITLE,s,e)];var e,n,i,s},toString:function(){return function(e,t,n,o){var i=C(n),s=O(t);return i?"<"+e+' data-rh="true" '+i+">"+Y(s,o)+"</"+e+">":"<"+e+' data-rh="true">'+Y(s,o)+"</"+e+">"}(e,t.title,t.titleAttributes,n)}};case"bodyAttributes":case"htmlAttributes":return{toComponent:function(){return L(t)},toString:function(){return C(t)}};default:return{toComponent:function(){return D(e,t)},toString:function(){return function(e,t,n){return t.reduce((function(t,o){var i=Object.keys(o).filter((function(e){return!("innerHTML"===e||"cssText"===e)})).reduce((function(e,t){var i=void 0===o[t]?t:t+'="'+Y(o[t],n)+'"';return e?e+" "+i:i}),""),s=o.innerHTML||o.cssText||"",a=-1===U.indexOf(e);return t+"<"+e+' data-rh="true" '+i+(a?"/>":">"+s+"</"+e+">")}),"")}(e,t,n)}}}},F=function(e){var t=e.baseTag,n=e.bodyAttributes,o=e.encode,i=e.htmlAttributes,s=e.noscriptTags,a=e.styleTags,r=e.title,p=void 0===r?"":r,c=e.titleAttributes,d=e.linkTags,l=e.metaTags,u=e.scriptTags,h={toComponent:function(){},toString:function(){return""}};if(e.prioritizeSeoTags){var f=function(e){var t=e.linkTags,n=e.scriptTags,o=e.encode,i=x(e.metaTags,b),s=x(t,g),a=x(n,_);return{priorityMethods:{toComponent:function(){return[].concat(D(m.META,i.priority),D(m.LINK,s.priority),D(m.SCRIPT,a.priority))},toString:function(){return q(m.META,i.priority,o)+" "+q(m.LINK,s.priority,o)+" "+q(m.SCRIPT,a.priority,o)}},metaTags:i.default,linkTags:s.default,scriptTags:a.default}}(e);h=f.priorityMethods,d=f.linkTags,l=f.metaTags,u=f.scriptTags}return{priority:h,base:q(m.BASE,t,o),bodyAttributes:q("bodyAttributes",n,o),htmlAttributes:q("htmlAttributes",i,o),link:q(m.LINK,d,o),meta:q(m.META,l,o),noscript:q(m.NOSCRIPT,s,o),script:q(m.SCRIPT,u,o),style:q(m.STYLE,a,o),title:q(m.TITLE,{title:p,titleAttributes:c},o)}},j=[],M=function(e,t){var n=this;void 0===t&&(t="undefined"!=typeof document),this.instances=[],this.value={setHelmet:function(e){n.context.helmet=e},helmetInstances:{get:function(){return n.canUseDOM?j:n.instances},add:function(e){(n.canUseDOM?j:n.instances).push(e)},remove:function(e){var t=(n.canUseDOM?j:n.instances).indexOf(e);(n.canUseDOM?j:n.instances).splice(t,1)}}},this.context=e,this.canUseDOM=t,t||(e.helmet=F({baseTag:[],bodyAttributes:{},encodeSpecialCharacters:!0,htmlAttributes:{},linkTags:[],metaTags:[],noscriptTags:[],scriptTags:[],styleTags:[],title:"",titleAttributes:{}}))},z=o.createContext({}),V=s().shape({setHelmet:s().func,helmetInstances:s().shape({get:s().func,add:s().func,remove:s().func})}),G="undefined"!=typeof document,B=function(e){function t(n){var o;return(o=e.call(this,n)||this).helmetData=new M(o.props.context,t.canUseDOM),o}return h(t,e),t.prototype.render=function(){return o.createElement(z.Provider,{value:this.helmetData.value},this.props.children)},t}(o.Component);B.canUseDOM=G,B.propTypes={context:s().shape({helmet:s().shape()}),children:s().node.isRequired},B.defaultProps={context:{}},B.displayName="HelmetProvider";var J=function(e,t){var n,o=document.head||document.querySelector(m.HEAD),i=o.querySelectorAll(e+"[data-rh]"),s=[].slice.call(i),a=[];return t&&t.length&&t.forEach((function(t){var o=document.createElement(e);for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&("innerHTML"===i?o.innerHTML=t.innerHTML:"cssText"===i?o.styleSheet?o.styleSheet.cssText=t.cssText:o.appendChild(document.createTextNode(t.cssText)):o.setAttribute(i,void 0===t[i]?"":t[i]));o.setAttribute("data-rh","true"),s.some((function(e,t){return n=t,o.isEqualNode(e)}))?s.splice(n,1):a.push(o)})),s.forEach((function(e){return e.parentNode.removeChild(e)})),a.forEach((function(e){return o.appendChild(e)})),{oldTags:s,newTags:a}},Q=function(e,t){var n=document.getElementsByTagName(e)[0];if(n){for(var o=n.getAttribute("data-rh"),i=o?o.split(","):[],s=[].concat(i),a=Object.keys(t),r=0;r<a.length;r+=1){var p=a[r],c=t[p]||"";n.getAttribute(p)!==c&&n.setAttribute(p,c),-1===i.indexOf(p)&&i.push(p);var d=s.indexOf(p);-1!==d&&s.splice(d,1)}for(var l=s.length-1;l>=0;l-=1)n.removeAttribute(s[l]);i.length===s.length?n.removeAttribute("data-rh"):n.getAttribute("data-rh")!==a.join(",")&&n.setAttribute("data-rh",a.join(","))}},H=function(e,t){var n=e.baseTag,o=e.htmlAttributes,i=e.linkTags,s=e.metaTags,a=e.noscriptTags,r=e.onChangeClientState,p=e.scriptTags,c=e.styleTags,d=e.title,l=e.titleAttributes;Q(m.BODY,e.bodyAttributes),Q(m.HTML,o),function(e,t){void 0!==e&&document.title!==e&&(document.title=O(e)),Q(m.TITLE,t)}(d,l);var u={baseTag:J(m.BASE,n),linkTags:J(m.LINK,i),metaTags:J(m.META,s),noscriptTags:J(m.NOSCRIPT,a),scriptTags:J(m.SCRIPT,p),styleTags:J(m.STYLE,c)},h={},f={};Object.keys(u).forEach((function(e){var t=u[e],n=t.newTags,o=t.oldTags;n.length&&(h[e]=n),o.length&&(f[e]=u[e].oldTags)})),t&&t(),r(e,h,f)},W=null,K=function(e){function t(){for(var t,n=arguments.length,o=new Array(n),i=0;i<n;i++)o[i]=arguments[i];return(t=e.call.apply(e,[this].concat(o))||this).rendered=!1,t}h(t,e);var n=t.prototype;return n.shouldComponentUpdate=function(e){return!l()(e,this.props)},n.componentDidUpdate=function(){this.emitChange()},n.componentWillUnmount=function(){this.props.context.helmetInstances.remove(this),this.emitChange()},n.emitChange=function(){var e,t,n=this.props.context,o=n.setHelmet,i=null,s=(e=n.helmetInstances.get().map((function(e){var t=u({},e.props);return delete t.context,t})),{baseTag:w(["href"],e),bodyAttributes:k("bodyAttributes",e),defer:E(e,"defer"),encode:E(e,"encodeSpecialCharacters"),htmlAttributes:k("htmlAttributes",e),linkTags:S(m.LINK,["rel","href"],e),metaTags:S(m.META,["name","charset","http-equiv","property","itemprop"],e),noscriptTags:S(m.NOSCRIPT,["innerHTML"],e),onChangeClientState:A(e),scriptTags:S(m.SCRIPT,["src","innerHTML"],e),styleTags:S(m.STYLE,["cssText"],e),title:R(e),titleAttributes:k("titleAttributes",e),prioritizeSeoTags:I(e,"prioritizeSeoTags")});B.canUseDOM?(t=s,W&&cancelAnimationFrame(W),t.defer?W=requestAnimationFrame((function(){H(t,(function(){W=null}))})):(H(t),W=null)):F&&(i=F(s)),o(i)},n.init=function(){this.rendered||(this.rendered=!0,this.props.context.helmetInstances.add(this),this.emitChange())},n.render=function(){return this.init(),null},t}(o.Component);K.propTypes={context:V.isRequired},K.displayName="HelmetDispatcher";var $=["children"],Z=["children"],X=function(e){function t(){return e.apply(this,arguments)||this}h(t,e);var n=t.prototype;return n.shouldComponentUpdate=function(e){return!r()(N(this.props,"helmetData"),N(e,"helmetData"))},n.mapNestedChildrenToProps=function(e,t){if(!t)return null;switch(e.type){case m.SCRIPT:case m.NOSCRIPT:return{innerHTML:t};case m.STYLE:return{cssText:t};default:throw new Error("<"+e.type+" /> elements are self-closing and can not contain children. Refer to our API for more information.")}},n.flattenArrayTypeChildren=function(e){var t,n=e.child,o=e.arrayTypeChildren;return u({},o,((t={})[n.type]=[].concat(o[n.type]||[],[u({},e.newChildProps,this.mapNestedChildrenToProps(n,e.nestedChildren))]),t))},n.mapObjectTypeChildren=function(e){var t,n,o=e.child,i=e.newProps,s=e.newChildProps,a=e.nestedChildren;switch(o.type){case m.TITLE:return u({},i,((t={})[o.type]=a,t.titleAttributes=u({},s),t));case m.BODY:return u({},i,{bodyAttributes:u({},s)});case m.HTML:return u({},i,{htmlAttributes:u({},s)});default:return u({},i,((n={})[o.type]=u({},s),n))}},n.mapArrayTypeChildrenToProps=function(e,t){var n=u({},t);return Object.keys(e).forEach((function(t){var o;n=u({},n,((o={})[t]=e[t],o))})),n},n.warnOnInvalidChildren=function(e,t){return c()(T.some((function(t){return e.type===t})),"function"==typeof e.type?"You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.":"Only elements types "+T.join(", ")+" are allowed. Helmet does not support rendering <"+e.type+"> elements. Refer to our API for more information."),c()(!t||"string"==typeof t||Array.isArray(t)&&!t.some((function(e){return"string"!=typeof e})),"Helmet expects a string as a child of <"+e.type+">. Did you forget to wrap your children in braces? ( <"+e.type+">{``}</"+e.type+"> ) Refer to our API for more information."),!0},n.mapChildrenToProps=function(e,t){var n=this,i={};return o.Children.forEach(e,(function(e){if(e&&e.props){var o=e.props,s=o.children,a=y(o,$),r=Object.keys(a).reduce((function(e,t){return e[P[t]||t]=a[t],e}),{}),p=e.type;switch("symbol"==typeof p?p=p.toString():n.warnOnInvalidChildren(e,s),p){case m.FRAGMENT:t=n.mapChildrenToProps(s,t);break;case m.LINK:case m.META:case m.NOSCRIPT:case m.SCRIPT:case m.STYLE:i=n.flattenArrayTypeChildren({child:e,arrayTypeChildren:i,newChildProps:r,nestedChildren:s});break;default:t=n.mapObjectTypeChildren({child:e,newProps:t,newChildProps:r,nestedChildren:s})}}})),this.mapArrayTypeChildrenToProps(i,t)},n.render=function(){var e=this.props,t=e.children,n=y(e,Z),i=u({},n),s=n.helmetData;return t&&(i=this.mapChildrenToProps(t,i)),!s||s instanceof M||(s=new M(s.context,s.instances)),s?o.createElement(K,u({},i,{context:s.value,helmetData:void 0})):o.createElement(z.Consumer,null,(function(e){return o.createElement(K,u({},i,{context:e}))}))},t}(o.Component);X.propTypes={base:s().object,bodyAttributes:s().object,children:s().oneOfType([s().arrayOf(s().node),s().node]),defaultTitle:s().string,defer:s().bool,encodeSpecialCharacters:s().bool,htmlAttributes:s().object,link:s().arrayOf(s().object),meta:s().arrayOf(s().object),noscript:s().arrayOf(s().object),onChangeClientState:s().func,script:s().arrayOf(s().object),style:s().arrayOf(s().object),title:s().string,titleAttributes:s().object,titleTemplate:s().string,prioritizeSeoTags:s().bool,helmetData:s().object},X.defaultProps={defer:!0,encodeSpecialCharacters:!0,prioritizeSeoTags:!1},X.displayName="Helmet"},69921:(e,t)=>{"use strict";var n="function"==typeof Symbol&&Symbol.for,o=n?Symbol.for("react.element"):60103,i=n?Symbol.for("react.portal"):60106,s=n?Symbol.for("react.fragment"):60107,a=n?Symbol.for("react.strict_mode"):60108,r=n?Symbol.for("react.profiler"):60114,p=n?Symbol.for("react.provider"):60109,c=n?Symbol.for("react.context"):60110,d=n?Symbol.for("react.async_mode"):60111,l=n?Symbol.for("react.concurrent_mode"):60111,u=n?Symbol.for("react.forward_ref"):60112,h=n?Symbol.for("react.suspense"):60113,f=n?Symbol.for("react.suspense_list"):60120,y=n?Symbol.for("react.memo"):60115,m=n?Symbol.for("react.lazy"):60116,g=n?Symbol.for("react.block"):60121,_=n?Symbol.for("react.fundamental"):60117,b=n?Symbol.for("react.responder"):60118,T=n?Symbol.for("react.scope"):60119;function v(e){if("object"==typeof e&&null!==e){var t=e.$$typeof;switch(t){case o:switch(e=e.type){case d:case l:case s:case r:case a:case h:return e;default:switch(e=e&&e.$$typeof){case c:case u:case m:case y:case p:return e;default:return t}}case i:return t}}}function P(e){return v(e)===l}t.AsyncMode=d,t.ConcurrentMode=l,t.ContextConsumer=c,t.ContextProvider=p,t.Element=o,t.ForwardRef=u,t.Fragment=s,t.Lazy=m,t.Memo=y,t.Portal=i,t.Profiler=r,t.StrictMode=a,t.Suspense=h,t.isAsyncMode=function(e){return P(e)||v(e)===d},t.isConcurrentMode=P,t.isContextConsumer=function(e){return v(e)===c},t.isContextProvider=function(e){return v(e)===p},t.isElement=function(e){return"object"==typeof e&&null!==e&&e.$$typeof===o},t.isForwardRef=function(e){return v(e)===u},t.isFragment=function(e){return v(e)===s},t.isLazy=function(e){return v(e)===m},t.isMemo=function(e){return v(e)===y},t.isPortal=function(e){return v(e)===i},t.isProfiler=function(e){return v(e)===r},t.isStrictMode=function(e){return v(e)===a},t.isSuspense=function(e){return v(e)===h},t.isValidElementType=function(e){return"string"==typeof e||"function"==typeof e||e===s||e===l||e===r||e===a||e===h||e===f||"object"==typeof e&&null!==e&&(e.$$typeof===m||e.$$typeof===y||e.$$typeof===p||e.$$typeof===c||e.$$typeof===u||e.$$typeof===_||e.$$typeof===b||e.$$typeof===T||e.$$typeof===g)},t.typeOf=v},59864:(e,t,n)=>{"use strict";e.exports=n(69921)},68356:(e,t,n)=>{"use strict";function o(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e.__proto__=t}function i(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(){return a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},a.apply(this,arguments)}var r=n(67294),p=n(45697),c=[],d=[];function l(e){var t=e(),n={loading:!0,loaded:null,error:null};return n.promise=t.then((function(e){return n.loading=!1,n.loaded=e,e})).catch((function(e){throw n.loading=!1,n.error=e,e})),n}function u(e){var t={loading:!1,loaded:{},error:null},n=[];try{Object.keys(e).forEach((function(o){var i=l(e[o]);i.loading?t.loading=!0:(t.loaded[o]=i.loaded,t.error=i.error),n.push(i.promise),i.promise.then((function(e){t.loaded[o]=e})).catch((function(e){t.error=e}))}))}catch(o){t.error=o}return t.promise=Promise.all(n).then((function(e){return t.loading=!1,e})).catch((function(e){throw t.loading=!1,e})),t}function h(e,t){return r.createElement((n=e)&&n.__esModule?n.default:n,t);var n}function f(e,t){var l,u;if(!t.loading)throw new Error("react-loadable requires a `loading` component");var f=a({loader:null,loading:null,delay:200,timeout:null,render:h,webpack:null,modules:null},t),y=null;function m(){return y||(y=e(f.loader)),y.promise}return c.push(m),"function"==typeof f.webpack&&d.push((function(){if((0,f.webpack)().every((function(e){return void 0!==e&&void 0!==n.m[e]})))return m()})),u=l=function(t){function n(n){var o;return s(i(i(o=t.call(this,n)||this)),"retry",(function(){o.setState({error:null,loading:!0,timedOut:!1}),y=e(f.loader),o._loadModule()})),m(),o.state={error:y.error,pastDelay:!1,timedOut:!1,loading:y.loading,loaded:y.loaded},o}o(n,t),n.preload=function(){return m()};var a=n.prototype;return a.UNSAFE_componentWillMount=function(){this._loadModule()},a.componentDidMount=function(){this._mounted=!0},a._loadModule=function(){var e=this;if(this.context.loadable&&Array.isArray(f.modules)&&f.modules.forEach((function(t){e.context.loadable.report(t)})),y.loading){var t=function(t){e._mounted&&e.setState(t)};"number"==typeof f.delay&&(0===f.delay?this.setState({pastDelay:!0}):this._delay=setTimeout((function(){t({pastDelay:!0})}),f.delay)),"number"==typeof f.timeout&&(this._timeout=setTimeout((function(){t({timedOut:!0})}),f.timeout));var n=function(){t({error:y.error,loaded:y.loaded,loading:y.loading}),e._clearTimeouts()};y.promise.then((function(){return n(),null})).catch((function(e){return n(),null}))}},a.componentWillUnmount=function(){this._mounted=!1,this._clearTimeouts()},a._clearTimeouts=function(){clearTimeout(this._delay),clearTimeout(this._timeout)},a.render=function(){return this.state.loading||this.state.error?r.createElement(f.loading,{isLoading:this.state.loading,pastDelay:this.state.pastDelay,timedOut:this.state.timedOut,error:this.state.error,retry:this.retry}):this.state.loaded?f.render(this.state.loaded,this.props):null},n}(r.Component),s(l,"contextTypes",{loadable:p.shape({report:p.func.isRequired})}),u}function y(e){return f(l,e)}y.Map=function(e){if("function"!=typeof e.render)throw new Error("LoadableMap requires a `render(loaded, props)` function");return f(u,e)};var m=function(e){function t(){return e.apply(this,arguments)||this}o(t,e);var n=t.prototype;return n.getChildContext=function(){return{loadable:{report:this.props.report}}},n.render=function(){return r.Children.only(this.props.children)},t}(r.Component);function g(e){for(var t=[];e.length;){var n=e.pop();t.push(n())}return Promise.all(t).then((function(){if(e.length)return g(e)}))}s(m,"propTypes",{report:p.func.isRequired}),s(m,"childContextTypes",{loadable:p.shape({report:p.func.isRequired}).isRequired}),y.Capture=m,y.preloadAll=function(){return new Promise((function(e,t){g(c).then(e,t)}))},y.preloadReady=function(){return new Promise((function(e,t){g(d).then(e,e)}))},e.exports=y},18790:(e,t,n)=>{"use strict";n.d(t,{H:()=>r,f:()=>a});var o=n(16550),i=n(83117),s=n(67294);function a(e,t,n){return void 0===n&&(n=[]),e.some((function(e){var i=e.path?(0,o.LX)(t,e):n.length?n[n.length-1].match:o.F0.computeRootMatch(t);return i&&(n.push({route:e,match:i}),e.routes&&a(e.routes,t,n)),i})),n}function r(e,t,n){return void 0===t&&(t={}),void 0===n&&(n={}),e?s.createElement(o.rs,n,e.map((function(e,n){return s.createElement(o.AW,{key:e.key||n,path:e.path,exact:e.exact,strict:e.strict,render:function(n){return e.render?e.render((0,i.Z)({},n,{},t,{route:e})):s.createElement(e.component,(0,i.Z)({},n,t,{route:e}))}})}))):null}},73727:(e,t,n)=>{"use strict";n.d(t,{OL:()=>b,VK:()=>d,rU:()=>m});var o=n(16550),i=n(21073),s=n(67294),a=n(99318),r=n(83117),p=n(80102),c=n(38776),d=function(e){function t(){for(var t,n=arguments.length,o=new Array(n),i=0;i<n;i++)o[i]=arguments[i];return(t=e.call.apply(e,[this].concat(o))||this).history=(0,a.lX)(t.props),t}return(0,i.Z)(t,e),t.prototype.render=function(){return s.createElement(o.F0,{history:this.history,children:this.props.children})},t}(s.Component);s.Component;var l=function(e,t){return"function"==typeof e?e(t):e},u=function(e,t){return"string"==typeof e?(0,a.ob)(e,null,null,t):e},h=function(e){return e},f=s.forwardRef;void 0===f&&(f=h);var y=f((function(e,t){var n=e.innerRef,o=e.navigate,i=e.onClick,a=(0,p.Z)(e,["innerRef","navigate","onClick"]),c=a.target,d=(0,r.Z)({},a,{onClick:function(e){try{i&&i(e)}catch(t){throw e.preventDefault(),t}e.defaultPrevented||0!==e.button||c&&"_self"!==c||function(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}(e)||(e.preventDefault(),o())}});return d.ref=h!==f&&t||n,s.createElement("a",d)}));var m=f((function(e,t){var n=e.component,i=void 0===n?y:n,d=e.replace,m=e.to,g=e.innerRef,_=(0,p.Z)(e,["component","replace","to","innerRef"]);return s.createElement(o.s6.Consumer,null,(function(e){e||(0,c.Z)(!1);var n=e.history,o=u(l(m,e.location),e.location),p=o?n.createHref(o):"",y=(0,r.Z)({},_,{href:p,navigate:function(){var t=l(m,e.location),o=(0,a.Ep)(e.location)===(0,a.Ep)(u(t));(d||o?n.replace:n.push)(t)}});return h!==f?y.ref=t||g:y.innerRef=g,s.createElement(i,y)}))})),g=function(e){return e},_=s.forwardRef;void 0===_&&(_=g);var b=_((function(e,t){var n=e["aria-current"],i=void 0===n?"page":n,a=e.activeClassName,d=void 0===a?"active":a,h=e.activeStyle,f=e.className,y=e.exact,b=e.isActive,T=e.location,v=e.sensitive,P=e.strict,E=e.style,R=e.to,A=e.innerRef,k=(0,p.Z)(e,["aria-current","activeClassName","activeStyle","className","exact","isActive","location","sensitive","strict","style","to","innerRef"]);return s.createElement(o.s6.Consumer,null,(function(e){e||(0,c.Z)(!1);var n=T||e.location,a=u(l(R,n),n),p=a.pathname,w=p&&p.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1"),S=w?(0,o.LX)(n.pathname,{path:w,exact:y,sensitive:v,strict:P}):null,I=!!(b?b(S,n):S),O="function"==typeof f?f(I):f,x="function"==typeof E?E(I):E;I&&(O=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return t.filter((function(e){return e})).join(" ")}(O,d),x=(0,r.Z)({},x,h));var N=(0,r.Z)({"aria-current":I&&i||null,className:O,style:x,to:a},k);return g!==_?N.ref=t||A:N.innerRef=A,s.createElement(m,N)}))}))},16550:(e,t,n)=>{"use strict";n.d(t,{AW:()=>R,F0:()=>b,LX:()=>E,TH:()=>U,k6:()=>N,rs:()=>O,s6:()=>_});var o=n(21073),i=n(67294),s=n(45697),a=n.n(s),r=n(99318),p=n(38776),c=n(83117),d=n(39658),l=n.n(d),u=(n(59864),n(80102)),h=(n(8679),1073741823),f="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:void 0!==n.g?n.g:{};var y=i.createContext||function(e,t){var n,s,r="__create-react-context-"+function(){var e="__global_unique_id__";return f[e]=(f[e]||0)+1}()+"__",p=function(e){function n(){for(var t,n,o,i=arguments.length,s=new Array(i),a=0;a<i;a++)s[a]=arguments[a];return(t=e.call.apply(e,[this].concat(s))||this).emitter=(n=t.props.value,o=[],{on:function(e){o.push(e)},off:function(e){o=o.filter((function(t){return t!==e}))},get:function(){return n},set:function(e,t){n=e,o.forEach((function(e){return e(n,t)}))}}),t}(0,o.Z)(n,e);var i=n.prototype;return i.getChildContext=function(){var e;return(e={})[r]=this.emitter,e},i.componentWillReceiveProps=function(e){if(this.props.value!==e.value){var n,o=this.props.value,i=e.value;((s=o)===(a=i)?0!==s||1/s==1/a:s!=s&&a!=a)?n=0:(n="function"==typeof t?t(o,i):h,0!==(n|=0)&&this.emitter.set(e.value,n))}var s,a},i.render=function(){return this.props.children},n}(i.Component);p.childContextTypes=((n={})[r]=a().object.isRequired,n);var c=function(t){function n(){for(var e,n=arguments.length,o=new Array(n),i=0;i<n;i++)o[i]=arguments[i];return(e=t.call.apply(t,[this].concat(o))||this).observedBits=void 0,e.state={value:e.getValue()},e.onUpdate=function(t,n){0!=((0|e.observedBits)&n)&&e.setState({value:e.getValue()})},e}(0,o.Z)(n,t);var i=n.prototype;return i.componentWillReceiveProps=function(e){var t=e.observedBits;this.observedBits=null==t?h:t},i.componentDidMount=function(){this.context[r]&&this.context[r].on(this.onUpdate);var e=this.props.observedBits;this.observedBits=null==e?h:e},i.componentWillUnmount=function(){this.context[r]&&this.context[r].off(this.onUpdate)},i.getValue=function(){return this.context[r]?this.context[r].get():e},i.render=function(){return(e=this.props.children,Array.isArray(e)?e[0]:e)(this.state.value);var e},n}(i.Component);return c.contextTypes=((s={})[r]=a().object,s),{Provider:p,Consumer:c}},m=function(e){var t=y();return t.displayName=e,t},g=m("Router-History"),_=m("Router"),b=function(e){function t(t){var n;return(n=e.call(this,t)||this).state={location:t.history.location},n._isMounted=!1,n._pendingLocation=null,t.staticContext||(n.unlisten=t.history.listen((function(e){n._pendingLocation=e}))),n}(0,o.Z)(t,e),t.computeRootMatch=function(e){return{path:"/",url:"/",params:{},isExact:"/"===e}};var n=t.prototype;return n.componentDidMount=function(){var e=this;this._isMounted=!0,this.unlisten&&this.unlisten(),this.props.staticContext||(this.unlisten=this.props.history.listen((function(t){e._isMounted&&e.setState({location:t})}))),this._pendingLocation&&this.setState({location:this._pendingLocation})},n.componentWillUnmount=function(){this.unlisten&&(this.unlisten(),this._isMounted=!1,this._pendingLocation=null)},n.render=function(){return i.createElement(_.Provider,{value:{history:this.props.history,location:this.state.location,match:t.computeRootMatch(this.state.location.pathname),staticContext:this.props.staticContext}},i.createElement(g.Provider,{children:this.props.children||null,value:this.props.history}))},t}(i.Component);i.Component;i.Component;var T={},v=1e4,P=0;function E(e,t){void 0===t&&(t={}),("string"==typeof t||Array.isArray(t))&&(t={path:t});var n=t,o=n.path,i=n.exact,s=void 0!==i&&i,a=n.strict,r=void 0!==a&&a,p=n.sensitive,c=void 0!==p&&p;return[].concat(o).reduce((function(t,n){if(!n&&""!==n)return null;if(t)return t;var o=function(e,t){var n=""+t.end+t.strict+t.sensitive,o=T[n]||(T[n]={});if(o[e])return o[e];var i=[],s={regexp:l()(e,i,t),keys:i};return P<v&&(o[e]=s,P++),s}(n,{end:s,strict:r,sensitive:c}),i=o.regexp,a=o.keys,p=i.exec(e);if(!p)return null;var d=p[0],u=p.slice(1),h=e===d;return s&&!h?null:{path:n,url:"/"===n&&""===d?"/":d,isExact:h,params:a.reduce((function(e,t,n){return e[t.name]=u[n],e}),{})}}),null)}var R=function(e){function t(){return e.apply(this,arguments)||this}return(0,o.Z)(t,e),t.prototype.render=function(){var e=this;return i.createElement(_.Consumer,null,(function(t){t||(0,p.Z)(!1);var n=e.props.location||t.location,o=e.props.computedMatch?e.props.computedMatch:e.props.path?E(n.pathname,e.props):t.match,s=(0,c.Z)({},t,{location:n,match:o}),a=e.props,r=a.children,d=a.component,l=a.render;return Array.isArray(r)&&function(e){return 0===i.Children.count(e)}(r)&&(r=null),i.createElement(_.Provider,{value:s},s.match?r?"function"==typeof r?r(s):r:d?i.createElement(d,s):l?l(s):null:"function"==typeof r?r(s):null)}))},t}(i.Component);function A(e){return"/"===e.charAt(0)?e:"/"+e}function k(e,t){if(!e)return t;var n=A(e);return 0!==t.pathname.indexOf(n)?t:(0,c.Z)({},t,{pathname:t.pathname.substr(n.length)})}function w(e){return"string"==typeof e?e:(0,r.Ep)(e)}function S(e){return function(){(0,p.Z)(!1)}}function I(){}i.Component;var O=function(e){function t(){return e.apply(this,arguments)||this}return(0,o.Z)(t,e),t.prototype.render=function(){var e=this;return i.createElement(_.Consumer,null,(function(t){t||(0,p.Z)(!1);var n,o,s=e.props.location||t.location;return i.Children.forEach(e.props.children,(function(e){if(null==o&&i.isValidElement(e)){n=e;var a=e.props.path||e.props.from;o=a?E(s.pathname,(0,c.Z)({},e.props,{path:a})):t.match}})),o?i.cloneElement(n,{location:s,computedMatch:o}):null}))},t}(i.Component);var x=i.useContext;function N(){return x(g)}function U(){return x(_).location}},39658:(e,t,n)=>{var o=n(5826);e.exports=h,e.exports.parse=s,e.exports.compile=function(e,t){return r(s(e,t),t)},e.exports.tokensToFunction=r,e.exports.tokensToRegExp=u;var i=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function s(e,t){for(var n,o=[],s=0,a=0,r="",d=t&&t.delimiter||"/";null!=(n=i.exec(e));){var l=n[0],u=n[1],h=n.index;if(r+=e.slice(a,h),a=h+l.length,u)r+=u[1];else{var f=e[a],y=n[2],m=n[3],g=n[4],_=n[5],b=n[6],T=n[7];r&&(o.push(r),r="");var v=null!=y&&null!=f&&f!==y,P="+"===b||"*"===b,E="?"===b||"*"===b,R=n[2]||d,A=g||_;o.push({name:m||s++,prefix:y||"",delimiter:R,optional:E,repeat:P,partial:v,asterisk:!!T,pattern:A?c(A):T?".*":"[^"+p(R)+"]+?"})}}return a<e.length&&(r+=e.substr(a)),r&&o.push(r),o}function a(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function r(e,t){for(var n=new Array(e.length),i=0;i<e.length;i++)"object"==typeof e[i]&&(n[i]=new RegExp("^(?:"+e[i].pattern+")$",l(t)));return function(t,i){for(var s="",r=t||{},p=(i||{}).pretty?a:encodeURIComponent,c=0;c<e.length;c++){var d=e[c];if("string"!=typeof d){var l,u=r[d.name];if(null==u){if(d.optional){d.partial&&(s+=d.prefix);continue}throw new TypeError('Expected "'+d.name+'" to be defined')}if(o(u)){if(!d.repeat)throw new TypeError('Expected "'+d.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(d.optional)continue;throw new TypeError('Expected "'+d.name+'" to not be empty')}for(var h=0;h<u.length;h++){if(l=p(u[h]),!n[c].test(l))throw new TypeError('Expected all "'+d.name+'" to match "'+d.pattern+'", but received `'+JSON.stringify(l)+"`");s+=(0===h?d.prefix:d.delimiter)+l}}else{if(l=d.asterisk?encodeURI(u).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()})):p(u),!n[c].test(l))throw new TypeError('Expected "'+d.name+'" to match "'+d.pattern+'", but received "'+l+'"');s+=d.prefix+l}}else s+=d}return s}}function p(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function c(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function d(e,t){return e.keys=t,e}function l(e){return e&&e.sensitive?"":"i"}function u(e,t,n){o(t)||(n=t||n,t=[]);for(var i=(n=n||{}).strict,s=!1!==n.end,a="",r=0;r<e.length;r++){var c=e[r];if("string"==typeof c)a+=p(c);else{var u=p(c.prefix),h="(?:"+c.pattern+")";t.push(c),c.repeat&&(h+="(?:"+u+h+")*"),a+=h=c.optional?c.partial?u+"("+h+")?":"(?:"+u+"("+h+"))?":u+"("+h+")"}}var f=p(n.delimiter||"/"),y=a.slice(-f.length)===f;return i||(a=(y?a.slice(0,-f.length):a)+"(?:"+f+"(?=$))?"),a+=s?"$":i&&y?"":"(?="+f+"|$)",d(new RegExp("^"+a,l(n)),t)}function h(e,t,n){return o(t)||(n=t||n,t=[]),n=n||{},e instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var o=0;o<n.length;o++)t.push({name:o,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return d(e,t)}(e,t):o(e)?function(e,t,n){for(var o=[],i=0;i<e.length;i++)o.push(h(e[i],t,n).source);return d(new RegExp("(?:"+o.join("|")+")",l(n)),t)}(e,t,n):function(e,t,n){return u(s(e,n),t,n)}(e,t,n)}},75251:(e,t,n)=>{"use strict";var o=n(67294),i=Symbol.for("react.element"),s=Symbol.for("react.fragment"),a=Object.prototype.hasOwnProperty,r=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};function c(e,t,n){var o,s={},c=null,d=null;for(o in void 0!==n&&(c=""+n),void 0!==t.key&&(c=""+t.key),void 0!==t.ref&&(d=t.ref),t)a.call(t,o)&&!p.hasOwnProperty(o)&&(s[o]=t[o]);if(e&&e.defaultProps)for(o in t=e.defaultProps)void 0===s[o]&&(s[o]=t[o]);return{$$typeof:i,type:e,key:c,ref:d,props:s,_owner:r.current}}t.Fragment=s,t.jsx=c,t.jsxs=c},72408:(e,t)=>{"use strict";var n=Symbol.for("react.element"),o=Symbol.for("react.portal"),i=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),a=Symbol.for("react.profiler"),r=Symbol.for("react.provider"),p=Symbol.for("react.context"),c=Symbol.for("react.forward_ref"),d=Symbol.for("react.suspense"),l=Symbol.for("react.memo"),u=Symbol.for("react.lazy"),h=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},y=Object.assign,m={};function g(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||f}function _(){}function b(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||f}g.prototype.isReactComponent={},g.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},g.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},_.prototype=g.prototype;var T=b.prototype=new _;T.constructor=b,y(T,g.prototype),T.isPureReactComponent=!0;var v=Array.isArray,P=Object.prototype.hasOwnProperty,E={current:null},R={key:!0,ref:!0,__self:!0,__source:!0};function A(e,t,o){var i,s={},a=null,r=null;if(null!=t)for(i in void 0!==t.ref&&(r=t.ref),void 0!==t.key&&(a=""+t.key),t)P.call(t,i)&&!R.hasOwnProperty(i)&&(s[i]=t[i]);var p=arguments.length-2;if(1===p)s.children=o;else if(1<p){for(var c=Array(p),d=0;d<p;d++)c[d]=arguments[d+2];s.children=c}if(e&&e.defaultProps)for(i in p=e.defaultProps)void 0===s[i]&&(s[i]=p[i]);return{$$typeof:n,type:e,key:a,ref:r,props:s,_owner:E.current}}function k(e){return"object"==typeof e&&null!==e&&e.$$typeof===n}var w=/\/+/g;function S(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function I(e,t,i,s,a){var r=typeof e;"undefined"!==r&&"boolean"!==r||(e=null);var p=!1;if(null===e)p=!0;else switch(r){case"string":case"number":p=!0;break;case"object":switch(e.$$typeof){case n:case o:p=!0}}if(p)return a=a(p=e),e=""===s?"."+S(p,0):s,v(a)?(i="",null!=e&&(i=e.replace(w,"$&/")+"/"),I(a,t,i,"",(function(e){return e}))):null!=a&&(k(a)&&(a=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(a,i+(!a.key||p&&p.key===a.key?"":(""+a.key).replace(w,"$&/")+"/")+e)),t.push(a)),1;if(p=0,s=""===s?".":s+":",v(e))for(var c=0;c<e.length;c++){var d=s+S(r=e[c],c);p+=I(r,t,i,d,a)}else if(d=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=h&&e[h]||e["@@iterator"])?e:null}(e),"function"==typeof d)for(e=d.call(e),c=0;!(r=e.next()).done;)p+=I(r=r.value,t,i,d=s+S(r,c++),a);else if("object"===r)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return p}function O(e,t,n){if(null==e)return e;var o=[],i=0;return I(e,o,"","",(function(e){return t.call(n,e,i++)})),o}function x(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var N={current:null},U={transition:null},Y={ReactCurrentDispatcher:N,ReactCurrentBatchConfig:U,ReactCurrentOwner:E};t.Children={map:O,forEach:function(e,t,n){O(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return O(e,(function(){t++})),t},toArray:function(e){return O(e,(function(e){return e}))||[]},only:function(e){if(!k(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=g,t.Fragment=i,t.Profiler=a,t.PureComponent=b,t.StrictMode=s,t.Suspense=d,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Y,t.cloneElement=function(e,t,o){if(null==e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var i=y({},e.props),s=e.key,a=e.ref,r=e._owner;if(null!=t){if(void 0!==t.ref&&(a=t.ref,r=E.current),void 0!==t.key&&(s=""+t.key),e.type&&e.type.defaultProps)var p=e.type.defaultProps;for(c in t)P.call(t,c)&&!R.hasOwnProperty(c)&&(i[c]=void 0===t[c]&&void 0!==p?p[c]:t[c])}var c=arguments.length-2;if(1===c)i.children=o;else if(1<c){p=Array(c);for(var d=0;d<c;d++)p[d]=arguments[d+2];i.children=p}return{$$typeof:n,type:e.type,key:s,ref:a,props:i,_owner:r}},t.createContext=function(e){return(e={$$typeof:p,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:r,_context:e},e.Consumer=e},t.createElement=A,t.createFactory=function(e){var t=A.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:c,render:e}},t.isValidElement=k,t.lazy=function(e){return{$$typeof:u,_payload:{_status:-1,_result:e},_init:x}},t.memo=function(e,t){return{$$typeof:l,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=U.transition;U.transition={};try{e()}finally{U.transition=t}},t.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},t.useCallback=function(e,t){return N.current.useCallback(e,t)},t.useContext=function(e){return N.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return N.current.useDeferredValue(e)},t.useEffect=function(e,t){return N.current.useEffect(e,t)},t.useId=function(){return N.current.useId()},t.useImperativeHandle=function(e,t,n){return N.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return N.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return N.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return N.current.useMemo(e,t)},t.useReducer=function(e,t,n){return N.current.useReducer(e,t,n)},t.useRef=function(e){return N.current.useRef(e)},t.useState=function(e){return N.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return N.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return N.current.useTransition()},t.version="18.2.0"},67294:(e,t,n)=>{"use strict";e.exports=n(72408)},85893:(e,t,n)=>{"use strict";e.exports=n(75251)},60053:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var o=n-1>>>1,i=e[o];if(!(0<s(i,t)))break e;e[o]=t,e[n]=i,n=o}}function o(e){return 0===e.length?null:e[0]}function i(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var o=0,i=e.length,a=i>>>1;o<a;){var r=2*(o+1)-1,p=e[r],c=r+1,d=e[c];if(0>s(p,n))c<i&&0>s(d,p)?(e[o]=d,e[c]=n,o=c):(e[o]=p,e[r]=n,o=r);else{if(!(c<i&&0>s(d,n)))break e;e[o]=d,e[c]=n,o=c}}}return t}function s(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"==typeof performance&&"function"==typeof performance.now){var a=performance;t.unstable_now=function(){return a.now()}}else{var r=Date,p=r.now();t.unstable_now=function(){return r.now()-p}}var c=[],d=[],l=1,u=null,h=3,f=!1,y=!1,m=!1,g="function"==typeof setTimeout?setTimeout:null,_="function"==typeof clearTimeout?clearTimeout:null,b="undefined"!=typeof setImmediate?setImmediate:null;function T(e){for(var t=o(d);null!==t;){if(null===t.callback)i(d);else{if(!(t.startTime<=e))break;i(d),t.sortIndex=t.expirationTime,n(c,t)}t=o(d)}}function v(e){if(m=!1,T(e),!y)if(null!==o(c))y=!0,U(P);else{var t=o(d);null!==t&&Y(v,t.startTime-e)}}function P(e,n){y=!1,m&&(m=!1,_(k),k=-1),f=!0;var s=h;try{for(T(n),u=o(c);null!==u&&(!(u.expirationTime>n)||e&&!I());){var a=u.callback;if("function"==typeof a){u.callback=null,h=u.priorityLevel;var r=a(u.expirationTime<=n);n=t.unstable_now(),"function"==typeof r?u.callback=r:u===o(c)&&i(c),T(n)}else i(c);u=o(c)}if(null!==u)var p=!0;else{var l=o(d);null!==l&&Y(v,l.startTime-n),p=!1}return p}finally{u=null,h=s,f=!1}}"undefined"!=typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var E,R=!1,A=null,k=-1,w=5,S=-1;function I(){return!(t.unstable_now()-S<w)}function O(){if(null!==A){var e=t.unstable_now();S=e;var n=!0;try{n=A(!0,e)}finally{n?E():(R=!1,A=null)}}else R=!1}if("function"==typeof b)E=function(){b(O)};else if("undefined"!=typeof MessageChannel){var x=new MessageChannel,N=x.port2;x.port1.onmessage=O,E=function(){N.postMessage(null)}}else E=function(){g(O,0)};function U(e){A=e,R||(R=!0,E())}function Y(e,n){k=g((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){y||f||(y=!0,U(P))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):w=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return h},t.unstable_getFirstCallbackNode=function(){return o(c)},t.unstable_next=function(e){switch(h){case 1:case 2:case 3:var t=3;break;default:t=h}var n=h;h=t;try{return e()}finally{h=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=h;h=e;try{return t()}finally{h=n}},t.unstable_scheduleCallback=function(e,i,s){var a=t.unstable_now();switch("object"==typeof s&&null!==s?s="number"==typeof(s=s.delay)&&0<s?a+s:a:s=a,e){case 1:var r=-1;break;case 2:r=250;break;case 5:r=1073741823;break;case 4:r=1e4;break;default:r=5e3}return e={id:l++,callback:i,priorityLevel:e,startTime:s,expirationTime:r=s+r,sortIndex:-1},s>a?(e.sortIndex=s,n(d,e),null===o(c)&&e===o(d)&&(m?(_(k),k=-1):m=!0,Y(v,s-a))):(e.sortIndex=r,n(c,e),y||f||(y=!0,U(P))),e},t.unstable_shouldYield=I,t.unstable_wrapCallback=function(e){var t=h;return function(){var n=h;h=t;try{return e.apply(this,arguments)}finally{h=n}}}},63840:(e,t,n)=>{"use strict";e.exports=n(60053)},96774:e=>{e.exports=function(e,t,n,o){var i=n?n.call(o,e,t):void 0;if(void 0!==i)return!!i;if(e===t)return!0;if("object"!=typeof e||!e||"object"!=typeof t||!t)return!1;var s=Object.keys(e),a=Object.keys(t);if(s.length!==a.length)return!1;for(var r=Object.prototype.hasOwnProperty.bind(t),p=0;p<s.length;p++){var c=s[p];if(!r(c))return!1;var d=e[c],l=t[c];if(!1===(i=n?n.call(o,d,l,c):void 0)||void 0===i&&d!==l)return!1}return!0}},36809:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>o});const o={title:"Provenance Blockchain Developer Portal",tagline:"A distributed, proof-of-stake blockchain designed for financial service industries.",url:"https://developer.provenance.io",baseUrl:"/",onBrokenLinks:"warn",onBrokenMarkdownLinks:"warn",favicon:"img/prov-logo.svg",organizationName:"provenance-io",projectName:"docs",i18n:{defaultLocale:"en",locales:["en"],path:"i18n",localeConfigs:{}},presets:[["classic",{docs:{sidebarPath:"/home/runner/work/provenance-docs/provenance-docs/sidebars.js",remarkPlugins:[null],rehypePlugins:[null]},blog:!1,theme:{customCss:"/home/runner/work/provenance-docs/provenance-docs/src/css/custom.css"},gtag:{trackingID:"G-J8X4N657D9",anonymizeIP:!0}}],["redocusaurus",{specs:[{spec:"openapi/swagger.yaml",route:"/api/"}],theme:{primaryColor:"#18367C"}}]],stylesheets:[{href:"https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css",type:"text/css",integrity:"sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM",crossorigin:"anonymous"}],themeConfig:{algolia:{appId:"5NLCC7K64G",apiKey:"b9b681f8cda531803db53d5636b77ca3",indexName:"developer-provenance",contextualSearch:!0,searchParameters:{},searchPagePath:"search"},navbar:{logo:{alt:"Provenance Blockchain Logo",src:"img/prov-logo-full-color.png"},items:[{type:"dropdown",position:"left",label:"Quick Start",items:[{label:"Start Here",to:"docs/quick-start/start-here"},{label:"Get a Wallet & Hash",to:"docs/quick-start/wallet-and-hash"},{label:"Run a Node",to:"docs/pb/blockchain/running-a-node/running-a-node-1/"},{label:"Become a Validator",to:"docs/quick-start/become-a-validator"},{label:"Tokenize an Asset",to:"docs/learn/asset-lifecycle/markers"},{label:"Build a dApp",to:"docs/quick-start/build-a-dapp"},{label:"Write a Smart Contract",to:"docs/quick-start/write-a-smart-contract"}]},{label:"Guides",type:"dropdown",position:"left",items:[{label:"Asset Lifecycle Guide",to:"docs/learn/asset-lifecycle/assets-overview"},{label:"dApp Builder's Guide",to:"docs/learn/dapps/dapps-overview"},{label:"More Guides & Tutorials",to:"docs/learn/learn-about"}]},{label:"Build",type:"dropdown",position:"left",items:[{label:"Dev Environment",to:"docs/build/dev-environment"},{label:"Clients",to:"docs/build/clients"},{label:"Libraries and APIs",to:"docs/build/libraries"},{label:"Grants Program",to:"https://provenance.io/grants"}]},{label:"Discover",type:"dropdown",position:"left",items:[{label:"Provenance Explorer",to:"docs/discover/explorer"},{label:"Wallets",to:"docs/discover/wallets"},{label:"Hash",to:"docs/discover/hash"},{label:"USDF",to:"docs/discover/usdf"},{label:"Smart Contract Catalog",to:"docs/discover/smart-contract-catalog"},{label:"dApps",to:"docs/discover/dapps"}]},{label:"Connect",type:"dropdown",position:"left",items:[{label:"GitHub",to:"https://github.com/provenance-io/"},{label:"Discord",to:"https://discord.gg/kNZC8nwCFP"},{label:"LinkedIn",to:"https://www.linkedin.com/company/provenance-blockchain/"},{label:"Twitter",to:"https://twitter.com/provenancefdn"},{label:"Blog",to:"https://medium.com/provenanceblockchain"}]},{type:"doc",docId:"index",position:"left",label:"Documentation"},{href:"https://github.com/provenance-io",label:"GitHub",position:"right"}],hideOnScroll:!1},footer:{style:"dark",links:[{title:"Contact",items:[{label:"inbound@provenance.io",href:"mailto:inbound@provenance.io"}]},{title:"Community",items:[{label:"Discord",href:"https://discord.gg/kNZC8nwCFP"},{label:"Twitter",href:"https://twitter.com/provenancefdn"}]},{title:"More",items:[{label:"Blog",href:"https://medium.com/provenanceblockchain"},{label:"GitHub",href:"https://github.com/provenance-io"}]}],copyright:"Copyright \xa9 2024 Provenance Blockchain Foundation"},prism:{theme:{plain:{color:"#F8F8F2",backgroundColor:"#282A36"},styles:[{types:["prolog","constant","builtin"],style:{color:"rgb(189, 147, 249)"}},{types:["inserted","function"],style:{color:"rgb(80, 250, 123)"}},{types:["deleted"],style:{color:"rgb(255, 85, 85)"}},{types:["changed"],style:{color:"rgb(255, 184, 108)"}},{types:["punctuation","symbol"],style:{color:"rgb(248, 248, 242)"}},{types:["string","char","tag","selector"],style:{color:"rgb(255, 121, 198)"}},{types:["keyword","variable"],style:{color:"rgb(189, 147, 249)",fontStyle:"italic"}},{types:["comment"],style:{color:"rgb(98, 114, 164)"}},{types:["attr-name"],style:{color:"rgb(241, 250, 140)"}}]},additionalLanguages:["bash","json","kotlin","protobuf"],magicComments:[{className:"theme-code-block-highlighted-line",line:"highlight-next-line",block:{start:"highlight-start",end:"highlight-end"}}]},colorMode:{defaultMode:"light",disableSwitch:!1,respectPrefersColorScheme:!1},docs:{versionPersistence:"localStorage",sidebar:{hideable:!1,autoCollapseCategories:!1}},metadata:[],tableOfContents:{minHeadingLevel:2,maxHeadingLevel:3}},plugins:[null,["@docusaurus/plugin-client-redirects",{redirects:[{from:"/docs/quick-start/run-a-node",to:"/docs/pb/blockchain/running-a-node/running-a-node-1/"},{from:"/docs/pb/ecosystem/financial-services-blockchain/token-economics",to:"https://provenance.io/ecosystem/HASH/tokenomics/"}]}]],baseUrlIssueBanner:!0,onDuplicateRoutes:"warn",staticDirectories:["static"],customFields:{},themes:[],scripts:[],headTags:[],clientModules:[],titleDelimiter:"|",noIndex:!1,markdown:{format:"mdx",mermaid:!1,mdx1Compat:{comments:!0,admonitions:!0,headingIds:!0}}}},83117:(e,t,n)=>{"use strict";function o(){return o=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},o.apply(this,arguments)}n.d(t,{Z:()=>o})},21073:(e,t,n)=>{"use strict";n.d(t,{Z:()=>i});var o=n(79817);function i(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,(0,o.Z)(e,t)}},80102:(e,t,n)=>{"use strict";function o(e,t){if(null==e)return{};var n,o,i={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}n.d(t,{Z:()=>o})},79817:(e,t,n)=>{"use strict";function o(e,t){return o=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},o(e,t)}n.d(t,{Z:()=>o})},34798:(e,t,n)=>{"use strict";n.d(t,{p1:()=>w,y$:()=>ee});var o,i,s,a,r,p,c,d=n(67294),l=n(90512),u=Object.create,h=Object.defineProperty,f=Object.defineProperties,y=Object.getOwnPropertyDescriptor,m=Object.getOwnPropertyDescriptors,g=Object.getOwnPropertyNames,_=Object.getOwnPropertySymbols,b=Object.getPrototypeOf,T=Object.prototype.hasOwnProperty,v=Object.prototype.propertyIsEnumerable,P=(e,t,n)=>t in e?h(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,E=(e,t)=>{for(var n in t||(t={}))T.call(t,n)&&P(e,n,t[n]);if(_)for(var n of _(t))v.call(t,n)&&P(e,n,t[n]);return e},R=(e,t)=>f(e,m(t)),A=(e,t)=>{var n={};for(var o in e)T.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&_)for(var o of _(e))t.indexOf(o)<0&&v.call(e,o)&&(n[o]=e[o]);return n},k=(o={"../../node_modules/.pnpm/prismjs@1.29.0_patch_hash=vrxx3pzkik6jpmgpayxfjunetu/node_modules/prismjs/prism.js"(e,t){var n=function(){var e=/(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i,t=0,n={},o={util:{encode:function e(t){return t instanceof i?new i(t.type,e(t.content),t.alias):Array.isArray(t)?t.map(e):t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function e(t,n){var i,s;switch(n=n||{},o.util.type(t)){case"Object":if(s=o.util.objId(t),n[s])return n[s];for(var a in i={},n[s]=i,t)t.hasOwnProperty(a)&&(i[a]=e(t[a],n));return i;case"Array":return s=o.util.objId(t),n[s]?n[s]:(i=[],n[s]=i,t.forEach((function(t,o){i[o]=e(t,n)})),i);default:return t}},getLanguage:function(t){for(;t;){var n=e.exec(t.className);if(n)return n[1].toLowerCase();t=t.parentElement}return"none"},setLanguage:function(t,n){t.className=t.className.replace(RegExp(e,"gi"),""),t.classList.add("language-"+n)},isActive:function(e,t,n){for(var o="no-"+t;e;){var i=e.classList;if(i.contains(t))return!0;if(i.contains(o))return!1;e=e.parentElement}return!!n}},languages:{plain:n,plaintext:n,text:n,txt:n,extend:function(e,t){var n=o.util.clone(o.languages[e]);for(var i in t)n[i]=t[i];return n},insertBefore:function(e,t,n,i){var s=(i=i||o.languages)[e],a={};for(var r in s)if(s.hasOwnProperty(r)){if(r==t)for(var p in n)n.hasOwnProperty(p)&&(a[p]=n[p]);n.hasOwnProperty(r)||(a[r]=s[r])}var c=i[e];return i[e]=a,o.languages.DFS(o.languages,(function(t,n){n===c&&t!=e&&(this[t]=a)})),a},DFS:function e(t,n,i,s){s=s||{};var a=o.util.objId;for(var r in t)if(t.hasOwnProperty(r)){n.call(t,r,t[r],i||r);var p=t[r],c=o.util.type(p);"Object"!==c||s[a(p)]?"Array"!==c||s[a(p)]||(s[a(p)]=!0,e(p,n,r,s)):(s[a(p)]=!0,e(p,n,null,s))}}},plugins:{},highlight:function(e,t,n){var s={code:e,grammar:t,language:n};if(o.hooks.run("before-tokenize",s),!s.grammar)throw new Error('The language "'+s.language+'" has no grammar.');return s.tokens=o.tokenize(s.code,s.grammar),o.hooks.run("after-tokenize",s),i.stringify(o.util.encode(s.tokens),s.language)},tokenize:function(e,t){var n=t.rest;if(n){for(var o in n)t[o]=n[o];delete t.rest}var i=new r;return p(i,i.head,e),a(e,i,t,i.head,0),function(e){for(var t=[],n=e.head.next;n!==e.tail;)t.push(n.value),n=n.next;return t}(i)},hooks:{all:{},add:function(e,t){var n=o.hooks.all;n[e]=n[e]||[],n[e].push(t)},run:function(e,t){var n=o.hooks.all[e];if(n&&n.length)for(var i,s=0;i=n[s++];)i(t)}},Token:i};function i(e,t,n,o){this.type=e,this.content=t,this.alias=n,this.length=0|(o||"").length}function s(e,t,n,o){e.lastIndex=t;var i=e.exec(n);if(i&&o&&i[1]){var s=i[1].length;i.index+=s,i[0]=i[0].slice(s)}return i}function a(e,t,n,r,d,l){for(var u in n)if(n.hasOwnProperty(u)&&n[u]){var h=n[u];h=Array.isArray(h)?h:[h];for(var f=0;f<h.length;++f){if(l&&l.cause==u+","+f)return;var y=h[f],m=y.inside,g=!!y.lookbehind,_=!!y.greedy,b=y.alias;if(_&&!y.pattern.global){var T=y.pattern.toString().match(/[imsuy]*$/)[0];y.pattern=RegExp(y.pattern.source,T+"g")}for(var v=y.pattern||y,P=r.next,E=d;P!==t.tail&&!(l&&E>=l.reach);E+=P.value.length,P=P.next){var R=P.value;if(t.length>e.length)return;if(!(R instanceof i)){var A,k=1;if(_){if(!(A=s(v,E,e,g))||A.index>=e.length)break;var w=A.index,S=A.index+A[0].length,I=E;for(I+=P.value.length;w>=I;)I+=(P=P.next).value.length;if(E=I-=P.value.length,P.value instanceof i)continue;for(var O=P;O!==t.tail&&(I<S||"string"==typeof O.value);O=O.next)k++,I+=O.value.length;k--,R=e.slice(E,I),A.index-=E}else if(!(A=s(v,0,R,g)))continue;w=A.index;var x=A[0],N=R.slice(0,w),U=R.slice(w+x.length),Y=E+R.length;l&&Y>l.reach&&(l.reach=Y);var C=P.prev;if(N&&(C=p(t,C,N),E+=N.length),c(t,C,k),P=p(t,C,new i(u,m?o.tokenize(x,m):x,b,x)),U&&p(t,P,U),k>1){var L={cause:u+","+f,reach:Y};a(e,t,n,P.prev,E,L),l&&L.reach>l.reach&&(l.reach=L.reach)}}}}}}function r(){var e={value:null,prev:null,next:null},t={value:null,prev:e,next:null};e.next=t,this.head=e,this.tail=t,this.length=0}function p(e,t,n){var o=t.next,i={value:n,prev:t,next:o};return t.next=i,o.prev=i,e.length++,i}function c(e,t,n){for(var o=t.next,i=0;i<n&&o!==e.tail;i++)o=o.next;t.next=o,o.prev=t,e.length-=i}return i.stringify=function e(t,n){if("string"==typeof t)return t;if(Array.isArray(t)){var i="";return t.forEach((function(t){i+=e(t,n)})),i}var s={type:t.type,content:e(t.content,n),tag:"span",classes:["token",t.type],attributes:{},language:n},a=t.alias;a&&(Array.isArray(a)?Array.prototype.push.apply(s.classes,a):s.classes.push(a)),o.hooks.run("wrap",s);var r="";for(var p in s.attributes)r+=" "+p+'="'+(s.attributes[p]||"").replace(/"/g,"&quot;")+'"';return"<"+s.tag+' class="'+s.classes.join(" ")+'"'+r+">"+s.content+"</"+s.tag+">"},o}();t.exports=n,n.default=n}},function(){return i||(0,o[g(o)[0]])((i={exports:{}}).exports,i),i.exports}),w=((e,t,n)=>(n=null!=e?u(b(e)):{},((e,t,n,o)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let i of g(t))T.call(e,i)||i===n||h(e,i,{get:()=>t[i],enumerable:!(o=y(t,i))||o.enumerable});return e})(!t&&e&&e.__esModule?n:h(n,"default",{value:e,enumerable:!0}),e)))(k());w.languages.markup={comment:{pattern:/<!--(?:(?!<!--)[\s\S])*?-->/,greedy:!0},prolog:{pattern:/<\?[\s\S]+?\?>/,greedy:!0},doctype:{pattern:/<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,greedy:!0,inside:{"internal-subset":{pattern:/(^[^\[]*\[)[\s\S]+(?=\]>$)/,lookbehind:!0,greedy:!0,inside:null},string:{pattern:/"[^"]*"|'[^']*'/,greedy:!0},punctuation:/^<!|>$|[[\]]/,"doctype-tag":/^DOCTYPE/i,name:/[^\s<>'"]+/}},cdata:{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,greedy:!0},tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"special-attr":[],"attr-value":{pattern:/=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,inside:{punctuation:[{pattern:/^=/,alias:"attr-equals"},{pattern:/^(\s*)["']|["']$/,lookbehind:!0}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:[{pattern:/&[\da-z]{1,8};/i,alias:"named-entity"},/&#x?[\da-f]{1,8};/i]},w.languages.markup.tag.inside["attr-value"].inside.entity=w.languages.markup.entity,w.languages.markup.doctype.inside["internal-subset"].inside=w.languages.markup,w.hooks.add("wrap",(function(e){"entity"===e.type&&(e.attributes.title=e.content.replace(/&amp;/,"&"))})),Object.defineProperty(w.languages.markup.tag,"addInlined",{value:function(e,t){var n;(t=((n=((n={})["language-"+t]={pattern:/(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,lookbehind:!0,inside:w.languages[t]},n.cdata=/^<!\[CDATA\[|\]\]>$/i,{"included-cdata":{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,inside:n}}))["language-"+t]={pattern:/[\s\S]+/,inside:w.languages[t]},{}))[e]={pattern:RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g,(function(){return e})),"i"),lookbehind:!0,greedy:!0,inside:n},w.languages.insertBefore("markup","cdata",t)}}),Object.defineProperty(w.languages.markup.tag,"addAttribute",{value:function(e,t){w.languages.markup.tag.inside["special-attr"].push({pattern:RegExp(/(^|["'\s])/.source+"(?:"+e+")"+/\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,"i"),lookbehind:!0,inside:{"attr-name":/^[^\s=]+/,"attr-value":{pattern:/=[\s\S]+/,inside:{value:{pattern:/(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,lookbehind:!0,alias:[t,"language-"+t],inside:w.languages[t]},punctuation:[{pattern:/^=/,alias:"attr-equals"},/"|'/]}}}})}}),w.languages.html=w.languages.markup,w.languages.mathml=w.languages.markup,w.languages.svg=w.languages.markup,w.languages.xml=w.languages.extend("markup",{}),w.languages.ssml=w.languages.xml,w.languages.atom=w.languages.xml,w.languages.rss=w.languages.xml,s=w,a={pattern:/\\[\\(){}[\]^$+*?|.]/,alias:"escape"},p="(?:[^\\\\-]|"+(r=/\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/).source+")",p=RegExp(p+"-"+p),c={pattern:/(<|')[^<>']+(?=[>']$)/,lookbehind:!0,alias:"variable"},s.languages.regex={"char-class":{pattern:/((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,lookbehind:!0,inside:{"char-class-negation":{pattern:/(^\[)\^/,lookbehind:!0,alias:"operator"},"char-class-punctuation":{pattern:/^\[|\]$/,alias:"punctuation"},range:{pattern:p,inside:{escape:r,"range-punctuation":{pattern:/-/,alias:"operator"}}},"special-escape":a,"char-set":{pattern:/\\[wsd]|\\p\{[^{}]+\}/i,alias:"class-name"},escape:r}},"special-escape":a,"char-set":{pattern:/\.|\\[wsd]|\\p\{[^{}]+\}/i,alias:"class-name"},backreference:[{pattern:/\\(?![123][0-7]{2})[1-9]/,alias:"keyword"},{pattern:/\\k<[^<>']+>/,alias:"keyword",inside:{"group-name":c}}],anchor:{pattern:/[$^]|\\[ABbGZz]/,alias:"function"},escape:r,group:[{pattern:/\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,alias:"punctuation",inside:{"group-name":c}},{pattern:/\)/,alias:"punctuation"}],quantifier:{pattern:/(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,alias:"number"},alternation:{pattern:/\|/,alias:"keyword"}},w.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0,greedy:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,boolean:/\b(?:false|true)\b/,function:/\b\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,punctuation:/[{}[\];(),.:]/},w.languages.javascript=w.languages.extend("clike",{"class-name":[w.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,lookbehind:!0}],keyword:[{pattern:/((?:^|\})\s*)catch\b/,lookbehind:!0},{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],function:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,number:{pattern:RegExp(/(^|[^\w$])/.source+"(?:"+/NaN|Infinity/.source+"|"+/0[bB][01]+(?:_[01]+)*n?/.source+"|"+/0[oO][0-7]+(?:_[0-7]+)*n?/.source+"|"+/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source+"|"+/\d+(?:_\d+)*n/.source+"|"+/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source+")"+/(?![\w$])/.source),lookbehind:!0},operator:/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/}),w.languages.javascript["class-name"][0].pattern=/(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/,w.languages.insertBefore("javascript","keyword",{regex:{pattern:RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source+/\//.source+"(?:"+/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source+"|"+/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source+")"+/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),lookbehind:!0,greedy:!0,inside:{"regex-source":{pattern:/^(\/)[\s\S]+(?=\/[a-z]*$)/,lookbehind:!0,alias:"language-regex",inside:w.languages.regex},"regex-delimiter":/^\/|\/$/,"regex-flags":/^[a-z]+$/}},"function-variable":{pattern:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,alias:"function"},parameter:[{pattern:/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,lookbehind:!0,inside:w.languages.javascript},{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,lookbehind:!0,inside:w.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,lookbehind:!0,inside:w.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,lookbehind:!0,inside:w.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/}),w.languages.insertBefore("javascript","string",{hashbang:{pattern:/^#!.*/,greedy:!0,alias:"comment"},"template-string":{pattern:/`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,greedy:!0,inside:{"template-punctuation":{pattern:/^`|`$/,alias:"string"},interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,lookbehind:!0,inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/,alias:"punctuation"},rest:w.languages.javascript}},string:/[\s\S]+/}},"string-property":{pattern:/((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,lookbehind:!0,greedy:!0,alias:"property"}}),w.languages.insertBefore("javascript","operator",{"literal-property":{pattern:/((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,lookbehind:!0,alias:"property"}}),w.languages.markup&&(w.languages.markup.tag.addInlined("script","javascript"),w.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,"javascript")),w.languages.js=w.languages.javascript,w.languages.actionscript=w.languages.extend("javascript",{keyword:/\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/,operator:/\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/}),w.languages.actionscript["class-name"].alias="function",delete w.languages.actionscript.parameter,delete w.languages.actionscript["literal-property"],w.languages.markup&&w.languages.insertBefore("actionscript","string",{xml:{pattern:/(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,lookbehind:!0,inside:w.languages.markup}}),function(e){var t=/#(?!\{).+/,n={pattern:/#\{[^}]+\}/,alias:"variable"};e.languages.coffeescript=e.languages.extend("javascript",{comment:t,string:[{pattern:/'(?:\\[\s\S]|[^\\'])*'/,greedy:!0},{pattern:/"(?:\\[\s\S]|[^\\"])*"/,greedy:!0,inside:{interpolation:n}}],keyword:/\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,"class-member":{pattern:/@(?!\d)\w+/,alias:"variable"}}),e.languages.insertBefore("coffeescript","comment",{"multiline-comment":{pattern:/###[\s\S]+?###/,alias:"comment"},"block-regex":{pattern:/\/{3}[\s\S]*?\/{3}/,alias:"regex",inside:{comment:t,interpolation:n}}}),e.languages.insertBefore("coffeescript","string",{"inline-javascript":{pattern:/`(?:\\[\s\S]|[^\\`])*`/,inside:{delimiter:{pattern:/^`|`$/,alias:"punctuation"},script:{pattern:/[\s\S]+/,alias:"language-javascript",inside:e.languages.javascript}}},"multiline-string":[{pattern:/'''[\s\S]*?'''/,greedy:!0,alias:"string"},{pattern:/"""[\s\S]*?"""/,greedy:!0,alias:"string",inside:{interpolation:n}}]}),e.languages.insertBefore("coffeescript","keyword",{property:/(?!\d)\w+(?=\s*:(?!:))/}),delete e.languages.coffeescript["template-string"],e.languages.coffee=e.languages.coffeescript}(w),function(e){var t=e.languages.javadoclike={parameter:{pattern:/(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m,lookbehind:!0},keyword:{pattern:/(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m,lookbehind:!0},punctuation:/[{}]/};Object.defineProperty(t,"addSupport",{value:function(t,n){(t="string"==typeof t?[t]:t).forEach((function(t){var o=function(e){e.inside||(e.inside={}),e.inside.rest=n},i="doc-comment";if(s=e.languages[t]){var s,a=s[i];if((a=a||(s=e.languages.insertBefore(t,"comment",{"doc-comment":{pattern:/(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,lookbehind:!0,alias:"comment"}}))[i])instanceof RegExp&&(a=s[i]={pattern:a}),Array.isArray(a))for(var r=0,p=a.length;r<p;r++)a[r]instanceof RegExp&&(a[r]={pattern:a[r]}),o(a[r]);else o(a)}}))}}),t.addSupport(["java","javascript","php"],t)}(w),function(e){var t=/(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;(t=(e.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:RegExp("@[\\w-](?:"+/[^;{\s"']|\s+(?!\s)/.source+"|"+t.source+")*?"+/(?:;|(?=\s*\{))/.source),inside:{rule:/^@[\w-]+/,"selector-function-argument":{pattern:/(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,lookbehind:!0,alias:"selector"},keyword:{pattern:/(^|[^\w-])(?:and|not|only|or)(?![\w-])/,lookbehind:!0}}},url:{pattern:RegExp("\\burl\\((?:"+t.source+"|"+/(?:[^\\\r\n()"']|\\[\s\S])*/.source+")\\)","i"),greedy:!0,inside:{function:/^url/i,punctuation:/^\(|\)$/,string:{pattern:RegExp("^"+t.source+"$"),alias:"url"}}},selector:{pattern:RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|"+t.source+")*(?=\\s*\\{)"),lookbehind:!0},string:{pattern:t,greedy:!0},property:{pattern:/(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,lookbehind:!0},important:/!important\b/i,function:{pattern:/(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,lookbehind:!0},punctuation:/[(){};:,]/},e.languages.css.atrule.inside.rest=e.languages.css,e.languages.markup))&&(t.tag.addInlined("style","css"),t.tag.addAttribute("style","css"))}(w),function(e){var t=/("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,n=(t=(e.languages.css.selector={pattern:e.languages.css.selector.pattern,lookbehind:!0,inside:t={"pseudo-element":/:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,"pseudo-class":/:[-\w]+/,class:/\.[-\w]+/,id:/#[-\w]+/,attribute:{pattern:RegExp("\\[(?:[^[\\]\"']|"+t.source+")*\\]"),greedy:!0,inside:{punctuation:/^\[|\]$/,"case-sensitivity":{pattern:/(\s)[si]$/i,lookbehind:!0,alias:"keyword"},namespace:{pattern:/^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,lookbehind:!0,inside:{punctuation:/\|$/}},"attr-name":{pattern:/^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,lookbehind:!0},"attr-value":[t,{pattern:/(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,lookbehind:!0}],operator:/[|~*^$]?=/}},"n-th":[{pattern:/(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,lookbehind:!0,inside:{number:/[\dn]+/,operator:/[+-]/}},{pattern:/(\(\s*)(?:even|odd)(?=\s*\))/i,lookbehind:!0}],combinator:/>|\+|~|\|\|/,punctuation:/[(),]/}},e.languages.css.atrule.inside["selector-function-argument"].inside=t,e.languages.insertBefore("css","property",{variable:{pattern:/(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,lookbehind:!0}}),{pattern:/(\b\d+)(?:%|[a-z]+(?![\w-]))/,lookbehind:!0}),{pattern:/(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,lookbehind:!0});e.languages.insertBefore("css","function",{operator:{pattern:/(\s)[+\-*\/](?=\s)/,lookbehind:!0},hexcode:{pattern:/\B#[\da-f]{3,8}\b/i,alias:"color"},color:[{pattern:/(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,lookbehind:!0},{pattern:/\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,inside:{unit:t,number:n,function:/[\w-]+(?=\()/,punctuation:/[(),]/}}],entity:/\\[\da-f]{1,8}/i,unit:t,number:n})}(w),function(e){var t=/[*&][^\s[\]{},]+/,n=/!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/,o="(?:"+n.source+"(?:[ \t]+"+t.source+")?|"+t.source+"(?:[ \t]+"+n.source+")?)",i=/(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g,(function(){return/[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source})),s=/"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;function a(e,t){t=(t||"").replace(/m/g,"")+"m";var n=/([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g,(function(){return o})).replace(/<<value>>/g,(function(){return e}));return RegExp(n,t)}e.languages.yaml={scalar:{pattern:RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g,(function(){return o}))),lookbehind:!0,alias:"string"},comment:/#.*/,key:{pattern:RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g,(function(){return o})).replace(/<<key>>/g,(function(){return"(?:"+i+"|"+s+")"}))),lookbehind:!0,greedy:!0,alias:"atrule"},directive:{pattern:/(^[ \t]*)%.+/m,lookbehind:!0,alias:"important"},datetime:{pattern:a(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),lookbehind:!0,alias:"number"},boolean:{pattern:a(/false|true/.source,"i"),lookbehind:!0,alias:"important"},null:{pattern:a(/null|~/.source,"i"),lookbehind:!0,alias:"important"},string:{pattern:a(s),lookbehind:!0,greedy:!0},number:{pattern:a(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source,"i"),lookbehind:!0},tag:n,important:t,punctuation:/---|[:[\]{}\-,|>?]|\.\.\./},e.languages.yml=e.languages.yaml}(w),function(e){var t=/(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;function n(e){return e=e.replace(/<inner>/g,(function(){return t})),RegExp(/((?:^|[^\\])(?:\\{2})*)/.source+"(?:"+e+")")}var o=/(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source,i=/\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g,(function(){return o})),s=/\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source,a=(e.languages.markdown=e.languages.extend("markup",{}),e.languages.insertBefore("markdown","prolog",{"front-matter-block":{pattern:/(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,lookbehind:!0,greedy:!0,inside:{punctuation:/^---|---$/,"front-matter":{pattern:/\S+(?:\s+\S+)*/,alias:["yaml","language-yaml"],inside:e.languages.yaml}}},blockquote:{pattern:/^>(?:[\t ]*>)*/m,alias:"punctuation"},table:{pattern:RegExp("^"+i+s+"(?:"+i+")*","m"),inside:{"table-data-rows":{pattern:RegExp("^("+i+s+")(?:"+i+")*$"),lookbehind:!0,inside:{"table-data":{pattern:RegExp(o),inside:e.languages.markdown},punctuation:/\|/}},"table-line":{pattern:RegExp("^("+i+")"+s+"$"),lookbehind:!0,inside:{punctuation:/\||:?-{3,}:?/}},"table-header-row":{pattern:RegExp("^"+i+"$"),inside:{"table-header":{pattern:RegExp(o),alias:"important",inside:e.languages.markdown},punctuation:/\|/}}}},code:[{pattern:/((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,lookbehind:!0,alias:"keyword"},{pattern:/^```[\s\S]*?^```$/m,greedy:!0,inside:{"code-block":{pattern:/^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,lookbehind:!0},"code-language":{pattern:/^(```).+/,lookbehind:!0},punctuation:/```/}}],title:[{pattern:/\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,alias:"important",inside:{punctuation:/==+$|--+$/}},{pattern:/(^\s*)#.+/m,lookbehind:!0,alias:"important",inside:{punctuation:/^#+|#+$/}}],hr:{pattern:/(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,lookbehind:!0,alias:"punctuation"},list:{pattern:/(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,lookbehind:!0,alias:"punctuation"},"url-reference":{pattern:/!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,inside:{variable:{pattern:/^(!?\[)[^\]]+/,lookbehind:!0},string:/(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,punctuation:/^[\[\]!:]|[<>]/},alias:"url"},bold:{pattern:n(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),lookbehind:!0,greedy:!0,inside:{content:{pattern:/(^..)[\s\S]+(?=..$)/,lookbehind:!0,inside:{}},punctuation:/\*\*|__/}},italic:{pattern:n(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),lookbehind:!0,greedy:!0,inside:{content:{pattern:/(^.)[\s\S]+(?=.$)/,lookbehind:!0,inside:{}},punctuation:/[*_]/}},strike:{pattern:n(/(~~?)(?:(?!~)<inner>)+\2/.source),lookbehind:!0,greedy:!0,inside:{content:{pattern:/(^~~?)[\s\S]+(?=\1$)/,lookbehind:!0,inside:{}},punctuation:/~~?/}},"code-snippet":{pattern:/(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,lookbehind:!0,greedy:!0,alias:["code","keyword"]},url:{pattern:n(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),lookbehind:!0,greedy:!0,inside:{operator:/^!/,content:{pattern:/(^\[)[^\]]+(?=\])/,lookbehind:!0,inside:{}},variable:{pattern:/(^\][ \t]?\[)[^\]]+(?=\]$)/,lookbehind:!0},url:{pattern:/(^\]\()[^\s)]+/,lookbehind:!0},string:{pattern:/(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,lookbehind:!0}}}}),["url","bold","italic","strike"].forEach((function(t){["url","bold","italic","strike","code-snippet"].forEach((function(n){t!==n&&(e.languages.markdown[t].inside.content.inside[n]=e.languages.markdown[n])}))})),e.hooks.add("after-tokenize",(function(e){"markdown"!==e.language&&"md"!==e.language||function e(t){if(t&&"string"!=typeof t)for(var n=0,o=t.length;n<o;n++){var i,s=t[n];"code"!==s.type?e(s.content):(i=s.content[1],s=s.content[3],i&&s&&"code-language"===i.type&&"code-block"===s.type&&"string"==typeof i.content&&(i=i.content.replace(/\b#/g,"sharp").replace(/\b\+\+/g,"pp"),i="language-"+(i=(/[a-z][\w-]*/i.exec(i)||[""])[0].toLowerCase()),s.alias?"string"==typeof s.alias?s.alias=[s.alias,i]:s.alias.push(i):s.alias=[i]))}}(e.tokens)})),e.hooks.add("wrap",(function(t){if("code-block"===t.type){for(var n="",o=0,i=t.classes.length;o<i;o++){var s=t.classes[o];if(s=/language-(.+)/.exec(s)){n=s[1];break}}var c,d=e.languages[n];d?t.content=e.highlight(t.content.replace(a,"").replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi,(function(e,t){var n;return"#"===(t=t.toLowerCase())[0]?(n="x"===t[1]?parseInt(t.slice(2),16):Number(t.slice(1)),p(n)):r[t]||e})),d,n):n&&"none"!==n&&e.plugins.autoloader&&(c="md-"+(new Date).valueOf()+"-"+Math.floor(1e16*Math.random()),t.attributes.id=c,e.plugins.autoloader.loadLanguages(n,(function(){var t=document.getElementById(c);t&&(t.innerHTML=e.highlight(t.textContent,e.languages[n],n))})))}})),RegExp(e.languages.markup.tag.pattern.source,"gi")),r={amp:"&",lt:"<",gt:">",quot:'"'},p=String.fromCodePoint||String.fromCharCode;e.languages.md=e.languages.markdown}(w),w.languages.graphql={comment:/#.*/,description:{pattern:/(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,greedy:!0,alias:"string",inside:{"language-markdown":{pattern:/(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,lookbehind:!0,inside:w.languages.markdown}}},string:{pattern:/"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,greedy:!0},number:/(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,boolean:/\b(?:false|true)\b/,variable:/\$[a-z_]\w*/i,directive:{pattern:/@[a-z_]\w*/i,alias:"function"},"attr-name":{pattern:/\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,greedy:!0},"atom-input":{pattern:/\b[A-Z]\w*Input\b/,alias:"class-name"},scalar:/\b(?:Boolean|Float|ID|Int|String)\b/,constant:/\b[A-Z][A-Z_\d]*\b/,"class-name":{pattern:/(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,lookbehind:!0},fragment:{pattern:/(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,lookbehind:!0,alias:"function"},"definition-mutation":{pattern:/(\bmutation\s+)[a-zA-Z_]\w*/,lookbehind:!0,alias:"function"},"definition-query":{pattern:/(\bquery\s+)[a-zA-Z_]\w*/,lookbehind:!0,alias:"function"},keyword:/\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,operator:/[!=|&]|\.{3}/,"property-query":/\w+(?=\s*\()/,object:/\w+(?=\s*\{)/,punctuation:/[!(){}\[\]:=,]/,property:/\w+/},w.hooks.add("after-tokenize",(function(e){if("graphql"===e.language)for(var t=e.tokens.filter((function(e){return"string"!=typeof e&&"comment"!==e.type&&"scalar"!==e.type})),n=0;n<t.length;){var o=t[n++];if("keyword"===o.type&&"mutation"===o.content){var i=[];if(l(["definition-mutation","punctuation"])&&"("===d(1).content){n+=2;var s=u(/^\($/,/^\)$/);if(-1===s)continue;for(;n<s;n++){var a=d(0);"variable"===a.type&&(h(a,"variable-input"),i.push(a.content))}n=s+1}if(l(["punctuation","property-query"])&&"{"===d(0).content&&(n++,h(d(0),"property-mutation"),0<i.length)){var r=u(/^\{$/,/^\}$/);if(-1!==r)for(var p=n;p<r;p++){var c=t[p];"variable"===c.type&&0<=i.indexOf(c.content)&&h(c,"variable-input")}}}}function d(e){return t[n+e]}function l(e,t){t=t||0;for(var n=0;n<e.length;n++){var o=d(n+t);if(!o||o.type!==e[n])return}return 1}function u(e,o){for(var i=1,s=n;s<t.length;s++){var a=t[s],r=a.content;if("punctuation"===a.type&&"string"==typeof r)if(e.test(r))i++;else if(o.test(r)&&0==--i)return s}return-1}function h(e,t){var n=e.alias;n?Array.isArray(n)||(e.alias=n=[n]):e.alias=n=[],n.push(t)}})),w.languages.sql={comment:{pattern:/(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,lookbehind:!0},variable:[{pattern:/@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,greedy:!0},/@[\w.$]+/],string:{pattern:/(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,greedy:!0,lookbehind:!0},identifier:{pattern:/(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,greedy:!0,lookbehind:!0,inside:{punctuation:/^`|`$/}},function:/\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,keyword:/\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,boolean:/\b(?:FALSE|NULL|TRUE)\b/i,number:/\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,operator:/[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,punctuation:/[;[\]()`,.]/},function(e){var t=e.languages.javascript["template-string"],n=t.pattern.source,o=t.inside.interpolation,i=o.inside["interpolation-punctuation"],s=o.pattern.source;function a(t,o){if(e.languages[t])return{pattern:RegExp("((?:"+o+")\\s*)"+n),lookbehind:!0,greedy:!0,inside:{"template-punctuation":{pattern:/^`|`$/,alias:"string"},"embedded-code":{pattern:/[\s\S]+/,alias:t}}}}function r(t,n,o){return t={code:t,grammar:n,language:o},e.hooks.run("before-tokenize",t),t.tokens=e.tokenize(t.code,t.grammar),e.hooks.run("after-tokenize",t),t.tokens}function p(t,n,a){var p=e.tokenize(t,{interpolation:{pattern:RegExp(s),lookbehind:!0}}),c=0,d={},l=(p=r(p.map((function(e){if("string"==typeof e)return e;var n,o;for(e=e.content;-1!==t.indexOf((o=c++,n="___"+a.toUpperCase()+"_"+o+"___")););return d[n]=e,n})).join(""),n,a),Object.keys(d));return c=0,function t(n){for(var s=0;s<n.length;s++){if(c>=l.length)return;var a,p,u,h,f,y,m,g=n[s];"string"==typeof g||"string"==typeof g.content?(a=l[c],-1!==(m=(y="string"==typeof g?g:g.content).indexOf(a))&&(++c,p=y.substring(0,m),f=d[a],u=void 0,(h={})["interpolation-punctuation"]=i,3===(h=e.tokenize(f,h)).length&&((u=[1,1]).push.apply(u,r(h[1],e.languages.javascript,"javascript")),h.splice.apply(h,u)),u=new e.Token("interpolation",h,o.alias,f),h=y.substring(m+a.length),f=[],p&&f.push(p),f.push(u),h&&(t(y=[h]),f.push.apply(f,y)),"string"==typeof g?(n.splice.apply(n,[s,1].concat(f)),s+=f.length-1):g.content=f)):(m=g.content,Array.isArray(m)?t(m):t([m]))}}(p),new e.Token(a,p,"language-"+a,t)}e.languages.javascript["template-string"]=[a("css",/\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),a("html",/\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),a("svg",/\bsvg/.source),a("markdown",/\b(?:markdown|md)/.source),a("graphql",/\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source),a("sql",/\bsql/.source),t].filter(Boolean);var c={javascript:!0,js:!0,typescript:!0,ts:!0,jsx:!0,tsx:!0};function d(e){return"string"==typeof e?e:Array.isArray(e)?e.map(d).join(""):d(e.content)}e.hooks.add("after-tokenize",(function(t){t.language in c&&function t(n){for(var o=0,i=n.length;o<i;o++){var s,a,r,c=n[o];"string"!=typeof c&&(s=c.content,Array.isArray(s)?"template-string"===c.type?(c=s[1],3===s.length&&"string"!=typeof c&&"embedded-code"===c.type&&(a=d(c),c=c.alias,c=Array.isArray(c)?c[0]:c,r=e.languages[c])&&(s[1]=p(a,r,c))):t(s):"string"!=typeof s&&t([s]))}}(t.tokens)}))}(w),function(e){e.languages.typescript=e.languages.extend("javascript",{"class-name":{pattern:/(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,lookbehind:!0,greedy:!0,inside:null},builtin:/\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/}),e.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/,/\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,/\btype\b(?=\s*(?:[\{*]|$))/),delete e.languages.typescript.parameter,delete e.languages.typescript["literal-property"];var t=e.languages.extend("typescript",{});delete t["class-name"],e.languages.typescript["class-name"].inside=t,e.languages.insertBefore("typescript","function",{decorator:{pattern:/@[$\w\xA0-\uFFFF]+/,inside:{at:{pattern:/^@/,alias:"operator"},function:/^[\s\S]+/}},"generic-function":{pattern:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,greedy:!0,inside:{function:/^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,generic:{pattern:/<[\s\S]+/,alias:"class-name",inside:t}}}}),e.languages.ts=e.languages.typescript}(w),function(e){var t=e.languages.javascript,n=/\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source,o="(@(?:arg|argument|param|property)\\s+(?:"+n+"\\s+)?)";e.languages.jsdoc=e.languages.extend("javadoclike",{parameter:{pattern:RegExp(o+/(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source),lookbehind:!0,inside:{punctuation:/\./}}}),e.languages.insertBefore("jsdoc","keyword",{"optional-parameter":{pattern:RegExp(o+/\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source),lookbehind:!0,inside:{parameter:{pattern:/(^\[)[$\w\xA0-\uFFFF\.]+/,lookbehind:!0,inside:{punctuation:/\./}},code:{pattern:/(=)[\s\S]*(?=\]$)/,lookbehind:!0,inside:t,alias:"language-javascript"},punctuation:/[=[\]]/}},"class-name":[{pattern:RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g,(function(){return n}))),lookbehind:!0,inside:{punctuation:/\./}},{pattern:RegExp("(@[a-z]+\\s+)"+n),lookbehind:!0,inside:{string:t.string,number:t.number,boolean:t.boolean,keyword:e.languages.typescript.keyword,operator:/=>|\.\.\.|[&|?:*]/,punctuation:/[.,;=<>{}()[\]]/}}],example:{pattern:/(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/,lookbehind:!0,inside:{code:{pattern:/^([\t ]*(?:\*\s*)?)\S.*$/m,lookbehind:!0,inside:t,alias:"language-javascript"}}}}),e.languages.javadoclike.addSupport("javascript",e.languages.jsdoc)}(w),function(e){e.languages.flow=e.languages.extend("javascript",{}),e.languages.insertBefore("flow","keyword",{type:[{pattern:/\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|[Ss]ymbol|any|mixed|null|void)\b/,alias:"class-name"}]}),e.languages.flow["function-variable"].pattern=/(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i,delete e.languages.flow.parameter,e.languages.insertBefore("flow","operator",{"flow-punctuation":{pattern:/\{\||\|\}/,alias:"punctuation"}}),Array.isArray(e.languages.flow.keyword)||(e.languages.flow.keyword=[e.languages.flow.keyword]),e.languages.flow.keyword.unshift({pattern:/(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/,lookbehind:!0},{pattern:/(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/,lookbehind:!0})}(w),w.languages.n4js=w.languages.extend("javascript",{keyword:/\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/}),w.languages.insertBefore("n4js","constant",{annotation:{pattern:/@+\w+/,alias:"operator"}}),w.languages.n4jsd=w.languages.n4js,function(e){function t(e,t){return RegExp(e.replace(/<ID>/g,(function(){return/(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source})),t)}e.languages.insertBefore("javascript","function-variable",{"method-variable":{pattern:RegExp("(\\.\\s*)"+e.languages.javascript["function-variable"].pattern.source),lookbehind:!0,alias:["function-variable","method","function","property-access"]}}),e.languages.insertBefore("javascript","function",{method:{pattern:RegExp("(\\.\\s*)"+e.languages.javascript.function.source),lookbehind:!0,alias:["function","property-access"]}}),e.languages.insertBefore("javascript","constant",{"known-class-name":[{pattern:/\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,alias:"class-name"},{pattern:/\b(?:[A-Z]\w*)Error\b/,alias:"class-name"}]}),e.languages.insertBefore("javascript","keyword",{imports:{pattern:t(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source),lookbehind:!0,inside:e.languages.javascript},exports:{pattern:t(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source),lookbehind:!0,inside:e.languages.javascript}}),e.languages.javascript.keyword.unshift({pattern:/\b(?:as|default|export|from|import)\b/,alias:"module"},{pattern:/\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,alias:"control-flow"},{pattern:/\bnull\b/,alias:["null","nil"]},{pattern:/\bundefined\b/,alias:"nil"}),e.languages.insertBefore("javascript","operator",{spread:{pattern:/\.{3}/,alias:"operator"},arrow:{pattern:/=>/,alias:"operator"}}),e.languages.insertBefore("javascript","punctuation",{"property-access":{pattern:t(/(\.\s*)#?<ID>/.source),lookbehind:!0},"maybe-class-name":{pattern:/(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,lookbehind:!0},dom:{pattern:/\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,alias:"variable"},console:{pattern:/\bconsole(?=\s*\.)/,alias:"class-name"}});for(var n=["function","function-variable","method","method-variable","property-access"],o=0;o<n.length;o++){var i=n[o],s=e.languages.javascript[i];i=(s="RegExp"===e.util.type(s)?e.languages.javascript[i]={pattern:s}:s).inside||{};(s.inside=i)["maybe-class-name"]=/^[A-Z][\s\S]*/}}(w),function(e){var t=e.util.clone(e.languages.javascript),n=/(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source,o=/(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source,i=/(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;function s(e,t){return e=e.replace(/<S>/g,(function(){return n})).replace(/<BRACES>/g,(function(){return o})).replace(/<SPREAD>/g,(function(){return i})),RegExp(e,t)}function a(t){for(var n=[],o=0;o<t.length;o++){var i=t[o],s=!1;"string"!=typeof i&&("tag"===i.type&&i.content[0]&&"tag"===i.content[0].type?"</"===i.content[0].content[0].content?0<n.length&&n[n.length-1].tagName===r(i.content[0].content[1])&&n.pop():"/>"!==i.content[i.content.length-1].content&&n.push({tagName:r(i.content[0].content[1]),openedBraces:0}):0<n.length&&"punctuation"===i.type&&"{"===i.content?n[n.length-1].openedBraces++:0<n.length&&0<n[n.length-1].openedBraces&&"punctuation"===i.type&&"}"===i.content?n[n.length-1].openedBraces--:s=!0),(s||"string"==typeof i)&&0<n.length&&0===n[n.length-1].openedBraces&&(s=r(i),o<t.length-1&&("string"==typeof t[o+1]||"plain-text"===t[o+1].type)&&(s+=r(t[o+1]),t.splice(o+1,1)),0<o&&("string"==typeof t[o-1]||"plain-text"===t[o-1].type)&&(s=r(t[o-1])+s,t.splice(o-1,1),o--),t[o]=new e.Token("plain-text",s,null,s)),i.content&&"string"!=typeof i.content&&a(i.content)}}i=s(i).source,e.languages.jsx=e.languages.extend("markup",t),e.languages.jsx.tag.pattern=s(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source),e.languages.jsx.tag.inside.tag.pattern=/^<\/?[^\s>\/]*/,e.languages.jsx.tag.inside["attr-value"].pattern=/=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/,e.languages.jsx.tag.inside.tag.inside["class-name"]=/^[A-Z]\w*(?:\.[A-Z]\w*)*$/,e.languages.jsx.tag.inside.comment=t.comment,e.languages.insertBefore("inside","attr-name",{spread:{pattern:s(/<SPREAD>/.source),inside:e.languages.jsx}},e.languages.jsx.tag),e.languages.insertBefore("inside","special-attr",{script:{pattern:s(/=<BRACES>/.source),alias:"language-javascript",inside:{"script-punctuation":{pattern:/^=(?=\{)/,alias:"punctuation"},rest:e.languages.jsx}}},e.languages.jsx.tag);var r=function(e){return e?"string"==typeof e?e:"string"==typeof e.content?e.content:e.content.map(r).join(""):""};e.hooks.add("after-tokenize",(function(e){"jsx"!==e.language&&"tsx"!==e.language||a(e.tokens)}))}(w),function(e){var t=e.util.clone(e.languages.typescript);(t=(e.languages.tsx=e.languages.extend("jsx",t),delete e.languages.tsx.parameter,delete e.languages.tsx["literal-property"],e.languages.tsx.tag)).pattern=RegExp(/(^|[^\w$]|(?=<\/))/.source+"(?:"+t.pattern.source+")",t.pattern.flags),t.lookbehind=!0}(w),w.languages.swift={comment:{pattern:/(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,lookbehind:!0,greedy:!0},"string-literal":[{pattern:RegExp(/(^|[^"#])/.source+"(?:"+/"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source+"|"+/"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source+")"+/(?!["#])/.source),lookbehind:!0,greedy:!0,inside:{interpolation:{pattern:/(\\\()(?:[^()]|\([^()]*\))*(?=\))/,lookbehind:!0,inside:null},"interpolation-punctuation":{pattern:/^\)|\\\($/,alias:"punctuation"},punctuation:/\\(?=[\r\n])/,string:/[\s\S]+/}},{pattern:RegExp(/(^|[^"#])(#+)/.source+"(?:"+/"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source+"|"+/"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source+")\\2"),lookbehind:!0,greedy:!0,inside:{interpolation:{pattern:/(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,lookbehind:!0,inside:null},"interpolation-punctuation":{pattern:/^\)|\\#+\($/,alias:"punctuation"},string:/[\s\S]+/}}],directive:{pattern:RegExp(/#/.source+"(?:"+/(?:elseif|if)\b/.source+"(?:[ \t]*"+/(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source+")+|"+/(?:else|endif)\b/.source+")"),alias:"property",inside:{"directive-name":/^#\w+/,boolean:/\b(?:false|true)\b/,number:/\b\d+(?:\.\d+)*\b/,operator:/!|&&|\|\||[<>]=?/,punctuation:/[(),]/}},literal:{pattern:/#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,alias:"constant"},"other-directive":{pattern:/#\w+\b/,alias:"property"},attribute:{pattern:/@\w+/,alias:"atrule"},"function-definition":{pattern:/(\bfunc\s+)\w+/,lookbehind:!0,alias:"function"},label:{pattern:/\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,lookbehind:!0,alias:"important"},keyword:/\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,boolean:/\b(?:false|true)\b/,nil:{pattern:/\bnil\b/,alias:"constant"},"short-argument":/\$\d+\b/,omit:{pattern:/\b_\b/,alias:"keyword"},number:/\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,"class-name":/\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,function:/\b[a-z_]\w*(?=\s*\()/i,constant:/\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,operator:/[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,punctuation:/[{}[\]();,.:\\]/},w.languages.swift["string-literal"].forEach((function(e){e.inside.interpolation.inside=w.languages.swift})),function(e){e.languages.kotlin=e.languages.extend("clike",{keyword:{pattern:/(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,lookbehind:!0},function:[{pattern:/(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,greedy:!0},{pattern:/(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,lookbehind:!0,greedy:!0}],number:/\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,operator:/\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/}),delete e.languages.kotlin["class-name"];var t={"interpolation-punctuation":{pattern:/^\$\{?|\}$/,alias:"punctuation"},expression:{pattern:/[\s\S]+/,inside:e.languages.kotlin}};e.languages.insertBefore("kotlin","string",{"string-literal":[{pattern:/"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,alias:"multiline",inside:{interpolation:{pattern:/\$(?:[a-z_]\w*|\{[^{}]*\})/i,inside:t},string:/[\s\S]+/}},{pattern:/"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,alias:"singleline",inside:{interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,lookbehind:!0,inside:t},string:/[\s\S]+/}}],char:{pattern:/'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,greedy:!0}}),delete e.languages.kotlin.string,e.languages.insertBefore("kotlin","keyword",{annotation:{pattern:/\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,alias:"builtin"}}),e.languages.insertBefore("kotlin","function",{label:{pattern:/\b\w+@|@\w+\b/,alias:"symbol"}}),e.languages.kt=e.languages.kotlin,e.languages.kts=e.languages.kotlin}(w),w.languages.c=w.languages.extend("clike",{comment:{pattern:/\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,greedy:!0},string:{pattern:/"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,greedy:!0},"class-name":{pattern:/(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,lookbehind:!0},keyword:/\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,function:/\b[a-z_]\w*(?=\s*\()/i,number:/(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,operator:/>>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/}),w.languages.insertBefore("c","string",{char:{pattern:/'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,greedy:!0}}),w.languages.insertBefore("c","string",{macro:{pattern:/(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,lookbehind:!0,greedy:!0,alias:"property",inside:{string:[{pattern:/^(#\s*include\s*)<[^>]+>/,lookbehind:!0},w.languages.c.string],char:w.languages.c.char,comment:w.languages.c.comment,"macro-name":[{pattern:/(^#\s*define\s+)\w+\b(?!\()/i,lookbehind:!0},{pattern:/(^#\s*define\s+)\w+\b(?=\()/i,lookbehind:!0,alias:"function"}],directive:{pattern:/^(#\s*)[a-z]+/,lookbehind:!0,alias:"keyword"},"directive-hash":/^#/,punctuation:/##|\\(?=[\r\n])/,expression:{pattern:/\S[\s\S]*/,inside:w.languages.c}}}}),w.languages.insertBefore("c","function",{constant:/\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/}),delete w.languages.c.boolean,w.languages.objectivec=w.languages.extend("c",{string:{pattern:/@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,greedy:!0},keyword:/\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,operator:/-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/}),delete w.languages.objectivec["class-name"],w.languages.objc=w.languages.objectivec,w.languages.reason=w.languages.extend("clike",{string:{pattern:/"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,greedy:!0},"class-name":/\b[A-Z]\w*/,keyword:/\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,operator:/\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/}),w.languages.insertBefore("reason","class-name",{char:{pattern:/'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,greedy:!0},constructor:/\b[A-Z]\w*\b(?!\s*\.)/,label:{pattern:/\b[a-z]\w*(?=::)/,alias:"symbol"}}),delete w.languages.reason.function,function(e){for(var t=/\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source,n=0;n<2;n++)t=t.replace(/<self>/g,(function(){return t}));t=t.replace(/<self>/g,(function(){return/[^\s\S]/.source})),e.languages.rust={comment:[{pattern:RegExp(/(^|[^\\])/.source+t),lookbehind:!0,greedy:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,greedy:!0},char:{pattern:/b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,greedy:!0},attribute:{pattern:/#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,greedy:!0,alias:"attr-name",inside:{string:null}},"closure-params":{pattern:/([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,lookbehind:!0,greedy:!0,inside:{"closure-punctuation":{pattern:/^\||\|$/,alias:"punctuation"},rest:null}},"lifetime-annotation":{pattern:/'\w+/,alias:"symbol"},"fragment-specifier":{pattern:/(\$\w+:)[a-z]+/,lookbehind:!0,alias:"punctuation"},variable:/\$\w+/,"function-definition":{pattern:/(\bfn\s+)\w+/,lookbehind:!0,alias:"function"},"type-definition":{pattern:/(\b(?:enum|struct|trait|type|union)\s+)\w+/,lookbehind:!0,alias:"class-name"},"module-declaration":[{pattern:/(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,lookbehind:!0,alias:"namespace"},{pattern:/(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,lookbehind:!0,alias:"namespace",inside:{punctuation:/::/}}],keyword:[/\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,/\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/],function:/\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,macro:{pattern:/\b\w+!/,alias:"property"},constant:/\b[A-Z_][A-Z_\d]+\b/,"class-name":/\b[A-Z]\w*\b/,namespace:{pattern:/(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,inside:{punctuation:/::/}},number:/\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,boolean:/\b(?:false|true)\b/,punctuation:/->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,operator:/[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/},e.languages.rust["closure-params"].inside.rest=e.languages.rust,e.languages.rust.attribute.inside.string=e.languages.rust.string}(w),w.languages.go=w.languages.extend("clike",{string:{pattern:/(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,lookbehind:!0,greedy:!0},keyword:/\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,boolean:/\b(?:_|false|iota|nil|true)\b/,number:[/\b0(?:b[01_]+|o[0-7_]+)i?\b/i,/\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,/(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i],operator:/[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,builtin:/\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/}),w.languages.insertBefore("go","string",{char:{pattern:/'(?:\\.|[^'\\\r\n]){0,10}'/,greedy:!0}}),delete w.languages.go["class-name"],function(e){var t=/\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,n=/\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g,(function(){return t.source}));e.languages.cpp=e.languages.extend("c",{"class-name":[{pattern:RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g,(function(){return t.source}))),lookbehind:!0},/\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,/\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,/\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/],keyword:t,number:{pattern:/(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,greedy:!0},operator:/>>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,boolean:/\b(?:false|true)\b/}),e.languages.insertBefore("cpp","string",{module:{pattern:RegExp(/(\b(?:import|module)\s+)/.source+"(?:"+/"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source+"|"+/<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g,(function(){return n}))+")"),lookbehind:!0,greedy:!0,inside:{string:/^[<"][\s\S]+/,operator:/:/,punctuation:/\./}},"raw-string":{pattern:/R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,alias:"string",greedy:!0}}),e.languages.insertBefore("cpp","keyword",{"generic-function":{pattern:/\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,inside:{function:/^\w+/,generic:{pattern:/<[\s\S]+/,alias:"class-name",inside:e.languages.cpp}}}}),e.languages.insertBefore("cpp","operator",{"double-colon":{pattern:/::/,alias:"punctuation"}}),e.languages.insertBefore("cpp","class-name",{"base-clause":{pattern:/(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,lookbehind:!0,greedy:!0,inside:e.languages.extend("cpp",{})}}),e.languages.insertBefore("inside","double-colon",{"class-name":/\b[a-z_]\w*\b(?!\s*::)/i},e.languages.cpp["base-clause"])}(w),w.languages.python={comment:{pattern:/(^|[^\\])#.*/,lookbehind:!0,greedy:!0},"string-interpolation":{pattern:/(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,greedy:!0,inside:{interpolation:{pattern:/((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,lookbehind:!0,inside:{"format-spec":{pattern:/(:)[^:(){}]+(?=\}$)/,lookbehind:!0},"conversion-option":{pattern:/![sra](?=[:}]$)/,alias:"punctuation"},rest:null}},string:/[\s\S]+/}},"triple-quoted-string":{pattern:/(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,greedy:!0,alias:"string"},string:{pattern:/(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,greedy:!0},function:{pattern:/((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,lookbehind:!0},"class-name":{pattern:/(\bclass\s+)\w+/i,lookbehind:!0},decorator:{pattern:/(^[\t ]*)@\w+(?:\.\w+)*/m,lookbehind:!0,alias:["annotation","punctuation"],inside:{punctuation:/\./}},keyword:/\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,builtin:/\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,boolean:/\b(?:False|None|True)\b/,number:/\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,operator:/[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,punctuation:/[{}[\];(),.:]/},w.languages.python["string-interpolation"].inside.interpolation.inside.rest=w.languages.python,w.languages.py=w.languages.python;((e,t)=>{for(var n in t)h(e,n,{get:t[n],enumerable:!0})})({},{dracula:()=>S,duotoneDark:()=>I,duotoneLight:()=>O,github:()=>x,jettwaveDark:()=>G,jettwaveLight:()=>B,nightOwl:()=>N,nightOwlLight:()=>U,oceanicNext:()=>L,okaidia:()=>D,oneDark:()=>J,oneLight:()=>Q,palenight:()=>q,shadesOfPurple:()=>F,synthwave84:()=>j,ultramin:()=>M,vsDark:()=>z,vsLight:()=>V});var S={plain:{color:"#F8F8F2",backgroundColor:"#282A36"},styles:[{types:["prolog","constant","builtin"],style:{color:"rgb(189, 147, 249)"}},{types:["inserted","function"],style:{color:"rgb(80, 250, 123)"}},{types:["deleted"],style:{color:"rgb(255, 85, 85)"}},{types:["changed"],style:{color:"rgb(255, 184, 108)"}},{types:["punctuation","symbol"],style:{color:"rgb(248, 248, 242)"}},{types:["string","char","tag","selector"],style:{color:"rgb(255, 121, 198)"}},{types:["keyword","variable"],style:{color:"rgb(189, 147, 249)",fontStyle:"italic"}},{types:["comment"],style:{color:"rgb(98, 114, 164)"}},{types:["attr-name"],style:{color:"rgb(241, 250, 140)"}}]},I={plain:{backgroundColor:"#2a2734",color:"#9a86fd"},styles:[{types:["comment","prolog","doctype","cdata","punctuation"],style:{color:"#6c6783"}},{types:["namespace"],style:{opacity:.7}},{types:["tag","operator","number"],style:{color:"#e09142"}},{types:["property","function"],style:{color:"#9a86fd"}},{types:["tag-id","selector","atrule-id"],style:{color:"#eeebff"}},{types:["attr-name"],style:{color:"#c4b9fe"}},{types:["boolean","string","entity","url","attr-value","keyword","control","directive","unit","statement","regex","atrule","placeholder","variable"],style:{color:"#ffcc99"}},{types:["deleted"],style:{textDecorationLine:"line-through"}},{types:["inserted"],style:{textDecorationLine:"underline"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["important","bold"],style:{fontWeight:"bold"}},{types:["important"],style:{color:"#c4b9fe"}}]},O={plain:{backgroundColor:"#faf8f5",color:"#728fcb"},styles:[{types:["comment","prolog","doctype","cdata","punctuation"],style:{color:"#b6ad9a"}},{types:["namespace"],style:{opacity:.7}},{types:["tag","operator","number"],style:{color:"#063289"}},{types:["property","function"],style:{color:"#b29762"}},{types:["tag-id","selector","atrule-id"],style:{color:"#2d2006"}},{types:["attr-name"],style:{color:"#896724"}},{types:["boolean","string","entity","url","attr-value","keyword","control","directive","unit","statement","regex","atrule"],style:{color:"#728fcb"}},{types:["placeholder","variable"],style:{color:"#93abdc"}},{types:["deleted"],style:{textDecorationLine:"line-through"}},{types:["inserted"],style:{textDecorationLine:"underline"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["important","bold"],style:{fontWeight:"bold"}},{types:["important"],style:{color:"#896724"}}]},x={plain:{color:"#393A34",backgroundColor:"#f6f8fa"},styles:[{types:["comment","prolog","doctype","cdata"],style:{color:"#999988",fontStyle:"italic"}},{types:["namespace"],style:{opacity:.7}},{types:["string","attr-value"],style:{color:"#e3116c"}},{types:["punctuation","operator"],style:{color:"#393A34"}},{types:["entity","url","symbol","number","boolean","variable","constant","property","regex","inserted"],style:{color:"#36acaa"}},{types:["atrule","keyword","attr-name","selector"],style:{color:"#00a4db"}},{types:["function","deleted","tag"],style:{color:"#d73a49"}},{types:["function-variable"],style:{color:"#6f42c1"}},{types:["tag","selector","keyword"],style:{color:"#00009f"}}]},N={plain:{color:"#d6deeb",backgroundColor:"#011627"},styles:[{types:["changed"],style:{color:"rgb(162, 191, 252)",fontStyle:"italic"}},{types:["deleted"],style:{color:"rgba(239, 83, 80, 0.56)",fontStyle:"italic"}},{types:["inserted","attr-name"],style:{color:"rgb(173, 219, 103)",fontStyle:"italic"}},{types:["comment"],style:{color:"rgb(99, 119, 119)",fontStyle:"italic"}},{types:["string","url"],style:{color:"rgb(173, 219, 103)"}},{types:["variable"],style:{color:"rgb(214, 222, 235)"}},{types:["number"],style:{color:"rgb(247, 140, 108)"}},{types:["builtin","char","constant","function"],style:{color:"rgb(130, 170, 255)"}},{types:["punctuation"],style:{color:"rgb(199, 146, 234)"}},{types:["selector","doctype"],style:{color:"rgb(199, 146, 234)",fontStyle:"italic"}},{types:["class-name"],style:{color:"rgb(255, 203, 139)"}},{types:["tag","operator","keyword"],style:{color:"rgb(127, 219, 202)"}},{types:["boolean"],style:{color:"rgb(255, 88, 116)"}},{types:["property"],style:{color:"rgb(128, 203, 196)"}},{types:["namespace"],style:{color:"rgb(178, 204, 214)"}}]},U={plain:{color:"#403f53",backgroundColor:"#FBFBFB"},styles:[{types:["changed"],style:{color:"rgb(162, 191, 252)",fontStyle:"italic"}},{types:["deleted"],style:{color:"rgba(239, 83, 80, 0.56)",fontStyle:"italic"}},{types:["inserted","attr-name"],style:{color:"rgb(72, 118, 214)",fontStyle:"italic"}},{types:["comment"],style:{color:"rgb(152, 159, 177)",fontStyle:"italic"}},{types:["string","builtin","char","constant","url"],style:{color:"rgb(72, 118, 214)"}},{types:["variable"],style:{color:"rgb(201, 103, 101)"}},{types:["number"],style:{color:"rgb(170, 9, 130)"}},{types:["punctuation"],style:{color:"rgb(153, 76, 195)"}},{types:["function","selector","doctype"],style:{color:"rgb(153, 76, 195)",fontStyle:"italic"}},{types:["class-name"],style:{color:"rgb(17, 17, 17)"}},{types:["tag"],style:{color:"rgb(153, 76, 195)"}},{types:["operator","property","keyword","namespace"],style:{color:"rgb(12, 150, 155)"}},{types:["boolean"],style:{color:"rgb(188, 84, 84)"}}]},Y="#c5a5c5",C="#8dc891",L={plain:{backgroundColor:"#282c34",color:"#ffffff"},styles:[{types:["attr-name"],style:{color:Y}},{types:["attr-value"],style:{color:C}},{types:["comment","block-comment","prolog","doctype","cdata","shebang"],style:{color:"#999999"}},{types:["property","number","function-name","constant","symbol","deleted"],style:{color:"#5a9bcf"}},{types:["boolean"],style:{color:"#ff8b50"}},{types:["tag"],style:{color:"#fc929e"}},{types:["string"],style:{color:C}},{types:["punctuation"],style:{color:C}},{types:["selector","char","builtin","inserted"],style:{color:"#D8DEE9"}},{types:["function"],style:{color:"#79b6f2"}},{types:["operator","entity","url","variable"],style:{color:"#d7deea"}},{types:["keyword"],style:{color:Y}},{types:["atrule","class-name"],style:{color:"#FAC863"}},{types:["important"],style:{fontWeight:"400"}},{types:["bold"],style:{fontWeight:"bold"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["namespace"],style:{opacity:.7}}]},D={plain:{color:"#f8f8f2",backgroundColor:"#272822"},styles:[{types:["changed"],style:{color:"rgb(162, 191, 252)",fontStyle:"italic"}},{types:["deleted"],style:{color:"#f92672",fontStyle:"italic"}},{types:["inserted"],style:{color:"rgb(173, 219, 103)",fontStyle:"italic"}},{types:["comment"],style:{color:"#8292a2",fontStyle:"italic"}},{types:["string","url"],style:{color:"#a6e22e"}},{types:["variable"],style:{color:"#f8f8f2"}},{types:["number"],style:{color:"#ae81ff"}},{types:["builtin","char","constant","function","class-name"],style:{color:"#e6db74"}},{types:["punctuation"],style:{color:"#f8f8f2"}},{types:["selector","doctype"],style:{color:"#a6e22e",fontStyle:"italic"}},{types:["tag","operator","keyword"],style:{color:"#66d9ef"}},{types:["boolean"],style:{color:"#ae81ff"}},{types:["namespace"],style:{color:"rgb(178, 204, 214)",opacity:.7}},{types:["tag","property"],style:{color:"#f92672"}},{types:["attr-name"],style:{color:"#a6e22e !important"}},{types:["doctype"],style:{color:"#8292a2"}},{types:["rule"],style:{color:"#e6db74"}}]},q={plain:{color:"#bfc7d5",backgroundColor:"#292d3e"},styles:[{types:["comment"],style:{color:"rgb(105, 112, 152)",fontStyle:"italic"}},{types:["string","inserted"],style:{color:"rgb(195, 232, 141)"}},{types:["number"],style:{color:"rgb(247, 140, 108)"}},{types:["builtin","char","constant","function"],style:{color:"rgb(130, 170, 255)"}},{types:["punctuation","selector"],style:{color:"rgb(199, 146, 234)"}},{types:["variable"],style:{color:"rgb(191, 199, 213)"}},{types:["class-name","attr-name"],style:{color:"rgb(255, 203, 107)"}},{types:["tag","deleted"],style:{color:"rgb(255, 85, 114)"}},{types:["operator"],style:{color:"rgb(137, 221, 255)"}},{types:["boolean"],style:{color:"rgb(255, 88, 116)"}},{types:["keyword"],style:{fontStyle:"italic"}},{types:["doctype"],style:{color:"rgb(199, 146, 234)",fontStyle:"italic"}},{types:["namespace"],style:{color:"rgb(178, 204, 214)"}},{types:["url"],style:{color:"rgb(221, 221, 221)"}}]},F={plain:{color:"#9EFEFF",backgroundColor:"#2D2A55"},styles:[{types:["changed"],style:{color:"rgb(255, 238, 128)"}},{types:["deleted"],style:{color:"rgba(239, 83, 80, 0.56)"}},{types:["inserted"],style:{color:"rgb(173, 219, 103)"}},{types:["comment"],style:{color:"rgb(179, 98, 255)",fontStyle:"italic"}},{types:["punctuation"],style:{color:"rgb(255, 255, 255)"}},{types:["constant"],style:{color:"rgb(255, 98, 140)"}},{types:["string","url"],style:{color:"rgb(165, 255, 144)"}},{types:["variable"],style:{color:"rgb(255, 238, 128)"}},{types:["number","boolean"],style:{color:"rgb(255, 98, 140)"}},{types:["attr-name"],style:{color:"rgb(255, 180, 84)"}},{types:["keyword","operator","property","namespace","tag","selector","doctype"],style:{color:"rgb(255, 157, 0)"}},{types:["builtin","char","constant","function","class-name"],style:{color:"rgb(250, 208, 0)"}}]},j={plain:{backgroundColor:"linear-gradient(to bottom, #2a2139 75%, #34294f)",backgroundImage:"#34294f",color:"#f92aad",textShadow:"0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"},styles:[{types:["comment","block-comment","prolog","doctype","cdata"],style:{color:"#495495",fontStyle:"italic"}},{types:["punctuation"],style:{color:"#ccc"}},{types:["tag","attr-name","namespace","number","unit","hexcode","deleted"],style:{color:"#e2777a"}},{types:["property","selector"],style:{color:"#72f1b8",textShadow:"0 0 2px #100c0f, 0 0 10px #257c5575, 0 0 35px #21272475"}},{types:["function-name"],style:{color:"#6196cc"}},{types:["boolean","selector-id","function"],style:{color:"#fdfdfd",textShadow:"0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"}},{types:["class-name","maybe-class-name","builtin"],style:{color:"#fff5f6",textShadow:"0 0 2px #000, 0 0 10px #fc1f2c75, 0 0 5px #fc1f2c75, 0 0 25px #fc1f2c75"}},{types:["constant","symbol"],style:{color:"#f92aad",textShadow:"0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"}},{types:["important","atrule","keyword","selector-class"],style:{color:"#f4eee4",textShadow:"0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"}},{types:["string","char","attr-value","regex","variable"],style:{color:"#f87c32"}},{types:["parameter"],style:{fontStyle:"italic"}},{types:["entity","url"],style:{color:"#67cdcc"}},{types:["operator"],style:{color:"ffffffee"}},{types:["important","bold"],style:{fontWeight:"bold"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["entity"],style:{cursor:"help"}},{types:["inserted"],style:{color:"green"}}]},M={plain:{color:"#282a2e",backgroundColor:"#ffffff"},styles:[{types:["comment"],style:{color:"rgb(197, 200, 198)"}},{types:["string","number","builtin","variable"],style:{color:"rgb(150, 152, 150)"}},{types:["class-name","function","tag","attr-name"],style:{color:"rgb(40, 42, 46)"}}]},z={plain:{color:"#9CDCFE",backgroundColor:"#1E1E1E"},styles:[{types:["prolog"],style:{color:"rgb(0, 0, 128)"}},{types:["comment"],style:{color:"rgb(106, 153, 85)"}},{types:["builtin","changed","keyword","interpolation-punctuation"],style:{color:"rgb(86, 156, 214)"}},{types:["number","inserted"],style:{color:"rgb(181, 206, 168)"}},{types:["constant"],style:{color:"rgb(100, 102, 149)"}},{types:["attr-name","variable"],style:{color:"rgb(156, 220, 254)"}},{types:["deleted","string","attr-value","template-punctuation"],style:{color:"rgb(206, 145, 120)"}},{types:["selector"],style:{color:"rgb(215, 186, 125)"}},{types:["tag"],style:{color:"rgb(78, 201, 176)"}},{types:["tag"],languages:["markup"],style:{color:"rgb(86, 156, 214)"}},{types:["punctuation","operator"],style:{color:"rgb(212, 212, 212)"}},{types:["punctuation"],languages:["markup"],style:{color:"#808080"}},{types:["function"],style:{color:"rgb(220, 220, 170)"}},{types:["class-name"],style:{color:"rgb(78, 201, 176)"}},{types:["char"],style:{color:"rgb(209, 105, 105)"}}]},V={plain:{color:"#000000",backgroundColor:"#ffffff"},styles:[{types:["comment"],style:{color:"rgb(0, 128, 0)"}},{types:["builtin"],style:{color:"rgb(0, 112, 193)"}},{types:["number","variable","inserted"],style:{color:"rgb(9, 134, 88)"}},{types:["operator"],style:{color:"rgb(0, 0, 0)"}},{types:["constant","char"],style:{color:"rgb(129, 31, 63)"}},{types:["tag"],style:{color:"rgb(128, 0, 0)"}},{types:["attr-name"],style:{color:"rgb(255, 0, 0)"}},{types:["deleted","string"],style:{color:"rgb(163, 21, 21)"}},{types:["changed","punctuation"],style:{color:"rgb(4, 81, 165)"}},{types:["function","keyword"],style:{color:"rgb(0, 0, 255)"}},{types:["class-name"],style:{color:"rgb(38, 127, 153)"}}]},G={plain:{color:"#f8fafc",backgroundColor:"#011627"},styles:[{types:["prolog"],style:{color:"#000080"}},{types:["comment"],style:{color:"#6A9955"}},{types:["builtin","changed","keyword","interpolation-punctuation"],style:{color:"#569CD6"}},{types:["number","inserted"],style:{color:"#B5CEA8"}},{types:["constant"],style:{color:"#f8fafc"}},{types:["attr-name","variable"],style:{color:"#9CDCFE"}},{types:["deleted","string","attr-value","template-punctuation"],style:{color:"#cbd5e1"}},{types:["selector"],style:{color:"#D7BA7D"}},{types:["tag"],style:{color:"#0ea5e9"}},{types:["tag"],languages:["markup"],style:{color:"#0ea5e9"}},{types:["punctuation","operator"],style:{color:"#D4D4D4"}},{types:["punctuation"],languages:["markup"],style:{color:"#808080"}},{types:["function"],style:{color:"#7dd3fc"}},{types:["class-name"],style:{color:"#0ea5e9"}},{types:["char"],style:{color:"#D16969"}}]},B={plain:{color:"#0f172a",backgroundColor:"#f1f5f9"},styles:[{types:["prolog"],style:{color:"#000080"}},{types:["comment"],style:{color:"#6A9955"}},{types:["builtin","changed","keyword","interpolation-punctuation"],style:{color:"#0c4a6e"}},{types:["number","inserted"],style:{color:"#B5CEA8"}},{types:["constant"],style:{color:"#0f172a"}},{types:["attr-name","variable"],style:{color:"#0c4a6e"}},{types:["deleted","string","attr-value","template-punctuation"],style:{color:"#64748b"}},{types:["selector"],style:{color:"#D7BA7D"}},{types:["tag"],style:{color:"#0ea5e9"}},{types:["tag"],languages:["markup"],style:{color:"#0ea5e9"}},{types:["punctuation","operator"],style:{color:"#475569"}},{types:["punctuation"],languages:["markup"],style:{color:"#808080"}},{types:["function"],style:{color:"#0e7490"}},{types:["class-name"],style:{color:"#0ea5e9"}},{types:["char"],style:{color:"#D16969"}}]},J={plain:{backgroundColor:"hsl(220, 13%, 18%)",color:"hsl(220, 14%, 71%)",textShadow:"0 1px rgba(0, 0, 0, 0.3)"},styles:[{types:["comment","prolog","cdata"],style:{color:"hsl(220, 10%, 40%)"}},{types:["doctype","punctuation","entity"],style:{color:"hsl(220, 14%, 71%)"}},{types:["attr-name","class-name","maybe-class-name","boolean","constant","number","atrule"],style:{color:"hsl(29, 54%, 61%)"}},{types:["keyword"],style:{color:"hsl(286, 60%, 67%)"}},{types:["property","tag","symbol","deleted","important"],style:{color:"hsl(355, 65%, 65%)"}},{types:["selector","string","char","builtin","inserted","regex","attr-value"],style:{color:"hsl(95, 38%, 62%)"}},{types:["variable","operator","function"],style:{color:"hsl(207, 82%, 66%)"}},{types:["url"],style:{color:"hsl(187, 47%, 55%)"}},{types:["deleted"],style:{textDecorationLine:"line-through"}},{types:["inserted"],style:{textDecorationLine:"underline"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["important","bold"],style:{fontWeight:"bold"}},{types:["important"],style:{color:"hsl(220, 14%, 71%)"}}]},Q={plain:{backgroundColor:"hsl(230, 1%, 98%)",color:"hsl(230, 8%, 24%)"},styles:[{types:["comment","prolog","cdata"],style:{color:"hsl(230, 4%, 64%)"}},{types:["doctype","punctuation","entity"],style:{color:"hsl(230, 8%, 24%)"}},{types:["attr-name","class-name","boolean","constant","number","atrule"],style:{color:"hsl(35, 99%, 36%)"}},{types:["keyword"],style:{color:"hsl(301, 63%, 40%)"}},{types:["property","tag","symbol","deleted","important"],style:{color:"hsl(5, 74%, 59%)"}},{types:["selector","string","char","builtin","inserted","regex","attr-value","punctuation"],style:{color:"hsl(119, 34%, 47%)"}},{types:["variable","operator","function"],style:{color:"hsl(221, 87%, 60%)"}},{types:["url"],style:{color:"hsl(198, 99%, 37%)"}},{types:["deleted"],style:{textDecorationLine:"line-through"}},{types:["inserted"],style:{textDecorationLine:"underline"}},{types:["italic"],style:{fontStyle:"italic"}},{types:["important","bold"],style:{fontWeight:"bold"}},{types:["important"],style:{color:"hsl(230, 8%, 24%)"}}]},H=(e,t)=>{const{plain:n}=e,o=e.styles.reduce(((e,n)=>{const{languages:o,style:i}=n;return o&&!o.includes(t)||n.types.forEach((t=>{const n=E(E({},e[t]),i);e[t]=n})),e}),{});return o.root=n,o.plain=R(E({},n),{backgroundColor:void 0}),o},W=/\r\n|\r|\n/,K=e=>{0===e.length?e.push({types:["plain"],content:"\n",empty:!0}):1===e.length&&""===e[0].content&&(e[0].content="\n",e[0].empty=!0)},$=(e,t)=>{const n=e.length;return n>0&&e[n-1]===t?e:e.concat(t)},Z=e=>{const t=[[]],n=[e],o=[0],i=[e.length];let s=0,a=0,r=[];const p=[r];for(;a>-1;){for(;(s=o[a]++)<i[a];){let e,c=t[a];const d=n[a][s];if("string"==typeof d?(c=a>0?c:["plain"],e=d):(c=$(c,d.type),d.alias&&(c=$(c,d.alias)),e=d.content),"string"!=typeof e){a++,t.push(c),n.push(e),o.push(0),i.push(e.length);continue}const l=e.split(W),u=l.length;r.push({types:c,content:l[0]});for(let t=1;t<u;t++)K(r),p.push(r=[]),r.push({types:c,content:l[t]})}a--,t.pop(),n.pop(),o.pop(),i.pop()}return K(r),p},X=({children:e,language:t,code:n,theme:o,prism:i})=>{const s=t.toLowerCase(),a=((e,t)=>{const[n,o]=(0,d.useState)(H(t,e)),i=(0,d.useRef)(),s=(0,d.useRef)();return(0,d.useEffect)((()=>{t===i.current&&e===s.current||(i.current=t,s.current=e,o(H(t,e)))}),[e,t]),n})(s,o),r=(e=>(0,d.useCallback)((t=>{var n=t,{className:o,style:i,line:s}=n,a=A(n,["className","style","line"]);const r=R(E({},a),{className:(0,l.Z)("token-line",o)});return"object"==typeof e&&"plain"in e&&(r.style=e.plain),"object"==typeof i&&(r.style=E(E({},r.style||{}),i)),r}),[e]))(a),p=(e=>{const t=(0,d.useCallback)((({types:t,empty:n})=>{if(null!=e)return 1===t.length&&"plain"===t[0]?null!=n?{display:"inline-block"}:void 0:1===t.length&&null!=n?e[t[0]]:Object.assign(null!=n?{display:"inline-block"}:{},...t.map((t=>e[t])))}),[e]);return(0,d.useCallback)((e=>{var n=e,{token:o,className:i,style:s}=n,a=A(n,["token","className","style"]);const r=R(E({},a),{className:(0,l.Z)("token",...o.types,i),children:o.content,style:t(o)});return null!=s&&(r.style=E(E({},r.style||{}),s)),r}),[t])})(a),c=(({prism:e,code:t,grammar:n,language:o})=>{const i=(0,d.useRef)(e);return(0,d.useMemo)((()=>{if(null==n)return Z([t]);const e={code:t,grammar:n,language:o,tokens:[]};return i.current.hooks.run("before-tokenize",e),e.tokens=i.current.tokenize(t,n),i.current.hooks.run("after-tokenize",e),Z(e.tokens)}),[t,n,o])})({prism:i,language:s,code:n,grammar:i.languages[s]});return e({tokens:c,className:`prism-code language-${s}`,style:null!=a?a.root:{},getLineProps:r,getTokenProps:p})},ee=e=>(0,d.createElement)(X,R(E({},e),{prism:e.prism||w,theme:e.theme||z,code:e.code,language:e.language}))},90512:(e,t,n)=>{"use strict";function o(e){var t,n,i="";if("string"==typeof e||"number"==typeof e)i+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=o(e[t]))&&(i&&(i+=" "),i+=n);else for(t in e)e[t]&&(i&&(i+=" "),i+=t);return i}n.d(t,{Z:()=>i});const i=function(){for(var e,t,n=0,i="";n<arguments.length;)(e=arguments[n++])&&(t=o(e))&&(i&&(i+=" "),i+=t);return i}},38776:(e,t,n)=>{"use strict";n.d(t,{Z:()=>s});var o=!0,i="Invariant failed";function s(e,t){if(!e){if(o)throw new Error(i);var n="function"==typeof t?t():t,s=n?"".concat(i,": ").concat(n):i;throw new Error(s)}}},57529:e=>{"use strict";e.exports={}},16887:e=>{"use strict";e.exports=JSON.parse('{"/api/-acb":{"__comp":"f0ad3fbb","__context":{"plugin":"34ce8394"},"specProps":"2dd1c8dd","layoutProps":"3b408982"},"/markdown-page-3cc":{"__comp":"1f391b9e","__context":{"plugin":"5ffcd300"},"content":"393be207"},"/search-264":{"__comp":"1a4e3797","__context":{"plugin":"72adf621"}},"/docs-389":{"__comp":"5e95c892","__context":{"plugin":"675359c4"}},"/docs-d83":{"__comp":"a7bd4aaa","version":"935f2afb"},"/docs-b8d":{"__comp":"a94703ab"},"/docs/-662":{"__comp":"17896441","content":"c377a04b"},"/docs/build/clients-2a1":{"__comp":"17896441","content":"c63d7cf9"},"/docs/build/dev-environment-ce8":{"__comp":"17896441","content":"e66e98d0"},"/docs/build/libraries-930":{"__comp":"17896441","content":"d63fee6f"},"/docs/discover/dapps-930":{"__comp":"17896441","content":"d699eab4"},"/docs/discover/explorer-83c":{"__comp":"17896441","content":"57887178"},"/docs/discover/explorer/-1bd":{"__comp":"17896441","content":"dcfecf48"},"/docs/discover/explorer/explorer-as-a-service/-4c5":{"__comp":"17896441","content":"eba5eeb0"},"/docs/discover/explorer/explorer-as-a-service/ingestion-120":{"__comp":"17896441","content":"838112e6"},"/docs/discover/explorer/ui-walkthrough/account-address-59c":{"__comp":"17896441","content":"18225268"},"/docs/discover/explorer/ui-walkthrough/assets-c7a":{"__comp":"17896441","content":"c79678dd"},"/docs/discover/explorer/ui-walkthrough/dashboard/-bfa":{"__comp":"17896441","content":"34c1e115"},"/docs/discover/explorer/ui-walkthrough/dashboard/blocks-f9d":{"__comp":"17896441","content":"a211fb39"},"/docs/discover/explorer/ui-walkthrough/forthcoming/blockchain-statistics-859":{"__comp":"17896441","content":"a5bef1e5"},"/docs/discover/explorer/ui-walkthrough/forthcoming/ibc-f04":{"__comp":"17896441","content":"49108e93"},"/docs/discover/explorer/ui-walkthrough/governance-710":{"__comp":"17896441","content":"fcac9a94"},"/docs/discover/explorer/ui-walkthrough/staking-validators/-3ed":{"__comp":"17896441","content":"692ce386"},"/docs/discover/explorer/ui-walkthrough/staking-validators/validator-details-1c2":{"__comp":"17896441","content":"7ab24626"},"/docs/discover/explorer/ui-walkthrough/transactions-3f7":{"__comp":"17896441","content":"7f608aa1"},"/docs/discover/explorer/ui-walkthrough/walkthru-8d5":{"__comp":"17896441","content":"c0e15940"},"/docs/discover/hash-523":{"__comp":"17896441","content":"44dea36a"},"/docs/discover/money-86d":{"__comp":"17896441","content":"224635d1"},"/docs/discover/ramps-862":{"__comp":"17896441","content":"27a9d6c5"},"/docs/discover/resources-feb":{"__comp":"17896441","content":"e0d232bf"},"/docs/discover/smart-contract-catalog-2cd":{"__comp":"17896441","content":"e94e12f0"},"/docs/discover/solutions-5a0":{"__comp":"17896441","content":"6e93f297"},"/docs/discover/staking-a24":{"__comp":"17896441","content":"6f6da0a1"},"/docs/discover/usdf-b48":{"__comp":"17896441","content":"12de55de"},"/docs/discover/wallets-8a8":{"__comp":"17896441","content":"9286998c"},"/docs/learn/about-provenance/-f15":{"__comp":"17896441","content":"b4363cdd"},"/docs/learn/about-provenance/foundation-248":{"__comp":"17896441","content":"918a6147"},"/docs/learn/asset-lifecycle/-ce4":{"__comp":"17896441","content":"4f6d8885"},"/docs/learn/asset-lifecycle/assets-overview-a45":{"__comp":"17896441","content":"fb30c99f"},"/docs/learn/asset-lifecycle/capital-raise-example-706":{"__comp":"17896441","content":"20fc3f76"},"/docs/learn/asset-lifecycle/issue-f23":{"__comp":"17896441","content":"49870d76"},"/docs/learn/asset-lifecycle/lending-example-753":{"__comp":"17896441","content":"ee686975"},"/docs/learn/asset-lifecycle/manage-316":{"__comp":"17896441","content":"843d4610"},"/docs/learn/asset-lifecycle/markers-73c":{"__comp":"17896441","content":"39b7b8a1"},"/docs/learn/asset-lifecycle/nfts-ad3":{"__comp":"17896441","content":"ceb5af00"},"/docs/learn/asset-lifecycle/trade-60d":{"__comp":"17896441","content":"17d612a1"},"/docs/learn/dapps/blockchain-communication-7b5":{"__comp":"17896441","content":"4c582ecf"},"/docs/learn/dapps/dapp-architecture-6d9":{"__comp":"17896441","content":"3604eab4"},"/docs/learn/dapps/dapps-overview-ba7":{"__comp":"17896441","content":"4e19846a"},"/docs/learn/dapps/data-privacy-8a7":{"__comp":"17896441","content":"960691ce"},"/docs/learn/dapps/fiat-ramps-196":{"__comp":"17896441","content":"11655800"},"/docs/learn/dapps/identity-verification-5d5":{"__comp":"17896441","content":"3a7a8a49"},"/docs/learn/dapps/identity-verification/attribute-names-9d6":{"__comp":"17896441","content":"88912d26"},"/docs/learn/dapps/identity-verification/attribute-values-2fd":{"__comp":"17896441","content":"794070ee"},"/docs/learn/dapps/identity-verification/flow-90e":{"__comp":"17896441","content":"9d2ba7fb"},"/docs/learn/dapps/identity-verification/identity-attribute-tutorial-2a6":{"__comp":"17896441","content":"3695be36"},"/docs/learn/dapps/identity-verification/identity-nfts-d8a":{"__comp":"17896441","content":"5d311828"},"/docs/learn/dapps/organization-management-b89":{"__comp":"17896441","content":"5c826b46"},"/docs/learn/dapps/ui-ux-f2d":{"__comp":"17896441","content":"ec18fed9"},"/docs/learn/learn-about-b60":{"__comp":"17896441","content":"3761e2f2"},"/docs/learn/provenance-applications/apps-powered-by-provenance-45e":{"__comp":"17896441","content":"df18dd7d"},"/docs/learn/provenance-applications/loan-origination-system-los/-a96":{"__comp":"17896441","content":"8174260a"},"/docs/learn/provenance-applications/loan-origination-system-los/assets-04c":{"__comp":"17896441","content":"04ffa485"},"/docs/learn/provenance-applications/loan-origination-system-los/data-sharing-with-portfolio-manager-a28":{"__comp":"17896441","content":"30f01348"},"/docs/learn/provenance-applications/loan-origination-system-los/funding-85f":{"__comp":"17896441","content":"ba11e1b9"},"/docs/learn/provenance-applications/loan-origination-system-los/loan-servicing-f0a":{"__comp":"17896441","content":"552a5b32"},"/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/-afb":{"__comp":"17896441","content":"cfd5da02"},"/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/3rd-party-digital-signatures-ab5":{"__comp":"17896441","content":"3a404b4f"},"/docs/learn/provenance-applications/loan-origination-system-los/loan-validation/loan-servicing-cca":{"__comp":"17896441","content":"6216800c"},"/docs/learn/provenance-applications/loan-origination-system-los/onboarding-contract-b65":{"__comp":"17896441","content":"d8f7434e"},"/docs/learn/provenance-applications/omnibus-ef0":{"__comp":"17896441","content":"107e0817"},"/docs/learn/whitepapers/blockchain-impact-on-credit-ratings-9b4":{"__comp":"17896441","content":"9274dddb"},"/docs/learn/whitepapers/investment-fund-services-on-provenance-98a":{"__comp":"17896441","content":"2f554aff"},"/docs/learn/whitepapers/loan-participation-on-provenance-626":{"__comp":"17896441","content":"b6b00c1e"},"/docs/learn/whitepapers/securitization-on-provenance-110":{"__comp":"17896441","content":"ec6e4860"},"/docs/learn/whitepapers/supply-chain-finance-on-provenance-ed8":{"__comp":"17896441","content":"f730245e"},"/docs/learn/why-cosmos-92d":{"__comp":"17896441","content":"435a0344"},"/docs/pb/blockchain/basics/accounts-415":{"__comp":"17896441","content":"64db2ecd"},"/docs/pb/blockchain/basics/anatomy-of-a-provenance-application-571":{"__comp":"17896441","content":"5edad310"},"/docs/pb/blockchain/basics/gas-and-fees-146":{"__comp":"17896441","content":"ac294bd0"},"/docs/pb/blockchain/basics/query-lifecycle-5a4":{"__comp":"17896441","content":"8c6ce6d0"},"/docs/pb/blockchain/basics/stablecoin-761":{"__comp":"17896441","content":"c932c0ed"},"/docs/pb/blockchain/basics/transaction-lifecycle-983":{"__comp":"17896441","content":"00e1ed7a"},"/docs/pb/blockchain/introduction/-aa3":{"__comp":"17896441","content":"77c3e805"},"/docs/pb/blockchain/introduction/application-architecture-6d5":{"__comp":"17896441","content":"f1665f4c"},"/docs/pb/blockchain/introduction/major-components-cee":{"__comp":"17896441","content":"f9694a6b"},"/docs/pb/blockchain/running-a-node/-d50":{"__comp":"17896441","content":"b641d608"},"/docs/pb/blockchain/running-a-node/running-a-node-1/-c22":{"__comp":"17896441","content":"79824c81"},"/docs/pb/blockchain/running-a-node/running-a-node-1/become-a-validator-5ea":{"__comp":"17896441","content":"7e534d6c"},"/docs/pb/blockchain/running-a-node/running-a-node-1/configure-a-sentry-717":{"__comp":"17896441","content":"fb9278bc"},"/docs/pb/blockchain/running-a-node/running-a-node-1/join-provenance-testnet/-d5d":{"__comp":"17896441","content":"aa4cf0d5"},"/docs/pb/blockchain/running-a-node/running-a-node-1/join-provenance-testnet/running-a-testnet-node-from-quicksync-9c4":{"__comp":"17896441","content":"386a7de4"},"/docs/pb/blockchain/running-a-node/running-a-node-1/running-a-mainnet-node-b87":{"__comp":"17896441","content":"b3c31fe3"},"/docs/pb/blockchain/using-provenance/-1e7":{"__comp":"17896441","content":"86030147"},"/docs/pb/blockchain/using-provenance/query-command-fbb":{"__comp":"17896441","content":"1386bc64"},"/docs/pb/blockchain/using-provenance/tx-command-920":{"__comp":"17896441","content":"467c0153"},"/docs/pb/contributing/adr/-7e6":{"__comp":"17896441","content":"adcac10b"},"/docs/pb/contributing/adr/administration-91f":{"__comp":"17896441","content":"437ba7a3"},"/docs/pb/contributing/adr/base-infrastructure/-591":{"__comp":"17896441","content":"478c945a"},"/docs/pb/contributing/adr/base-infrastructure/account-metadata-65e":{"__comp":"17896441","content":"42c6802c"},"/docs/pb/contributing/adr/base-infrastructure/name-service-2ca":{"__comp":"17896441","content":"656afb91"},"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/-bf7":{"__comp":"17896441","content":"1f32ae85"},"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/genesis-network-configuration-f13":{"__comp":"17896441","content":"59f3bed4"},"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/hd-wallets-key-pairs-addresses-314":{"__comp":"17896441","content":"03db9e4c"},"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/markers-tokens-and-coins-f05":{"__comp":"17896441","content":"b97da1ff"},"/docs/pb/contributing/adr/blockchain-configuration-and-concepts/transaction-fees-and-gas-e71":{"__comp":"17896441","content":"4635ef74"},"/docs/pb/contributing/adr/business-applications-5eb":{"__comp":"17896441","content":"d74cc90d"},"/docs/pb/contributing/adr/core-concepts/-3a7":{"__comp":"17896441","content":"bd95ecf1"},"/docs/pb/contributing/adr/core-concepts/hash-fa5":{"__comp":"17896441","content":"5802bce8"},"/docs/pb/contributing/adr/core-concepts/identity-7ba":{"__comp":"17896441","content":"590b6b50"},"/docs/pb/contributing/adr/governance-e80":{"__comp":"17896441","content":"aff65b1d"},"/docs/pb/contributing/adr/smart-contracts/-0f0":{"__comp":"17896441","content":"6992b847"},"/docs/pb/contributing/adr/smart-contracts/omnibus-f07":{"__comp":"17896441","content":"a58e2fdd"},"/docs/pb/contributing/adr/smart-contracts/p8e-metadata-5b5":{"__comp":"17896441","content":"d4cf4b1e"},"/docs/pb/contributing/adr/smart-contracts/p8e-smart-contracts-711":{"__comp":"17896441","content":"08e05b71"},"/docs/pb/contributing/adr/smart-contracts/p8e-specifications-8e5":{"__comp":"17896441","content":"91587fb7"},"/docs/pb/contributing/adr/smart-contracts/smart-contracts-1-a57":{"__comp":"17896441","content":"2cfe1a27"},"/docs/pb/contributing/adr/smart-contracts/upgrading-827":{"__comp":"17896441","content":"e7c3554b"},"/docs/pb/contributing/adr/system-migration-d3e":{"__comp":"17896441","content":"f19b186d"},"/docs/pb/contributing/adr/template-c18":{"__comp":"17896441","content":"4859d8e2"},"/docs/pb/ecosystem/community/asset-originators-51e":{"__comp":"17896441","content":"369f35ba"},"/docs/pb/ecosystem/community/delegator-870":{"__comp":"17896441","content":"922b40da"},"/docs/pb/ecosystem/community/validator-895":{"__comp":"17896441","content":"7ac5008d"},"/docs/pb/ecosystem/financial-services-blockchain/-af9":{"__comp":"17896441","content":"3314ce8a"},"/docs/pb/ecosystem/financial-services-blockchain/distribution-350":{"__comp":"17896441","content":"2560a3da"},"/docs/pb/ecosystem/financial-services-blockchain/token-economics-a26":{"__comp":"17896441","content":"7fc14121"},"/docs/pb/ecosystem/governance/-d7d":{"__comp":"17896441","content":"bb729153"},"/docs/pb/ecosystem/governance/software-upgrade-proposal-c77":{"__comp":"17896441","content":"a6955a14"},"/docs/pb/ecosystem/governance/voting-9b9":{"__comp":"17896441","content":"4257fe2b"},"/docs/pb/faq/delegator-faq-1bf":{"__comp":"17896441","content":"eacdae2b"},"/docs/pb/faq/transactions-error-codes-59b":{"__comp":"17896441","content":"ca8aea47"},"/docs/pb/faq/validator-faq-af7":{"__comp":"17896441","content":"49b578ab"},"/docs/pb/integrating/asset-originators-guide-2c1":{"__comp":"17896441","content":"4bc6e3bf"},"/docs/pb/integrating/integrating-with-p8e/-0f3":{"__comp":"17896441","content":"0602d7e2"},"/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/-767":{"__comp":"17896441","content":"1bef93b5"},"/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/data-mapping-2fa":{"__comp":"17896441","content":"06b87490"},"/docs/pb/integrating/integrating-with-p8e/lending-ecosystem/life-cycle-of-a-loan-add":{"__comp":"17896441","content":"a9df9c48"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/-5b2":{"__comp":"17896441","content":"5ee5099f"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/-c47":{"__comp":"17896441","content":"7c91ab8a"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/configuration-endpoints-ee0":{"__comp":"17896441","content":"6c5235e2"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/-94e":{"__comp":"17896441","content":"441e93e4"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/approve-contract-e72":{"__comp":"17896441","content":"19a920b0"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/contract-execution-endpoints/execute-contract-5d5":{"__comp":"17896441","content":"8cf8b69a"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/-a9c":{"__comp":"17896441","content":"58b1a698"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/retrieve-file-d83":{"__comp":"17896441","content":"7272aeda"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/retrieve-object-8e0":{"__comp":"17896441","content":"b540ff88"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/store-file-f95":{"__comp":"17896441","content":"fc25d28c"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/object-store-endpoints/store-object-418":{"__comp":"17896441","content":"0911d173"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-specification/p8e-endpoints-f7c":{"__comp":"17896441","content":"012d67d0"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/-040":{"__comp":"17896441","content":"8c6af858"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/error-handling-a82":{"__comp":"17896441","content":"10bebd98"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/loan-onboarding-253":{"__comp":"17896441","content":"09f5dc09"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/validation-request-dfc":{"__comp":"17896441","content":"d2cf49c0"},"/docs/pb/integrating/integrating-with-p8e/loan-onboarding-service/api-usage-guide/validation-response-727":{"__comp":"17896441","content":"3bc71cf1"},"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/-dd8":{"__comp":"17896441","content":"fb6cccac"},"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/deploying-the-encrypted-object-store/-3b3":{"__comp":"17896441","content":"fa64bb9a"},"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/deploying-the-encrypted-object-store/configuring-replication-c01":{"__comp":"17896441","content":"0b5aeaee"},"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/key-management/-a2d":{"__comp":"17896441","content":"b1242aa7"},"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/key-management/permissioning-others-c37":{"__comp":"17896441","content":"724624a5"},"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/p8e-contracts/-5af":{"__comp":"17896441","content":"201e8141"},"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/p8e-contracts/example-loan-contracts-f1e":{"__comp":"17896441","content":"4004cd87"},"/docs/pb/integrating/integrating-with-p8e/p8e-contract-execution-environment-p8e/summary-7cc":{"__comp":"17896441","content":"59979f1f"},"/docs/pb/modules/-acb":{"__comp":"17896441","content":"2671b8d3"},"/docs/pb/modules/attribute-module-f48":{"__comp":"17896441","content":"5485839b"},"/docs/pb/modules/cosmos-modules-c1c":{"__comp":"17896441","content":"37526ba3"},"/docs/pb/modules/ibc-and-zones-210":{"__comp":"17896441","content":"c83d36be"},"/docs/pb/modules/marker-module-4b9":{"__comp":"17896441","content":"0738acf9"},"/docs/pb/modules/metadata-module-862":{"__comp":"17896441","content":"4bbf0c85"},"/docs/pb/modules/name-module-373":{"__comp":"17896441","content":"dfccabea"},"/docs/pb/modules/provwasm-smart-contracts-7e3":{"__comp":"17896441","content":"38bc7367"},"/docs/pb/p8e/-5ae":{"__comp":"17896441","content":"2fd7c50c"},"/docs/pb/p8e/client-contract-execution-environment-faq-85b":{"__comp":"17896441","content":"932c8818"},"/docs/pb/p8e/components-1/api-3f6":{"__comp":"17896441","content":"37534510"},"/docs/pb/p8e/components-1/index-engine-824":{"__comp":"17896441","content":"dc6980cf"},"/docs/pb/p8e/contract-life-cycle-da1":{"__comp":"17896441","content":"9dcb1406"},"/docs/pb/p8e/overview/-1e0":{"__comp":"17896441","content":"91aa23a8"},"/docs/pb/p8e/overview/api-6b0":{"__comp":"17896441","content":"0ef3253a"},"/docs/pb/p8e/overview/api/-0cd":{"__comp":"17896441","content":"ab8de27a"},"/docs/pb/p8e/overview/api/authentication-280":{"__comp":"17896441","content":"a137ef52"},"/docs/pb/p8e/overview/api/contract-life-cycle-9d1":{"__comp":"17896441","content":"98dfef2a"},"/docs/pb/p8e/overview/api/index-engine-94d":{"__comp":"17896441","content":"f032e681"},"/docs/pb/p8e/overview/api/signing-and-encryption-8c0":{"__comp":"17896441","content":"22cfe006"},"/docs/pb/p8e/overview/encrypted-object-store/-eaa":{"__comp":"17896441","content":"c836b11f"},"/docs/pb/p8e/overview/encrypted-object-store/dime-encryption-envelope-specification-466":{"__comp":"17896441","content":"856cf724"},"/docs/pb/p8e/overview/encrypted-object-store/encryption-scheme-c42":{"__comp":"17896441","content":"78412288"},"/docs/pb/p8e/overview/p8e-transition-flow-86f":{"__comp":"17896441","content":"9ef3fdab"},"/docs/pb/p8e/overview/p8e-ui-1f8":{"__comp":"17896441","content":"84e93ef0"},"/docs/pb/p8e/p8e-usage/architecture-a3f":{"__comp":"17896441","content":"122dc7fc"},"/docs/pb/p8e/p8e-usage/building-new-contracts-979":{"__comp":"17896441","content":"6ff5f9db"},"/docs/pb/p8e/p8e-usage/cross-scope-contract-example-f62":{"__comp":"17896441","content":"ffcdb96d"},"/docs/pb/p8e/p8e-usage/data-retrieval-ebd":{"__comp":"17896441","content":"ea9d8076"},"/docs/pb/p8e/p8e-usage/multi-contract-example-cfb":{"__comp":"17896441","content":"68ed7ca5"},"/docs/pb/p8e/p8e-usage/multi-step-contract-example-147":{"__comp":"17896441","content":"a058717d"},"/docs/pb/p8e/p8e-usage/next-steps-fa5":{"__comp":"17896441","content":"bb0226cd"},"/docs/pb/p8e/p8e-usage/p8e-setup-f63":{"__comp":"17896441","content":"117a8e55"},"/docs/pb/p8e/p8e-usage/quick-start/-8a7":{"__comp":"17896441","content":"284af742"},"/docs/pb/p8e/p8e-usage/quick-start/hello-world-example-3f4":{"__comp":"17896441","content":"79037153"},"/docs/pb/p8e/p8e-usage/specifications-06b":{"__comp":"17896441","content":"0e876153"},"/docs/pb/p8e/security-81f":{"__comp":"17896441","content":"45bc127f"},"/docs/pb/p8e/untitled/-bfa":{"__comp":"17896441","content":"4cd95b83"},"/docs/pb/p8e/untitled/3rd-party-digital-signatures-f6f":{"__comp":"17896441","content":"7e5492a1"},"/docs/quick-start/become-a-validator-2dc":{"__comp":"17896441","content":"8f4f3548"},"/docs/quick-start/build-a-dapp-15e":{"__comp":"17896441","content":"544a1c6c"},"/docs/quick-start/start-here-069":{"__comp":"17896441","content":"302b56e9"},"/docs/quick-start/wallet-and-hash-72c":{"__comp":"17896441","content":"3a4a69ed"},"/docs/quick-start/write-a-smart-contract-e06":{"__comp":"17896441","content":"7a635e3f"},"/docs/sdk/-268":{"__comp":"17896441","content":"5389b6b3"},"/docs/sdk/attribute/-684":{"__comp":"17896441","content":"afe081df"},"/docs/sdk/attribute/events-357":{"__comp":"17896441","content":"23c728bd"},"/docs/sdk/attribute/messages-b04":{"__comp":"17896441","content":"01d09a63"},"/docs/sdk/attribute/params-eb3":{"__comp":"17896441","content":"6f229bd3"},"/docs/sdk/attribute/state-282":{"__comp":"17896441","content":"2b220663"},"/docs/sdk/exchange/-eca":{"__comp":"17896441","content":"0bba4e2f"},"/docs/sdk/exchange/concepts-8f7":{"__comp":"17896441","content":"17913518"},"/docs/sdk/exchange/events-4f5":{"__comp":"17896441","content":"3ea00ea9"},"/docs/sdk/exchange/messages-576":{"__comp":"17896441","content":"066f1a1f"},"/docs/sdk/exchange/params-18d":{"__comp":"17896441","content":"a26be617"},"/docs/sdk/exchange/queries-6bb":{"__comp":"17896441","content":"cd0fdc8b"},"/docs/sdk/exchange/state-d04":{"__comp":"17896441","content":"43079485"},"/docs/sdk/hold/-8ba":{"__comp":"17896441","content":"ab163351"},"/docs/sdk/hold/concepts-05a":{"__comp":"17896441","content":"36f8c416"},"/docs/sdk/hold/events-663":{"__comp":"17896441","content":"ffa4164d"},"/docs/sdk/hold/queries-91b":{"__comp":"17896441","content":"8033d4f2"},"/docs/sdk/hold/state-05d":{"__comp":"17896441","content":"e1b4a860"},"/docs/sdk/ibchooks/-32d":{"__comp":"17896441","content":"e94d5572"},"/docs/sdk/ibcratelimit/-6ea":{"__comp":"17896441","content":"82faa77e"},"/docs/sdk/marker/-6e3":{"__comp":"17896441","content":"50583958"},"/docs/sdk/marker/authorization-5df":{"__comp":"17896441","content":"f150ede0"},"/docs/sdk/marker/begin_block-faa":{"__comp":"17896441","content":"d143a44d"},"/docs/sdk/marker/end_block-225":{"__comp":"17896441","content":"10915e30"},"/docs/sdk/marker/events-2d3":{"__comp":"17896441","content":"e8bf91ff"},"/docs/sdk/marker/governance-177":{"__comp":"17896441","content":"8a4f7277"},"/docs/sdk/marker/hooks-7f7":{"__comp":"17896441","content":"f0ca0fdd"},"/docs/sdk/marker/messages-676":{"__comp":"17896441","content":"e790eacb"},"/docs/sdk/marker/params-899":{"__comp":"17896441","content":"dc56ea68"},"/docs/sdk/marker/state-e86":{"__comp":"17896441","content":"ba856710"},"/docs/sdk/marker/state_transitions-17e":{"__comp":"17896441","content":"a0c85ba5"},"/docs/sdk/marker/telemetry-d6c":{"__comp":"17896441","content":"dbc15c7d"},"/docs/sdk/marker/transfers-56a":{"__comp":"17896441","content":"8578622d"},"/docs/sdk/metadata/-631":{"__comp":"17896441","content":"6a0a334d"},"/docs/sdk/metadata/authz-e9f":{"__comp":"17896441","content":"f29001e3"},"/docs/sdk/metadata/concepts-42e":{"__comp":"17896441","content":"30ad14ec"},"/docs/sdk/metadata/events-ca5":{"__comp":"17896441","content":"b86c74f5"},"/docs/sdk/metadata/examples/kotlin/-47b":{"__comp":"17896441","content":"dc433783"},"/docs/sdk/metadata/messages-c25":{"__comp":"17896441","content":"73a09b8d"},"/docs/sdk/metadata/params-2d6":{"__comp":"17896441","content":"003f74ac"},"/docs/sdk/metadata/queries-f15":{"__comp":"17896441","content":"3bc15923"},"/docs/sdk/metadata/state-dbe":{"__comp":"17896441","content":"98c0552c"},"/docs/sdk/metadata/telemetry-c90":{"__comp":"17896441","content":"68ddbf57"},"/docs/sdk/msgfees/-146":{"__comp":"17896441","content":"65471103"},"/docs/sdk/msgfees/concepts-6fd":{"__comp":"17896441","content":"c77bf7af"},"/docs/sdk/msgfees/events-7d1":{"__comp":"17896441","content":"c203815b"},"/docs/sdk/msgfees/genesis-7ed":{"__comp":"17896441","content":"5b2b520a"},"/docs/sdk/msgfees/governance-a69":{"__comp":"17896441","content":"4c316eb3"},"/docs/sdk/msgfees/messages-ba4":{"__comp":"17896441","content":"ea1c85ff"},"/docs/sdk/msgfees/params-88d":{"__comp":"17896441","content":"f5484fe9"},"/docs/sdk/msgfees/queries-851":{"__comp":"17896441","content":"8aa6e8ab"},"/docs/sdk/msgfees/start_end_block-d30":{"__comp":"17896441","content":"35099a50"},"/docs/sdk/msgfees/state-f69":{"__comp":"17896441","content":"d4ee2c86"},"/docs/sdk/name/-feb":{"__comp":"17896441","content":"baf863e5"},"/docs/sdk/name/concepts-adc":{"__comp":"17896441","content":"7711cccf"},"/docs/sdk/name/events-93e":{"__comp":"17896441","content":"2eeef9d7"},"/docs/sdk/name/messages-0f6":{"__comp":"17896441","content":"f7212c74"},"/docs/sdk/name/params-aa0":{"__comp":"17896441","content":"d468077b"},"/docs/sdk/name/state-639":{"__comp":"17896441","content":"78a1e2b8"},"/docs/sdk/oracle/-07b":{"__comp":"17896441","content":"68b00b7c"},"/docs/sdk/oracle/concepts-0ae":{"__comp":"17896441","content":"538fdd7e"},"/docs/sdk/oracle/events-dc3":{"__comp":"17896441","content":"c3805537"},"/docs/sdk/oracle/genesis-83c":{"__comp":"17896441","content":"11b32f92"},"/docs/sdk/oracle/messages-247":{"__comp":"17896441","content":"468e17e2"},"/docs/sdk/oracle/queries-615":{"__comp":"17896441","content":"65148b81"},"/docs/sdk/oracle/state-d06":{"__comp":"17896441","content":"b9c66fb2"},"/docs/sdk/reward/-349":{"__comp":"17896441","content":"bd0296fc"},"/docs/sdk/reward/begin_and_end_blocker-feb":{"__comp":"17896441","content":"107ca8ff"},"/docs/sdk/reward/concepts-e25":{"__comp":"17896441","content":"a4721379"},"/docs/sdk/reward/events-7f7":{"__comp":"17896441","content":"633e38b7"},"/docs/sdk/reward/genesis-a9d":{"__comp":"17896441","content":"c0e3a46c"},"/docs/sdk/reward/messages-6bb":{"__comp":"17896441","content":"e3a5fbe4"},"/docs/sdk/reward/queries-c30":{"__comp":"17896441","content":"2e798e45"},"/docs/sdk/reward/state-c17":{"__comp":"17896441","content":"4f80c3ef"},"/docs/sdk/reward/state_transitions-46c":{"__comp":"17896441","content":"9aed69bf"},"/docs/sdk/trigger/-df5":{"__comp":"17896441","content":"9142477f"},"/docs/sdk/trigger/begin_and_end_blocker-0cd":{"__comp":"17896441","content":"019bb4c0"},"/docs/sdk/trigger/concepts-02f":{"__comp":"17896441","content":"dc884da2"},"/docs/sdk/trigger/events-dca":{"__comp":"17896441","content":"4cdbde10"},"/docs/sdk/trigger/genesis-576":{"__comp":"17896441","content":"0645a285"},"/docs/sdk/trigger/messages-c9c":{"__comp":"17896441","content":"1a2ebf8b"},"/docs/sdk/trigger/queries-849":{"__comp":"17896441","content":"d33615ad"},"/docs/sdk/trigger/state-501":{"__comp":"17896441","content":"9e031b8d"},"/-2bb":{"__comp":"1df93b7f","__context":{"plugin":"5ffcd300"},"config":"5e9f5e1a"}}')}},e=>{e.O(0,[532],(()=>{return t=97221,e(e.s=t);var t}));e.O()}]);