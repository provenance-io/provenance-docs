"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8977],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>v});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=i.createContext({}),l=function(e){var t=i.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return i.createElement(u.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},f=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,u=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=l(n),f=a,v=d["".concat(u,".").concat(f)]||d[f]||p[f]||r;return n?i.createElement(v,o(o({ref:t},c),{},{components:n})):i.createElement(v,o({ref:t},c))}));function v(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=f;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s[d]="string"==typeof e?e:a,o[1]=s;for(var l=2;l<r;l++)o[l]=n[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}f.displayName="MDXCreateElement"},2604:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var i=n(7462),a=(n(7294),n(3905));const r={},o="Identity Attribute Values",s={unversionedId:"learn/dapps/identity-verification/attribute-values",id:"learn/dapps/identity-verification/attribute-values",title:"Identity Attribute Values",description:"When crafting Attribute values for identity verification on Provenance Blockchain, it is crucial to determine what data",source:"@site/docs/learn/dapps/identity-verification/attribute-values.md",sourceDirName:"learn/dapps/identity-verification",slug:"/learn/dapps/identity-verification/attribute-values",permalink:"/docs/learn/dapps/identity-verification/attribute-values",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"dappsSidebar",previous:{title:"Identity Attribute Names",permalink:"/docs/learn/dapps/identity-verification/attribute-names"},next:{title:"Identity NFTs",permalink:"/docs/learn/dapps/identity-verification/identity-nfts"}},u={},l=[{value:"Ensuring Privacy and Security",id:"ensuring-privacy-and-security",level:2},{value:"Handling Expiration Dates and Status Fields",id:"handling-expiration-dates-and-status-fields",level:2},{value:"Data Types",id:"data-types",level:2}],c={toc:l},d="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"identity-attribute-values"},"Identity Attribute Values"),(0,a.kt)("p",null,"When crafting Attribute values for identity verification on Provenance Blockchain, it is crucial to determine what data\nshould be included in an Attribute value. Since attributes on a blockchain account are publicly readable, it is\nessential to consider privacy and security. This article discusses what should or could go into an Attribute value for\nidentity verification on the Provenance Blockchain."),(0,a.kt)("h2",{id:"ensuring-privacy-and-security"},"Ensuring Privacy and Security"),(0,a.kt)("p",null,"The primary rule is to ",(0,a.kt)("strong",{parentName:"p"},"never include any Personally Identifying Information (PII) in the Attribute value"),". Once the\nAttribute data is written to the chain, it is impossible to retract the information. The Attribute value's content is left to the\nidentity provider's discretion. The Attribute name should convey the credential type, while the Attribute value should\ncontain a simple, opaque reference identifier to the user's KYC data stored at the identity provider."),(0,a.kt)("admonition",{type:"danger"},(0,a.kt)("p",{parentName:"admonition"},"Never include any Personally Identifying Information (PII) in the Attribute value")),(0,a.kt)("p",null,"A minimal Attribute value example might be a customer or verification process reference ID. This ID can be used by a\ndApp or service to present to the identity provider when requesting user identity details. Alternatively, the identity\nprovider could include a full URI for obtaining the identity data, provided the customer authorizes access."),(0,a.kt)("h2",{id:"handling-expiration-dates-and-status-fields"},"Handling Expiration Dates and Status Fields"),(0,a.kt)("p",null,'Most identity verification processes are valid for a limited time. It may seem logical to include an expiration date or\nstatus field in the Attribute value, but this approach has downsides. Including an "expiration date" field relies on the\nconsuming application remembering to parse and respect the field. Similarly, incorporating a field for status or data state, such as\n"pending," "completed," or "expired," places the responsibility on applications to parse and respect these semantic\nvalues.'),(0,a.kt)("p",null,"A recommended approach is to include an issue date (but not an expiration date) for the Attribute. This allows the\nconsuming application to decide how current their credential requirements must be. Another method is for the identity\nprovider to delete the Attribute from the user account when it expires or becomes invalid. This way, consuming\napplications can reason about the Attribute using only the presence or absence of the Attribute as the definitive flag\nfor the credential's current validity."),(0,a.kt)("h2",{id:"data-types"},"Data Types"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/provenance-io/provenance/blob/main/proto/provenance/attribute/v1/attribute.proto#L32"},"AttributeType enum"),"\ndefines the different types of data that can be stored in an Attribute value. It is important to choose the appropriate\ntype based on the data being stored, ensuring both privacy and functionality."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-protobuf"},'// AttributeType defines the type of the data stored in the attribute value\nenum AttributeType {\n  // ATTRIBUTE_TYPE_UNSPECIFIED defines an unknown/invalid type\n  ATTRIBUTE_TYPE_UNSPECIFIED = 0 [(gogoproto.enumvalue_customname) = "Unspecified"];\n  // ATTRIBUTE_TYPE_UUID defines an attribute value that contains a string value representation of a V4 uuid\n  ATTRIBUTE_TYPE_UUID = 1 [(gogoproto.enumvalue_customname) = "UUID"];\n  // ATTRIBUTE_TYPE_JSON defines an attribute value that contains a byte string containing json data\n  ATTRIBUTE_TYPE_JSON = 2 [(gogoproto.enumvalue_customname) = "JSON"];\n  // ATTRIBUTE_TYPE_STRING defines an attribute value that contains a generic string value\n  ATTRIBUTE_TYPE_STRING = 3 [(gogoproto.enumvalue_customname) = "String"];\n  // ATTRIBUTE_TYPE_URI defines an attribute value that contains a URI\n  ATTRIBUTE_TYPE_URI = 4 [(gogoproto.enumvalue_customname) = "Uri"];\n  // ATTRIBUTE_TYPE_INT defines an attribute value that contains an integer (cast as int64)\n  ATTRIBUTE_TYPE_INT = 5 [(gogoproto.enumvalue_customname) = "Int"];\n  // ATTRIBUTE_TYPE_FLOAT defines an attribute value that contains a float\n  ATTRIBUTE_TYPE_FLOAT = 6 [(gogoproto.enumvalue_customname) = "Float"];\n  // ATTRIBUTE_TYPE_PROTO defines an attribute value that contains a serialized proto value in bytes\n  ATTRIBUTE_TYPE_PROTO = 7 [(gogoproto.enumvalue_customname) = "Proto"];\n  // ATTRIBUTE_TYPE_BYTES defines an attribute value that contains an untyped array of bytes\n  ATTRIBUTE_TYPE_BYTES = 8 [(gogoproto.enumvalue_customname) = "Bytes"];\n}\n')))}p.isMDXComponent=!0}}]);