"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1916],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(n),m=r,g=p["".concat(c,".").concat(m)]||p[m]||u[m]||i;return n?a.createElement(g,o(o({ref:t},d),{},{components:n})):a.createElement(g,o({ref:t},d))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8677:(e,t,n)=>{n.d(t,{Y:()=>r});var a=n(7294);const r=e=>{let{text:t}=e;return a.createElement("p",{className:"pb-5 mb-5 -mt-3 border-0 border-b border-b-gray-300 border-solid text-gray-500"},t)}},9810:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var a=n(7462),r=(n(7294),n(3905)),i=n(8677);const o={},s="405 - Smart Contract Lifecycle and Version Transition",c={unversionedId:"pb/contributing/adr/smart-contracts/upgrading",id:"pb/contributing/adr/smart-contracts/upgrading",title:"405 - Smart Contract Lifecycle and Version Transition",description:"1. Lifecycle of a Smart Contract",source:"@site/docs/pb/contributing/adr/400-smart-contracts/405-upgrading.mdx",sourceDirName:"pb/contributing/adr/400-smart-contracts",slug:"/pb/contributing/adr/smart-contracts/upgrading",permalink:"/docs/pb/contributing/adr/smart-contracts/upgrading",draft:!1,tags:[],version:"current",sidebarPosition:405,frontMatter:{},sidebar:"documentationSidebar",previous:{title:"404 - Omnibus",permalink:"/docs/pb/contributing/adr/smart-contracts/omnibus"},next:{title:"500 Administration",permalink:"/docs/pb/contributing/adr/administration"}},l={},d=[{value:"1. Lifecycle of a Smart Contract",id:"1-lifecycle-of-a-smart-contract",level:2},{value:"Deployment Plan",id:"deployment-plan",level:3},{value:"Version Transition (v1 to v2)",id:"version-transition-v1-to-v2",level:3},{value:"2. Migration and User Transition Strategies",id:"2-migration-and-user-transition-strategies",level:2},{value:"Developer&#39;s Responsibility",id:"developers-responsibility",level:3},{value:"Communication and Deprecation",id:"communication-and-deprecation",level:3},{value:"3. Data Handling and Integrity",id:"3-data-handling-and-integrity",level:2},{value:"Data Maintenance and Migration",id:"data-maintenance-and-migration",level:3},{value:"4. Risks and Challenges",id:"4-risks-and-challenges",level:2},{value:"5. Additional Notes",id:"5-additional-notes",level:2}],p={toc:d},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"405---smart-contract-lifecycle-and-version-transition"},"405 - Smart Contract Lifecycle and Version Transition"),(0,r.kt)(i.Y,{text:"The typical lifecycle of a smart contract within the ecosystem, focusing on the transition process from version 1 (v1) to version 2 (v2), and the procedures and policies associated with this process.",mdxType:"DocSubheader"}),(0,r.kt)("h2",{id:"1-lifecycle-of-a-smart-contract"},"1. Lifecycle of a Smart Contract"),(0,r.kt)("h3",{id:"deployment-plan"},"Deployment Plan"),(0,r.kt)("p",null,"The deployment of a smart contract typically follows these steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Build and Compile:")," The initial step where the contract is built and compiled."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Store/Deploy Contract:")," The contract is then stored/deployed to the Provenance blockchain network. This process involves submitting a governance proposal that includes the encoded WebAssembly (WASM) and metadata about the contract such as notes, repository links, and admin details. A unique code id, used to reference the stored code, is created if the proposal is passed."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Instantiate Contract:")," Using the obtained code ID, the contract is instantiated."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Execute/Invoke Contract:")," The contract is then ready for execution or invocation."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Development of New Features:")," New features for the contract are coded."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Store/Deploy Updated Contract:")," The updated contract code is stored/deployed, again through a governance proposal, which returns a new code ID."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Migrate Existing Contract:")," The existing contract is migrated to the new code ID, effectively upgrading the contract.")),(0,r.kt)("h3",{id:"version-transition-v1-to-v2"},"Version Transition (v1 to v2)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Upon upgrading, the contract address remains the same but runs the migrated (new) code."),(0,r.kt)("li",{parentName:"ul"},"The v1 version of the contract is no longer active and cannot be interacted with; the v1 instance effectively becomes the v2 version.")),(0,r.kt)("p",{className:"p-4 bg-sky-100 rounded-lg shadow-md max-w-xl m-auto"},(0,r.kt)("span",{className:"font-bold block text-xl border-0 border-b border-sky-200 pb-1 mb-1 border-solid"},"Note"),"The v1 code remains stored and could be instantiated with its code ID, but the specific migrated instance permanently changes to run the new version."),(0,r.kt)("h2",{id:"2-migration-and-user-transition-strategies"},"2. Migration and User Transition Strategies"),(0,r.kt)("h3",{id:"developers-responsibility"},"Developer's Responsibility"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Developers are responsible for ensuring successful migration. This typically involves proper deprecation of APIs, storing version data in the contract, and migrating stored data.")),(0,r.kt)("h3",{id:"communication-and-deprecation"},"Communication and Deprecation"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"There is no standard deprecation policy. Communication about upgrades and changes is typically done out-of-band by the developers to their clients."),(0,r.kt)("li",{parentName:"ul"},"A proper deprecation process involves maintaining the previous version API along with the new API, allowing older clients to update their code in parallel with the new version.")),(0,r.kt)("h2",{id:"3-data-handling-and-integrity"},"3. Data Handling and Integrity"),(0,r.kt)("h3",{id:"data-maintenance-and-migration"},"Data Maintenance and Migration"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'The duration for which data is stored depends on the contract\'s function. A "skeleton" contract upgrade can be used to delete stored data and remove admin access, essentially sunsetting the older contract.'),(0,r.kt)("li",{parentName:"ul"},"It's crucial to maintain data integrity during migration, and in cases of corruption, recovery from previous blocks might be possible, though this is not a standard practice and has not been widely performed.")),(0,r.kt)("h2",{id:"4-risks-and-challenges"},"4. Risks and Challenges"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Bad upgrades, such as those with flawed data migration logic or broken functions, require the updated contract code to be uploaded and migrated to."),(0,r.kt)("li",{parentName:"ul"},"In case of migration failure due to errors, the transaction fails and no changes are made. However, issues arising from bad programming logic (not actual transaction errors) are permanent and require subsequent fixes.")),(0,r.kt)("h2",{id:"5-additional-notes"},"5. Additional Notes"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Once a contract is updated from v1 to v2, v2 takes over and v1 can no longer be called."),(0,r.kt)("li",{parentName:"ul"},"The process of migration updates the version state data, indicating the transition from v1 to v2."),(0,r.kt)("li",{parentName:"ul"},"It's important to note that once migrated, there is no reversing to the previous version. Any necessary corrections must be addressed by moving forward with new updates and migrations.")))}m.isMDXComponent=!0}}]);